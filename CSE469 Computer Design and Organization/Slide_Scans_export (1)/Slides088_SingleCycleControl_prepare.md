

---

## 第 1 页

![第 1 页](Slides088_SingleCycleControl_assets/page-001.png)

这张图展示的是一个**只支持 LDUR（Load Register Unsigned）和 STUR（Store Register Unsigned）两条指令**的**单周期 CPU（Single-Cycle CPU）设计示意图**。它要求“尽可能简单”，所以省略了分支、算术逻辑运算等复杂模块，只保留最基础的取数、访存、寄存器和地址计算部分。

---

## 🧩 一、整体思路

这是一个非常简化的单周期 CPU，核心功能是：

* 能**从内存取数（LDUR）**；
* 能**向内存写数（STUR）**；
* 每条指令都在一个时钟周期内完成。

程序计数器（PC）每次增加 4，表示指令按字节顺序依次执行（每条指令占 4 字节）。

---

## ⚙️ 二、数据通路（Datapath）分析

图中从左到右的模块代表执行顺序：

1. **PC（Program Counter）**

* 存储当前指令的地址；
* 每个周期更新为 `PC + 4`；
* 输出给“指令存储器（Instruction Memory）”。

2. **Instruction Memory（指令存储器）**

* 根据 PC 取出当前指令；
* 输出字段：操作码（opcode）、寄存器编号（Rs, Rt, Rd）、偏移量（offset）等；
* 输出连接到寄存器堆和控制逻辑。

3. **Register File（寄存器堆）**

* 输入：两个读地址（A、B）、一个写地址（Rd）、写数据；
* 输出：两个读数据（Da, Db）；
* 支持写入（如执行 LDUR 后把读取的数据写回寄存器）。

4. **Adder（加法器）**

* 功能：地址计算；
* 输入：`base register`（Rs的内容）+ `SE(offset)`（偏移的符号扩展）；
* 输出：访问内存的实际地址。

5. **Data Memory（数据存储器）**

* 用于加载/存储数据；
* 输入：

* 地址（来自Adder）；
* 写数据（Db，来自寄存器堆）；
* 控制信号（MemRead/MemWrite）。
* 输出：

* 读出的数据（Memory Data），返回给寄存器堆用于写回。

---

## 🧮 三、控制逻辑（Control Signals）

图中虽然没画出完整控制模块，但笔记里有相应逻辑说明：

### LDUR 指令：

```
Addr = Rs[CPU] + SE(offset)
Register[Rd] = Mem[Addr]
PC = PC + 4
```

意思是：

* 用基址寄存器 `Rs` 加上偏移得到内存地址；
* 从该地址加载数据到寄存器 `Rd`；
* PC 自增 4。

### STUR 指令：

```
Addr = Rs[CPU] + SE(offset)
Mem[Addr] = Register[Rd]
PC = PC + 4
```

意思是：

* 计算相同的地址；
* 把寄存器 `Rd` 的值写入内存；
* PC 同样加 4。

两条指令除了**读写方向不同**，路径几乎一致，因此 CPU 可以用同一套数据通路，通过 `MemWrite` 控制信号区分是读取（LDUR）还是写入（STUR）。

---

## 🔁 四、执行流程总结

以 LDUR 为例的执行过程：

1. PC 提供地址给指令存储器；
2. 指令被取出；
3. 控制逻辑解码操作码；
4. 从寄存器堆读取 Rs；
5. 偏移量符号扩展后，与 Rs 相加得到内存地址；
6. 从内存读取数据；
7. 把数据写回寄存器 Rd；
8. PC 加 4，准备执行下一条指令。

STUR 仅在第 6、7 步交换方向。

---

## 🧠 五、主要特征

* **单周期设计**：取指、译码、访存、写回都在一个周期内完成；
* **结构简单**：只支持两条数据存取指令；
* **无流水线、无控制冒险**；
* **指令固定长度（4字节）**；
* **主通路清晰**：寄存器 → 加法器 → 内存 → 寄存器。

---

## ✅ 总结归纳

\[口语化表达]
这图其实是在画一个“最小可用”的单周期 CPU，只能执行加载（LDUR）和存储（STUR）两条指令。它的工作流程是这样的：先从 PC 指定的地方拿指令，然后根据寄存器和偏移量算出一个地址，再看是要“从内存拿数据回来”还是“把数据存进去”。LDUR 就是读，STUR 就是写，最后 PC 加 4 跳到下一条指令。整套逻辑用一个加法器、一个寄存器堆、一个数据存储器就能实现，思路非常基础但完整。


---

## 第 2 页

![第 2 页](Slides088_SingleCycleControl_assets/page-002.png)

这张图展示的是单周期 CPU 控制单元（Control Unit）的“控制信号真值表”，也就是不同指令对应的控制信号设置，用来告诉 CPU 在执行时各个模块（ALU、寄存器堆、存储器等）该怎么工作。下面我们逐项说明。

---

## 🧩 一、表格结构概览

从右到左依次是：

| 项目                                  | 含义                                  |
| ----------------------------------- | ----------------------------------- |
| **Opcode\[31:26] / Opcode\[25:21]** | 每条指令的操作码（机器码前几位），CPU 通过它判断是哪种指令。    |
| **指令名**                             | 对应的汇编指令：ADD、SUB、LDUR、STUR、B、CBZ。    |
| **Reg2Loc**                         | 控制寄存器堆读端口B的地址来源（0=来自指令Rt，1=来自指令Rm）。 |
| **ALUSrc**                          | 决定 ALU 第二个输入来自寄存器（0）还是立即数/偏移量（1）。   |
| **MemToReg**                        | 寄存器写回的数据来自内存（1）还是来自 ALU（0）。         |
| **RegWrite**                        | 是否写回寄存器堆（1=写回）。                     |
| **MemWrite**                        | 是否向数据存储器写入（1=写入）。                   |
| **Branch**                          | 是否为分支跳转指令（1=跳转）。                    |
| **MemRead**                         | 是否从内存读取数据（1=读）。                     |
| **ALUOp**                           | 告诉 ALU 执行什么操作（如加、减、传递等）。            |

---

## ⚙️ 二、各条指令的控制信号解释

### 1️⃣ ADD（加法指令）

* **Opcode**: `100010 11000`
* **功能**: 将两个寄存器的内容相加，结果写回目标寄存器。
* **信号分析**:

* `Reg2Loc = 1` → 第二个寄存器来源是 Rm。
* `ALUSrc = 0` → ALU 的第二输入来自寄存器。
* `MemToReg = 0` → 写回寄存器的数据来自 ALU。
* `RegWrite = 1` → 启用写回寄存器。
* `MemRead / MemWrite / Branch = 0` → 不访问内存、不跳转。
* `ALUOp = +` → ALU 执行加法。

---

### 2️⃣ SUB（减法指令）

* **Opcode**: `110010 11000`
* **功能**: 两寄存器相减，结果写回。
* **信号分析**:

* `Reg2Loc = 1`
* `ALUSrc = 0`
* `MemToReg = 0`
* `RegWrite = 1`
* 其他同上。
* `ALUOp = -` → ALU 执行减法。

---

### 3️⃣ LDUR（加载指令）

* **Opcode**: `111110 00010`
* **功能**: 从内存读数据存入寄存器。
* **信号分析**:

* `Reg2Loc = 0` → 不用 Rm。
* `ALUSrc = 1` → 地址计算时使用偏移量。
* `MemToReg = 1` → 从内存读出的数据写回寄存器。
* `RegWrite = 1` → 寄存器需要写回。
* `MemRead = 1` → 读取内存。
* `MemWrite / Branch = 0`
* `ALUOp = +` → 地址计算使用加法。

---

### 4️⃣ STUR（存储指令）

* **Opcode**: `111110 00000`
* **功能**: 将寄存器的数据写入内存。
* **信号分析**:

* `Reg2Loc = 1` → 要读取要写入内存的数据。
* `ALUSrc = 1` → 使用偏移量计算地址。
* `MemToReg = X` → 不关心（没有寄存器写回）。
* `RegWrite = 0` → 不写回寄存器。
* `MemWrite = 1` → 写内存。
* `MemRead = 0`
* `ALUOp = +` → 地址加法。

---

### 5️⃣ B（无条件跳转）

* **Opcode**: `000101`
* **功能**: 无条件修改 PC。
* **信号分析**:

* `Reg2Loc, MemToReg` 不使用。
* `Branch = 1` → 启用跳转。
* `RegWrite, MemRead, MemWrite = 0`
* `ALUOp = PassB` → ALU 传递偏移量值。

---

### 6️⃣ CBZ（条件跳转，Compare and Branch if Zero）

* **Opcode**: `10110100`
* **功能**: 检查寄存器是否为零，若为零则跳转。
* **信号分析**:

* `Reg2Loc = 0`
* `ALUSrc = 0` → 比较寄存器内容。
* `MemToReg, MemRead, MemWrite, RegWrite = 0`
* `Branch = 1` → 条件跳转。
* `ALUOp = PassB`（或零检测）
* 表中括号标注“(zero)”说明要依赖 ALU 输出的 Zero 标志位。

---

## 🧠 三、规律总结

| 指令类型           | 特征     | 关键控制信号                                  |
| -------------- | ------ | --------------------------------------- |
| R 型（ADD、SUB）   | 寄存器间运算 | `ALUSrc=0, RegWrite=1, MemRead/Write=0` |
| D 型（LDUR、STUR） | 内存访问类  | `ALUSrc=1, MemRead/MemWrite 有变化`        |
| B 型（B、CBZ）     | 分支跳转类  | `Branch=1, ALUOp=PassB`                 |

---

## ✅ 总结归纳

\[口语化表达]
这张表其实就是 CPU 的“操作指南”，告诉它每种指令要怎么控制各个部件。比如 ADD、SUB 是在寄存器之间算加减；LDUR 是去内存里取数；STUR 是把数据写进内存；B 是无条件跳转；CBZ 是判断寄存器是不是 0 来决定跳不跳。每个“0”“1”“X”都是控制信号的开关，控制 ALU 要不要加法、寄存器要不要写回、内存要不要读写、要不要跳转。CPU 执行指令时，就像照这张表一行一行地查，看到是哪条指令，就按对应信号去驱动整个数据通路。


---

## 第 3 页

![第 3 页](Slides088_SingleCycleControl_assets/page-003.png)

这页是“ADD 指令的控制与数据通路（ADD Control）”示意图，展示**单周期 CPU 执行一条 `ADD` 指令**时，所有主要部件如何连线、哪些多路选择器（MUX）该选哪一路、以及控制信号该取什么值。右上角的伪代码给出本条指令的语义：

```
Instruction = Mem[PC];
Reg[Rd] = Reg[Rn] + Reg[Rm];
PC = PC + 4;
```

下面按模块说明整条指令在一个时钟内走完的路径与控制：

---

## 1) 取指 & PC 更新

* **PC** 把当前值送到 **Instruction Memory**（指令存储器）→ 取出 32 位指令。
* 右侧有两个加法器：

* 一个做 **PC+4**（下一条顺序地址）；
* 另一个用于计算**分支目标**（CondAddr19 / BrAddr26 经过符号扩展 SE，再左移后与 PC 相加）。
* 下方两个 MUX：

* **BrTaken**（条件跳转有效）和 **UncondBr**（无条件跳转）在 ADD 指令下均为 **0**，


---

## 第 4 页

![第 4 页](Slides088_SingleCycleControl_assets/page-004.png)

这张图展示的是\*\*SUB 指令（减法）\*\*在单周期 CPU 中的控制信号路径和数据通路，也就是 CPU 执行
`Rd = Rn - Rm` 这条指令时，内部硬件是如何协同工作的。

---

## 🧩 一、整体结构概述

标题 **SUB Control** 表示这是 SUB（Subtract）指令的控制信号流程图。
右上角公式写着：

```
Instruction = Mem[PC];
Reg[Rd] = Reg[Rn] - Reg[Rm];
PC = PC + 4;
```

也就是：

1. 从指令存储器读取一条指令；
2. 执行寄存器 Rn - Rm；
3. 将结果写回 Rd；
4. PC（程序计数器）自增 4，准备执行下一条指令。

---

## ⚙️ 二、各模块功能详解

整张图的结构和“ADD 控制”图几乎相同，


---

## 第 5 页

![第 5 页](Slides088_SingleCycleControl_assets/page-005.png)

这张图展示的是**LDUR（Load Register Unsigned）指令的控制路径图（LDUR Control）**，也就是单周期 CPU 在执行“从内存加载数据到寄存器”这条指令时，数据在 CPU 内部各个部件之间如何流动、哪些控制信号被激活。下面我来详细分解。

---

## 🧩 一、LDUR 指令的含义

在汇编语言中：

```
LDUR Rd, [Rn, #offset]
```

表示：

> 从地址 = 寄存器 Rn + 偏移量 offset 的内存位置，读取一个字（word），存入目标寄存器 Rd。

对应图中右侧伪代码：

```
Instruction = Mem[PC];
Addr = Reg[Rn] + SignExtend(DAddr9);
Reg[Rd] = Mem[Addr];
PC = PC + 4;
```

这意味着：

1. 从指令存储器中取出当前指令；
2. 取出寄存器 Rn 的值；
3. 将立即数偏移（DAddr9）进行符号扩展后与 Rn 相加，得到内存地址；
4. 从该内存地址取出数据；
5. 将数据写入寄存器 Rd；
6. PC（程序计数器）增加 4，执行下一条指令。

---

## ⚙️ 二、图中各模块与信号解释

### 1️⃣ **Instruction Memory（指令存储器）**

* 输入：来自 PC（程序计数器）的地址；
* 输出：当前指令；
* 同时 PC 每周期加 4（见右侧下方两个加法器）；
* 指令分解出：Rn、Rd、DAddr9 等字段。

---

### 2️⃣ **Register File（寄存器堆）**

* 读出 Rn（基址寄存器）的内容；
* 写回 Rd（目标寄存器）的内容；
* 控制信号：

* `RegWrite = 1` → 启用写寄存器；
* `Reg2Loc = 0` → 使用 Rn，不涉及 Rm（第二操作数在 LDUR 中无用）。

---

### 3️⃣ **ALU（算术逻辑单元）**

* 输入：

* 一个来自寄存器 Rn；
* 另一个来自符号扩展后的偏移量（由控制信号 ALUSrc 控制）；
* 操作：

* 计算 `Addr = Rn + offset`；
* 控制信号 `ALUOp = +`；
* 输出：

* 结果送入数据存储器的地址输入端。

---

### 4️⃣ **Data Memory（数据存储器）**

* 输入：

* 地址 Addr（由 ALU 计算）；
* 控制信号 `MemRead = 1`（读取模式），`MemWrite = 0`；
* 输出：

* 读取出的数据送回寄存器堆；
* 控制信号：

* `MemToReg = 1` → 选择“内存输出”写回寄存器；
* `MemWrite = 0`（因为此时只读不写）。

---

### 5️⃣ **PC + 4 更新逻辑**

* 右下角部分展示：

* 两个加法器；
* 分支选择器；
* `UncondBr` 与 `BrTaken` 控制信号；
* 在 LDUR 中这部分不使用，PC 仅简单加 4。

---

## 🔧 三、关键控制信号总结

| 控制信号                  | 含义            | LDUR 值 |
| --------------------- | ------------- | ------ |
| **Reg2Loc**           | 选择寄存器输入来源     | 0      |
| **ALUSrc**            | ALU 第二输入来自偏移量 | 1      |
| **MemToReg**          | 写回寄存器来自内存     | 1      |
| **RegWrite**          | 是否写寄存器        | 1      |
| **MemWrite**          | 是否写内存         | 0      |
| **MemRead**           | 是否读内存         | 1      |
| **ALUOp**             | ALU 操作类型      | 加法     |
| **Branch / UncondBr** | 是否跳转          | 0      |

---

## 🧠 四、数据流动路径总结

完整路径如下：

```
PC → Instruction Memory → (取出指令)
→ 寄存器堆读 Rn
→ SE 扩展偏移量
→ ALU 加法计算出地址
→ Data Memory 从该地址读出数据
→ 写回寄存器 Rd
→ PC + 4 进入下一条指令
```

---

## ✅ 五、LDUR 的特点

* 典型的“取数类（load-type）”指令；
* 涉及访存与寄存器写回；
* ALU 只用于地址计算；
* 指令执行顺序简单清晰；
* 不改变控制流（不跳转）。

---

## 🗣️ 总结归纳

\[口语化表达]
这张图其实在画 CPU 执行“从内存读数据进寄存器”的全过程。LDUR 指令干的事就是：用寄存器 Rn 的值加上偏移量去算一个地址，然后去内存那拿数据，再把拿到的结果写回 Rd。图里可以看到，ALU 在算地址，数据存储器在读数据，寄存器堆在写数据，控制信号像“MemRead=1、MemWrite=0、ALUSrc=1、MemToReg=1”这些都对应着这个过程。最后 PC 再加 4 去取下一条指令。整体上，这是一个典型的单周期“取数操作”，控制逻辑也相对最简单。


---

## 第 6 页

![第 6 页](Slides088_SingleCycleControl_assets/page-006.png)

这张图展示的是 **STUR（Store Register Unsigned）指令的控制路径图（STUR Control）**，说明单周期 CPU 在执行“把寄存器的数据存入内存”时，内部数据是怎么流动的、各个控制信号如何起作用。它和前一页的 LDUR 图（加载指令）非常相似，只是数据流动方向相反。

---

## 🧩 一、STUR 指令的作用

在汇编语言中：

```
STUR Rt, [Rn, #offset]
```

意思是：

> 取寄存器 Rt 的值，把它写入内存中地址 = Rn + offset 的位置。

右上角的伪代码对应：

```
Instruction = Mem[PC];
Addr = Reg[Rn] + SignExtend(DAddr9);
Mem[Addr] = Reg[Rd];
PC = PC + 4;
```

也就是说：

1. 从指令存储器（Instruction Memory）取出当前指令；
2. 用 Rn 的内容 + 偏移量（经过符号扩展）计算出内存地址；
3. 从寄存器 Rd 读出要写入的数据；
4. 把这个数据写进内存；
5. PC 自增 4，准备执行下一条指令。

---

## ⚙️ 二、图中模块详细解释

### 1️⃣ **PC 与指令存储器**

* **PC**：当前指令地址；
* **Instruction Memory**：根据 PC 取出指令；
* 右下角的两个加法器负责 **PC + 4**，并提供下一条指令地址；
* STUR 不需要分支控制，因此图中右侧的 **Branch 部分（UncondBr, BrTaken）** 实际上不参与运算。

---

### 2️⃣ **寄存器堆（Register File）**

* 指令的字段包括：

* `Rn` → 基址寄存器；
* `Rd` → 存放数据的寄存器（要写入内存的数据）；
* `DAddr9` → 地址偏移。
* **Reg2Loc = 1**：控制多路选择器选择寄存器 Rm（或 Rd）作为第二输入；
* 读出两个寄存器的值：

* `Rn` → 用于计算内存地址；
* `Rd` → 要写入内存的数据；
* STUR 不需要写回寄存器，所以：

* `RegWrite = 0`；
* `MemToReg` 信号无关。

---

### 3️⃣ **ALU（算术逻辑单元）**

* 输入：

* `A` = Rn；
* `B` = SignExtend(DAddr9)（偏移量经过符号扩展）；
* 计算：

```
Addr = Rn + offset
```
* 控制信号：

* `ALUSrc = 1`（第二输入来自偏移量）；
* `ALUOp = +`（执行加法）。

ALU 的输出是目标内存地址，接入 Data Memory 的地址端口。

---

### 4️⃣ **数据存储器（Data Memory）**

* 输入：

* **地址**：来自 ALU；
* **写入数据**：来自寄存器 Rd；
* **控制信号**：

* `MemWrite = 1`（允许写入）；
* `MemRead = 0`；
* 输出：

* 无（STUR 只写不读）；
* 注意图中写入方向：`Din ← Db`，Db 就是寄存器堆输出的 Rd 内容。

---

### 5️⃣ **控制信号总结**

| 控制信号                  | 含义            | STUR 值 |
| --------------------- | ------------- | ------ |
| **Reg2Loc**           | 选择第二个寄存器字段    | 1      |
| **ALUSrc**            | ALU 第二输入来自偏移量 | 1      |
| **MemToReg**          | 不适用（X）        |        |
| **RegWrite**          | 不写回寄存器        | 0      |
| **MemWrite**          | 写内存           | 1      |
| **MemRead**           | 不读内存          | 0      |
| **ALUOp**             | 加法（地址计算）      | +      |
| **Branch / UncondBr** | 不分支           | 0      |

---

## 🔄 三、执行流程总结

执行步骤如下：

1. 从 PC 对应的地址取指令；
2. 从寄存器堆读出 Rn（基址）和 Rd（要写入的值）；
3. 符号扩展 DAddr9，并与 Rn 相加计算出内存地址；
4. 把寄存器 Rd 的数据通过数据总线送入内存；
5. 控制信号 MemWrite=1，触发写操作；
6. 写入完成后，PC += 4，进入下一条指令。

---

## 🧠 四、STUR 与 LDUR 对比

| 项目           | **LDUR（读）** | **STUR（写）** |
| ------------ | ----------- | ----------- |
| **数据流向**     | 内存 → 寄存器    | 寄存器 → 内存    |
| **MemRead**  | 1           | 0           |
| **MemWrite** | 0           | 1           |
| **RegWrite** | 1           | 0           |
| **MemToReg** | 1           | X           |
| **ALUSrc**   | 1           | 1           |
| **ALUOp**    | +           | +           |
| **核心功能**     | 取数据         | 存数据         |

---

## ✅ 五、整体理解

STUR 指令的主要功能就是 **“写入内存”**，
CPU 通过 ALU 计算出目标地址，然后把寄存器中的数据存进去。
这条指令只用到了 ALU、寄存器堆、数据存储器，不需要寄存器写回路径，也不需要分支逻辑。

---

## 🗣️ 总结归纳

\[口语化表达]
这张图画的是 CPU 执行“把寄存器数据存进内存”的整个流程。STUR 指令就是拿 Rn 的值加上偏移量算出一个内存地址，然后把寄存器 Rd 里的数据写到那儿去。图里可以看到 ALU 负责算地址，Data Memory 负责存数据，RegFile 负责提供要写入的数。控制信号方面，`MemWrite=1` 代表要写内存，`RegWrite=0` 因为不写寄存器，`ALUSrc=1` 代表地址要加偏移量。这整套逻辑和 LDUR 是对称的，一个是“从内存取”，一个是“往内存放”。


---

## 第 7 页

![第 7 页](Slides088_SingleCycleControl_assets/page-007.png)

这页是 **B（无条件跳转）指令的控制路径图**。它专门展示：当执行 `B` 指令时，CPU 如何计算分支目标地址并把它送回 PC，从而实现跳转。图中被高亮的右侧部分就是“**更新 PC 的分支通路**”。

---

## 一、B 指令做了什么？

右上角伪代码：

```
Instruction = Mem[PC];
PC = PC + SignExtend(BrAddr26) << 2;
```

含义：

* 先按 `PC` 从指令存储器取出 `B` 指令；
* 指令中有一个 **26 位立即数 BrAddr26**（相对偏移）；
* 把它**符号扩展**到 64 位，再 **左移 2 位**（因为每条指令 4 字节、按字对齐）；
* 将这个偏移与当前 `PC` 相加，得到 **分支目标地址**；
* 把目标地址写回 `PC`，完成跳转（不走“PC+4”的顺序执行路径）。

---

## 二、图中各模块如何配合？

### 1) 取指与指令拆解

* **PC → Instruction Memory**：取到当前 `B` 指令。
* 指令被拆出 **BrAddr26** （26 位分支偏移字段）。

### 2) 偏移加工

* **SE（Sign Extend）**：把 `BrAddr26` 符号扩展到 64 位；
* **<<2**：左移 2 位，相当于乘以 4，保证与 4 字节指令边界对齐。

### 3) 目标地址计算

* **Adder（加法器）**：`PC + (SE(BrAddr26) << 2)` 得到 **目标 PC**；
* 旁边还有一个 **PC+4 的加法器**，这是顺序执行时用的地址，这里被分支路径覆盖。

### 4) 选择新 PC

* 右下方的多路复用器（MUX）在 **`UncondBr=1`** 时选择“分支目标地址”，否则选“PC+4”；
* `BrTaken` 输入对 `B` 来说恒为 1（无条件分支），因此本页让分支选择器必然走分支目标。

### 5) 其余部件状态

* **寄存器堆、ALU、数据存储器**在 `B` 指令下基本闲置：

* `RegWrite=0`（不写寄存器）
* `MemRead=0, MemWrite=0`（不访存）
* `ALUSrc/ALUOp/MemToReg/Reg2Loc` 均无关或保持默认

---

## 三、为什么要“左移 2 位”？

* 指令固定 4 字节对齐；偏移字段以“指令为单位”计数；
* 左移 2 位（×4）把“按指令计”的偏移转成“按字节计”的真实地址偏移；
* 这样与 `PC`（字节地址）相加才正确。

---

## 四、B 指令的控制信号要点

* `UncondBr = 1`（无条件分支开启）
* `RegWrite = 0`、`MemRead = 0`、`MemWrite = 0`
* 其余如 `ALUSrc / ALUOp / MemToReg / Reg2Loc` 对本指令无效（X）

---

## 五、执行流程小结

1. 取 `B` 指令；
2. 抽出 `BrAddr26`，做符号扩展并左移 2；
3. 与当前 `PC` 相加得到目标地址；
4. 由于 `UncondBr=1`，MUX 选目标地址写回 `PC`；
5. 下一周期从新 `PC` 取指，跳转完成。

---

## ✅ 结论

`B` 指令只改 **控制流**，不改数据；核心就是把 **“PC+偏移”** 的结果送回 **PC**，因此图上只有 **PC 更新通路**被激活，其它通路（寄存器/内存/ALU数据运算）都处于“旁观”状态。

---

\[口语化表达]
这一页就是在讲“跳转怎么做”。`B` 指令拿到一个 26 位的偏移量，把它先做符号扩展再左移 2 位（因为一条指令 4 个字节），然后跟当前 PC 相加得到目标地址。接着控制器把“新地址”塞回 PC，而不是用 PC+4，所以程序直接跳到新地方继续跑。整个过程中不读不写内存，也不改寄存器，纯粹就是改 PC 的值——把“往哪儿跳”这条路打通了就行。


---

## 第 8 页

![第 8 页](Slides088_SingleCycleControl_assets/page-008.png)

这页是 **CBZ（Compare and Branch if Zero）条件跳转** 的控制路径图。它讲的是：当执行 `CBZ Rt, label` 时，CPU 如何“读取寄存器 Rt → 判断是否为 0 → 如果为 0 就按偏移跳转，否则顺序执行”。

---

## 一、指令语义与伪代码

右上角伪代码：

```
Instruction = Mem[PC];
Cond = (Reg[Rt] == 0);
if (Cond)
PC = PC + SE(CondAddr19) << 2;
else
PC = PC + 4;
```

* 从 `PC` 取指令；
* 读取寄存器 **Rt** 的值并判断是否为 **0**；
* 若为 0：把 **19 位条件偏移 CondAddr19** 符号扩展并左移 2 位，与当前 `PC` 相加，作为新 `PC`；
* 否则：`PC ← PC+4`。

---

## 二、图中关键通路与部件

### 1) 取指与偏移准备（右侧高亮的分支通路）

* **PC → Instruction Memory** 取到 `CBZ` 指令；
* 指令字段里有 **CondAddr19**（19 位条件分支立即数）；
* 经过 **SE（符号扩展）** → **<<2**（左移 2 位）得到按字节计的偏移；
* 与当前 **PC** 做加法，得到**候选目标地址**。

### 2) 读寄存器并做“是否为零”的判断（左侧）

* **Reg2Loc = 0**：从指令字段选择 **Rt** 作为读端口；
* **ALUSrc = 0**：ALU 第二输入来自寄存器（但 CBZ 不做运算，只“传递”）；
* **ALUOp = PassB**：ALU 传递寄存器值到“Zero 检测器”；
* **Zero** 单元输出 1 表示该寄存器值为 0，输出 0 表示非 0。

### 3) 选择新 PC（条件跳转）

* 右下角多路复用器（MUX）在 **BrTaken=1** 时选择“分支目标地址”，否则选择 “PC+4”；
* 对 CBZ 而言：
**BrTaken = Zero**（寄存器值为 0 → 跳转；否则不跳）。

### 4) 其余模块状态

* **数据存储器**不参与：`MemRead=0, MemWrite=0`；
* **寄存器堆**不写回：`RegWrite=0`；
* **UncondBr=0**（不是无条件分支）。

---

## 三、CBZ 的控制信号一览

| 信号                 | 值                        | 说明               |
| ------------------ | ------------------------ | ---------------- |
| Reg2Loc            | 0                        | 选择 Rt 作为读寄存器     |
| ALUSrc             | 0                        | ALU 从寄存器取第二输入    |
| ALUOp              | PassB                    | 仅将寄存器值传给 Zero 检测 |
| RegWrite           | 0                        | 不写回寄存器           |
| MemRead / MemWrite | 0 / 0                    | 不访问数据内存          |
| MemToReg           | X                        | 无关               |
| UncondBr           | 0                        | 不是无条件分支          |
| BrTaken            | Zero                     | 为 0 则跳转          |
| 目标地址               | `PC + SE(CondAddr19)<<2` | 偏移按指令对齐（左移 2）    |

---

## 四、执行流程小结

1. 取 `CBZ` 指令；
2. 读 **Rt**，通过 ALU→Zero 检测，得到 **Zero**；
3. 并行计算 `PC + SE(CondAddr19)<<2` 的**候选目标地址**；
4. 若 `Zero=1`：MUX 选目标地址写回 `PC`；否则选 `PC+4`；
5. 进入下一周期，从新 `PC` 取指。

---

## ✅ 结论

`CBZ` 是“**看某寄存器是不是 0**”再决定跳不跳的条件分支：数据通路只用到**寄存器读 + Zero 检测 + 分支目标地址计算**三处，内存与寄存器写回通路都关闭。

---

\[口语化表达]
这页就是在说“**为 0 就跳**”。CPU 先把 `CBZ` 里的那个寄存器读出来，丢给一个零检测器看是不是 0；同时把指令里的 19 位偏移做符号扩展再左移 2 位（因为一条指令 4 字节），和当前 PC 相加算出要跳到哪。最后如果检测结果是 0，就把这个新地址写回 PC，否则就按常规的 PC+4 往下走。整个过程不读写数据内存，也不改任何寄存器，主要就是“判零 + 选 PC”的控制流操作。


---

## 第 9 页

![第 9 页](Slides088_SingleCycleControl_assets/page-009.png)

这页讲的是 **异常（Exception）机制**，即当 CPU 在执行过程中遇到“非正常情况”时，系统如何中断当前程序、转去执行异常处理（exception handler），然后再返回继续执行用户程序。

---

## 一、什么是 Exception（异常）

**异常（Exception）= 处理器运行中发生的不寻常事件。**
这些事件可能由硬件、软件或外设引起。常见的例子有：

* **算术错误（Arithmetic overflow / divide by zero）**
比如除以零、加法结果溢出；
* **非法指令（Undefined instruction）**
CPU 遇到它根本不认识的操作码；
* **硬件故障（Hardware failure）**
比如内存或总线错误；
* **输入输出请求（I/O device request）**
外设通过中断信号通知 CPU，它有任务或数据要处理。

图中提到：

> I/O device request (called an "interrupt")
> 说明中断（interrupt）其实是一类异常。

---

## 二、异常发生后 CPU 的行为

当异常发生时，CPU 会自动：

1. **保存当前状态**
保存当前指令地址（即 **Exception Program Counter, EPC**），保存通用寄存器（GPRs），记录异常原因（cause register）。

2. **跳转到操作系统的异常处理程序（Exception Handler）**

* 不同类型的异常跳到不同的固定地址（由硬件规定）。
例如：

```
if (undef_instr) PC = 0x00000000
if (overflow)    PC = 0x00000020
if (I/O)         PC = 0x00000040
```
* 这些地址就是异常处理例程的入口。

3. **由操作系统进行处理**

* 比如显示错误消息；
* 终止程序；
* 或执行 I/O 处理任务；
* 最后**返回异常前的状态**（return from exception）继续执行。

---

## 三、异常的处理流程（图中右侧）

图中流程分为两部分：

1. **用户程序（user program）**

* 正常执行；
* 如果遇到异常（例如除以 0），就**中断执行**，跳到系统异常处理程序。

2. **系统异常处理程序（System Exception Handler）**

* 执行异常处理代码；
* 处理完后再“return from exception”；
* CPU 恢复先前保存的状态；
* 返回用户程序的下一条指令。

**箭头解释：**

* 从 *user program → System Exception Handler*：异常触发跳转；
* 从 *System Exception Handler → user program*：异常处理完毕返回。

---

## 四、两种异常检测方式

文中提到两种“异常检测方法（Approaches）”：

1. **软件检测（Polling）**

* 程序自己不断检测是否出错；
* 比如每次加法后自己判断是否溢出；
* 缺点：开销大、低效。

2. **硬件检测（Hardware detect and react）**

* 硬件自动识别异常；
* 自动保存状态、转跳到异常处理程序；
* 效率高，是现代 CPU 的标准做法。

---

## 🧠 五、整体理解

* **异常（Exception）** 就是 CPU 在执行过程中被迫“打断”当前任务；
* **硬件检测到问题**（如溢出、非法指令、中断）；
* **CPU 保存现场 → 跳到系统处理程序 → 执行完返回用户程序**；
* 不同类型的异常跳到不同的处理地址；
* 最终用户程序可以被恢复或终止。

---

## ✅ 六、总结归纳

\[口语化表达]
这页讲的就是“CPU 出错了怎么办”。当程序在跑的时候，可能会出一些意外，比如除以零、指令错了、硬件坏了、外设要中断一下。碰到这种事，CPU 不会傻愣着，它会自己保存当前状态（就像做个快照），然后跳去系统里的异常处理程序。系统处理完后再回来接着跑。比如遇到除零错误可能直接结束程序，遇到 I/O 中断可能是去收数据。简单说，就是：CPU 一旦发现不对劲，就先暂停当前任务，去找操作系统“打个小报告”，等系统处理完再回来继续干活。
