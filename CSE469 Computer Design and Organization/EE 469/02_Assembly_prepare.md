

---

## 第 1 页

![第 1 页](02_Assembly_assets/page-001.png)

这是课件的一张导入页，主题是“汇编语言（Assembly Language）”。逐条翻译并解释如下：

# 标题：Assembly Language

讲的是“汇编语言”——一种**非常贴近机器指令**的编程语言。

# Readings（阅读范围）

* 2.1–2.7，2.9–2.10，2.14
* 绿色参考卡（Green reference card）
意思是：上课前/后要读教材这些小节，并随身带一张“绿色参考卡”（通常是常用指令、寄存器、寻址方式的速查表）。

# 什么是汇编语言

* **“简单、规则的指令——C、Java 等语言的积木块”**
高级语言（C/Java/…）最终都会被编译成机器能执行的**基本指令**（如加减、加载/存储、跳转等）。这些基本指令就是汇编程序员手里直接操作的“积木块”。
* **“通常与机器语言一一对应”**
每条汇编指令（如 `ADD R1, R2, R3`）几乎**对应一条**机器码指令（某个二进制编码）。所以汇编非常接近硬件：你写什么，CPU就按那条指令做什么。

# 本课目标（Our goal）

* **理解汇编语言的基础**
认识寄存器、内存、指令格式、寻址方式，学会读/写最基本的小段汇编。
* **帮助你弄清“处理器需要具备哪些能力”**
通过贴近硬件的视角，你会明白 CPU 为了支持高级语言，需要提供哪些底层功能：算术/逻辑运算、数据搬运、控制流（分支/循环）、内存寻址等。

# 不在本课范围（Not our goal…）

这门课**不会**把汇编/机器语言教到完整可独立开发的大项目，只覆盖入门。下列高级主题**不深入**：

* **浮点**（Floating point）：如浮点寄存器、IEEE 754、小数加减乘除的硬件/指令细节。
* **过程调用**（Procedure calls）：如调用约定（调用者/被调用者保存哪些寄存器）、`call/ret`、参数传递、返回值位置等。
* **栈与局部变量**（Stacks & local variables）：如栈帧的建立与回收、`push/pop`、`sp/fp`（栈指针/帧指针）管理。

---

## 再补充几句帮助理解

* **为什么学汇编？**
能看懂编译器把 C/Java 变成了什么；调试底层问题（比如段错误、性能瓶颈）；理解计算机体系结构（CPU 是怎么执行程序的）。
* **“一一对应”的直观例子**
C 里一句 `x = y + z;` 编译后可能就是三四条汇编：把 `y`、`z` 从内存**加载**到寄存器 → 做一次**加法** → 把结果**存回** `x` 的内存位置。
* **和高级语言的差别**
汇编没有“数组/对象/函数”这些抽象的语法糖，本质都是**读写寄存器与内存 + 控制跳转**。因此学习它能看到高级语言背后的“真实动作”。

如果你愿意，我可以用一个小例子演示：给你看一段简短的 C 代码，它被编译成的汇编长什么样，每条指令在做什么。


---

## 第 2 页

![第 2 页](02_Assembly_assets/page-002.png)

这页是“C/C++ 速成小抄”，用很短的代码串起**结构体、指针、数组、指针运算与解引用**几个核心概念。下面把每行都翻译并解释，并给出执行后的内存/数值变化。

---

# 1) 结构体与指针

```c
struct coord { int x, y; };   /* 声明一个类型 */
struct coord start;           /* 声明一个对象（实例），有两个成员 x、y */
start.x = 1;                  /* 用 . 访问对象的成员 */
struct coord *myLoc;          /* 声明一个“指向该结构体的指针” */
myLoc = &start;               /* & 取地址：让指针指向 start 这个对象 */
myLoc->y = 2;                 /* -> 等价于 (*myLoc).y ：通过指针访问成员 */
```

要点：

* `struct coord { int x, y; };` 定义了一个**复合类型**，内存里是连续的两个 `int`：先 `x`，后 `y`（通常顺序即源码顺序，可能有对齐填充但此处可忽略）。
* `struct coord start;` 创建了变量 `start`，它拥有两格 `int` 大小的空间：`x` 与 `y`。
* `start.x = 1;` 把 `x` 写成 1，`y` 还未写。
* `struct coord *myLoc;` 是“**指向结构体的指针**”，本质上保存某个 `coord` 对象在内存中的地址。
* `myLoc = &start;` 让 `myLoc` 指向 `start`。
* `myLoc->y = 2;` 通过指针把 `y` 设为 2。`->` 是语法糖，`p->f` 等价 `(*p).f`。

执行完毕后，`start` 的内容是：

```
x = 1
y = 2
```

（课件右侧的小方框就是这个示意图：上格是 x，下格是 y。）

---

# 2) 数组与指针

```c
int scores[8];        /* 一个长度为 8 的 int 数组，索引 0..7 */
scores[1] = 5;        /* 通过下标写入：把第 2 个元素设为 5 */

int *index = scores;  /* “数组名”会衰变为指向首元素的指针；
这行等价于 int *index = &scores[0]; */

index++;              /* 指针算术：前进 1 个“元素”的大小（不是 1 个字节）。
现在 index 指向 scores[1] */

(*index)++;           /* 解引用并自增：把 *index 的值加 1。
由于 index 指向 scores[1]，于是 scores[1] 从 5 变为 6 */

index = &(scores[3]); /* 让 index 指向 scores[3] */
*index = 9;           /* 通过指针写入：scores[3] 设为 9 */
```

要点：

* **数组名与指针**：在表达式中，`scores` 会自动“退化（decay）”成 `&scores[0]`（指向首元素的指针）。因此 `int *index = scores;` 是合法且常见的写法。
* **指针加减**：`index++` 会把指针移动到**下一个 int 元素**的位置（按 `sizeof(int)` 跨越），所以从 `scores[0]` 移到 `scores[1]`。
* **解引用与自增**：`(*index)++` 先取出 `index` 所指元素，再把它加 1。
* **取地址**：`&(scores[3])` 取得第 4 个元素的地址。

按照上面的操作，最终数组里被确定写过的元素是：

```
scores[1] = 6   // 先写 5，又被 (*index)++ 加到 6
scores[3] = 9
```

其余 `scores[0], scores[2], scores[4]..scores[7]` 在示例里没有赋值（作为局部未初始化的普通数组元素，其值**不确定**；课件的底部图只是画出 0..7 的槽位位置，不代表已经赋值）。

---

## 一图串联常见符号

* `.`：对象.成员（你“直接拥有”这个对象）
* `&`：取地址（得到指针）
* `*p`：解引用（沿着指针去拿它“指到的值”）
* `->`：指针访问成员，等价 `(*p).member`
* 指针加减：按**元素大小**移动，而不是按字节（例如 `int*` 的 `p+1` 跳过 `sizeof(int)` 字节）

如果你想，我可以把这段代码放进一个完整的可编译示例，打印每一步后的状态，帮助你更直观地理解。


---

## 第 3 页

![第 3 页](02_Assembly_assets/page-003.png)

这页在讲 **ARM 汇编的基本指令格式**。核心点：ARM（经典的 A32/T32 指令集）的大多数算术/逻辑指令都采用**三操作数**形式，写法统一、硬件实现简单。

# 基本指令的“四个组成部分”

1. **操作符名（Operator name）**：要做什么，比如 `ADD`（加）、`SUB`（减）、`AND`、`ORR`、`MOV` 等。
2. **目的操作数（Destination, dst）**：结果要存到哪（通常是一个寄存器）。
3. **第 1 个源操作数（src1）**：参与运算的第一个输入。
4. **第 2 个源操作数（src2）**：参与运算的第二个输入（可以是寄存器，也常可写“立即数”或带移位的寄存器）。

典型格式（以加减为例）：

```asm
ADD <dst>, <src1>, <src2>   ; <dst> = <src1> + <src2>
SUB <dst>, <src1>, <src2>   ; <dst> = <src1> - <src2>
```

* **三操作数**意味着：结果不会强制覆盖任一输入，你可以把结果放到另一个寄存器里（当然也可以把 `<dst>` 写成与 `<src1>` 相同的寄存器来“就地更新”）。
* **负载/存储（Load/Store）体系**：算术指令的操作数必须在寄存器里；要用内存数据，先用 `LDR` 读到寄存器，算完再用 `STR` 存回去。

# 为什么说“Simple format: easy to implement in hardware”

* 编码风格统一：操作符 + 目的寄存器 + 两个源，解码器简单。
* 绝大多数算术/逻辑指令都长这样（也常带一个条件码与可选的更新标志位 `S`，如 `ADDS`）。
* 第二个源操作数在 ARM 里还能带**桶形移位器**（如 `ADD r0, r1, r2, LSL #1` 表示 `r0 = r1 + (r2<<1)`），这在指令条数不变的前提下增强了表达力。

# “More complex: A = B + C + D − E” 怎么落到指令上？

复杂表达式要拆成多条简单三操作数指令。假设：

* `A,B,C,D,E` 分别在寄存器 `r0,r1,r2,r3,r4` 中（只是示例，具体寄存器随你分配）
* 目标是 `A = B + C + D - E`

一种直接写法：

```asm
ADD r0, r1, r2    ; r0 = B + C
ADD r0, r0, r3    ; r0 = (B + C) + D
SUB r0, r0, r4    ; r0 = (B + C + D) - E   => A
```

说明：

* 三条指令，每条都只做一次简单的加/减，最终得到目标值。
* 若某步允许覆盖输入，也可以把目的寄存器选成其中一个源寄存器，减少额外寄存器的占用。

# 常见小补充

* **立即数**：第二个源常可写立即数，如 `ADD r0, r0, #5` 表示 `r0 += 5`（受限于 ARM 对立即数的编码规则）。
* **条件执行**：经典 ARM 支持条件码后缀，如 `ADDEQ`（零标志为真才执行），能减少分支。
* **标志位**：在操作符后加 `S` 更新标志位，如 `ADDS` 会更新 N/Z/C/V，用于后续条件判断。
* **内存访问分离**：若 `B,C,D,E` 在内存中，需要先 `LDR` 到寄存器、算完再 `STR`：

```asm
LDR r1, [addrB]
LDR r2, [addrC]
LDR r3, [addrD]
LDR r4, [addrE]
ADD r0, r1, r2
ADD r0, r0, r3
SUB r0, r0, r4
STR r0, [addrA]
```

如果你愿意，我可以把你给的某个 C 表达式翻成等价的 ARM 汇编，并标注每条指令在做什么、需要哪些寄存器。


---

## 第 4 页

![第 4 页](02_Assembly_assets/page-004.png)

这页在讲“操作数（operands）存放在哪里、指令怎样取数和存数”。要点如下：

# 核心结论

1. **寄存器（registers）**：CPU 内部有一小组**通用寄存器**（幻灯片写 32 个；不同架构数量略有差异，但都不多）。

* **极快**：位于处理器核心里，单个时钟周期就能读写。
* **用于大多数运算**：加减乘除、与或非、比较、移位……都在寄存器之间完成。
2. **主存（memory）**：容量很大（多 GB），但**速度远慢**于寄存器。
3. **设备（devices）/输入输出（I/O）**：键盘、显示器、磁盘、网卡等，通过 I/O 接口与 CPU、内存连在一起。
4. **负载/存储（Load/Store）原则**：

* 只有专门的**加载/存储指令**（如 `LDR/STR`）能在**寄存器 ↔ 主存**之间搬运数据。
* **其他指令一律只对寄存器操作**。这就是典型 **RISC / load–store 架构**的风格：格式统一、硬件简单、流水线友好。

# 图中各块代表什么

* **Processor（处理器）**：里面有

* **Control（控制）**：取指令、解码、发出控制信号、管理流水线和分支等。
* **Datapath（数据通路）**：真正执行运算的部分（ALU、寄存器文件 GPRs、移位器等）。
* **Memory（内存）**：程序和数据的大仓库（通常还会有多级缓存，图上为简化未画）。
* **Devices（设备）**：I/O 设备；通过 **Input**/**Output** 和 CPU/内存交互。

# 为什么要这样设计？

* **速度差异巨大**：寄存器最靠近 ALU，带宽高、延迟低；主存延迟大很多（通常要靠 cache 缓解）。
* **硬件实现简单**：让算术/逻辑只面对寄存器，指令格式固定、解码容易、流水线稳定。
* **编译器可控**：编译器负责把“活跃数据”尽量放在寄存器里，只有必要时才读/写内存。

# 一个小例子（以 ARM 风格示意）

把内存中 `A = B + C`：

```asm
LDR r1, [addrB]      ; r1 ← 内存B
LDR r2, [addrC]      ; r2 ← 内存C
ADD r0, r1, r2       ; r0 = r1 + r2   (寄存器内完成加法)
STR r0, [addrA]      ; 把结果写回内存A
```

* 只有 `LDR/STR` 接触内存；`ADD` 只在寄存器间工作。

# 学习/写汇编时的实用认知

* **尽量把热点数据放在寄存器**，减少内存读写。
* **指令只处理寄存器**，所以每次要用内存数据时，先 `Load`；算完再 `Store`。
* **理解数据位置**（在寄存器？在内存？在 I/O？）是读懂任何一段汇编/机器执行的第一步。


---

## 第 5 页

![第 5 页](02_Assembly_assets/page-005.png)

这页在讲 **AArch64（ARM 64 位）通用寄存器** 的用途与**调用约定**（哪些寄存器在函数调用间需要保存）。表格里的 `X0…X31` 指的是 64 位视图；同一物理寄存器还有 32 位视图 `W0…W31`（只读写低 32 位）。

> 幻灯片给出的一套课堂约定略作简化；不同平台/ABI 细节会有差异。我按表中含义逐行解释，并补上调用约定要点。

---

## 共有 32 个 64 位寄存器（X0–X31）

### X0–X7：函数**参数/返回值**

* 调用者把前 8 个整型/指针参数放在 `X0..X7` 传给被调函数。
* 返回值也放在这里：1 个整型/指针→`X0`；两个值常用 `X0,X1`。
* **易失（caller-saved）**：调用别的函数前，若还要用它们，调用者自己先备份。

### X8：当返回值是“指针”或“间接结果位置”时使用

* 某些 ABI 用 `X8` 传**间接返回值地址**（例如返回大结构体时，调用者把“结果应写到哪里”的地址放在 `X8`）。
* 也常作为普通临时寄存器使用（仍属 caller-saved）。

### X9–X15：**易失的临时寄存器（Volatile Temporaries）**

* **不跨调用保存**：被调函数可以随意改；调用者若要保留，需自己入栈保存。
* 适合放短期中间结果。

### X16–X17：**链接器/PLT 的工作寄存器**

* 也叫 `IP0/IP1`（intra-procedure call scratch）。
* 动态链接跳转、PLT 桩代码会用到它们。**应用代码不要依赖**，当作易失 scratch。

### X18：**平台保留**

* 某些系统把 `X18` 作为“平台寄存器”（如 TLS 指针等）。**不要占用**（按平台 ABI 要求）。

### X19–X27：**可保存的临时寄存器（Callee-saved）**

* **需要跨调用保持值**：如果被调函数使用了这些寄存器，**它自己**要在入口时把用到的寄存器压栈，返回前恢复。
* 适合放需要在整个函数生命周期中“长期存活”的变量。

### X28：**栈指针（Stack Pointer，SP）**（按这份课件的标注）

* 用来指向当前栈顶，`STP/LDP/STR/LDR` 等栈操作会围绕它调整。
* 说明：在标准 AArch64 文档里，SP 通常作为**单独的寄存器名**出现（编码位上与 `X31` 复用），课堂简化为“X28=SP”的记法来帮助记忆使用，不影响对“它是栈指针”的理解。

### X29：**帧指针（Frame Pointer，FP）**

* 许多函数会建立栈帧：保存旧的 `FP` 与返回地址，然后把 `FP` 设为当前栈帧基址，便于调试/回溯和访问局部变量。
* 是否强制使用由编译选项和平台 ABI 决定（有时会省略以优化）。

### X30：**返回地址（Link Register，LR）**

* `BL target`（Branch with Link）会把**下一条指令地址**写入 `X30`，再跳转到 `target`。
* `RET` 通过 `X30` 返回：`RET` ≈ `BR X30`。
* 若函数内部会再调用别人或可能覆盖 `X30`，通常会把 `X30` 入栈保存。

### X31：**零寄存器（Zero Register）/写入无效**

* 读作常数 0（`X31`→0，`W31`→0）。
* 对它“写入”是**空操作**（no-op），结果被丢弃。
* 常用于清零：`ADD Xd, Xn, XZR` 或直接把目的写到 `XZR` 丢弃结果。

---

## 小结：谁需要保存？

* **调用者保存（caller-saved / 易失）**：`X0–X15`、`X16–X17`（以及课堂中的 `X8`）。调用前自己备份要留用的值。
* **被调者保存（callee-saved）**：`X19–X27`（以及 `FP(X29)`、必要时 `LR(X30)`）。函数用到这些时要入栈/出栈成对保存恢复。
* **特殊**：`SP`（课堂记为 `X28`）指向栈；`X31`恒为 0。

---

## 典型函数序言/尾声（示意）

```asm
; 入口：保存返回地址和上一个栈帧
STP    X29, X30, [SP, #-16]!
MOV    X29, SP
; 若使用了 X19..X27，也要相应 STP/STR 入栈

...    ; 函数体，参数在 X0..X7，返回值放 X0

; 尾声：恢复寄存器并返回
MOV    SP, X29
LDP    X29, X30, [SP], #16
RET
```

---

## 补充：32 位视图

* `Wn` 是 `Xn` 的低 32 位。例如写 `W0` 会**自动清零** `X0` 的高 32 位（常见于整型运算）。

如果你给我一段具体的函数，我可以标出它用到了哪些 caller-/callee-saved 寄存器，以及对应的入栈/出栈指令。


---

## 第 6 页

![第 6 页](02_Assembly_assets/page-006.png)

这页在讲 AArch64（ARM 64 位）里常用的基础指令：算术、逻辑、移位，以及“立即数”形式。右侧给了对应的写法与等式语义。
1) 算术指令（Mathematic）
ADD Xd, Xn, Xm：Xd = Xn + Xm
SUB Xd, Xn, Xm：Xd = Xn - Xm
MUL Xd, Xn, Xm：Xd = Xn * Xm
SDIV Xd, Xn, Xm：有符号除法（无符号用 UDIV）
立即数形式（第二个输入是常数）：ADD Xd, Xn, #imm（幻灯片用 ADDI 表示“带立即数的 ADD”）
例：ADD X0, X1, #100 → X0 = X1 + 100
说明：所有这些也有 32 位变体（W0…W30），语义相同但只对低 32 位生效。
2) 逻辑指令（Logical）
AND Xd, Xn, Xm：按位与 → Xd = Xn & Xm
ORR Xd, Xn, Xm：按位或 → Xd = Xn | Xm
EOR Xd, Xn, Xm：按位异或 → Xd = Xn ^ Xm
立即数形式：AND Xd, Xn, #imm、ORR Xd, Xn, #imm、EOR Xd, Xn, #imm
例：AND X0, X1, #7 → 只保留 X1 的最低 3 位（0b111）
3) 逻辑移位（Shift）
LSL Xd, Xn, #k：逻辑左移 k 位（低位补 0） → Xd = Xn << k
LSR Xd, Xn, #k：逻辑右移 k 位（高位补 0） → Xd = Xn >> k
例子（幻灯片底部）
要求：把 X0 的第 6–4 位提取出来，放到 X1 的第 2–0 位，其余位清零。
思路：先把目标位对齐到最低位，再用与掩码保留 3 位。
asm
复制
编辑
LSR  X1, X0, #4      // X1 = X0 >> 4   （原来的 bit[6:4] 现在变成 bit[2:0]）
AND  X1, X1, #7      // X1 = X1 & 0b111（清掉其余所有位，只留最低3位）
这样，X1 的 2:0 位就是原 X0 的 6:4 位，其他位为 0。
（补充：也可用位域提取指令别名 UBFX X1, X0, #4, #3 一步完成，但本页只尚未介绍它，所以用移位+与更直观。）


---

## 第 7 页

![第 7 页](02_Assembly_assets/page-007.png)

这页在讲**内存的基本抽象**：把内存看成一个**很大的一维数组**；数组中的每个格子是 **1 个字节（8 bit）**。图里 0、1、2、3… 就是**下标**；每个下标对应的内容是“8 bits of data”。

# 关键信息

* **“一维大数组”**
计算机把主存抽象成从地址 0 开始、连续编号的很多小格子。你可以把它想成：
`memory[0], memory[1], memory[2], …`
* **“地址 = 下标（index）”**
我们平时说的“内存地址”，其实就是这个数组的**索引号**。
例如：地址 1000 表示“第 1000 个字节”的位置。
* **“按字节寻址（Byte addressing）”**
意味着**每移动 1 个地址单位，就移动 1 个字节（8 bit）**。所以地址 +1 就到下一个字节。

# 对程序员的意义

* **不同数据类型占用多个字节**

* `char`：1 字节
* `int32`：4 字节（占用 `addr, addr+1, addr+2, addr+3`）
* `int64`/指针（在 64 位机）：8 字节
读取这些类型时，CPU 会一次性取/存**多个相邻字节**。
* **指针与指针运算**
指针本质是“某个字节的地址”。但 C/C++ 的指针加减会按**所指类型的大小**来步进：

```c
int *p = base;   // 假设 sizeof(int)=4
p = p + 1;       // 地址实际上加了 4 个字节
char *q = (char*)base;
q = q + 1;       // 地址只加 1 个字节
```
* **对齐（alignment）**
许多平台要求多字节数据按其大小对齐到相应边界（如 4 字节整型地址要是 4 的倍数）。对齐能提升访问效率，避免异常。
* **大小端（endianness）**
多字节数据在字节数组中如何排布有两种常见方式：小端（低位字节放在低地址）和大端（反之）。这只影响**字节顺序**，不影响“按字节编址”的概念本身。
* **数组与结构体其实都是字节的连续片段**

* 数组是**同类型元素**的连续布局；下标 i 的地址 = `base + i * sizeof(T)`。
* 结构体把不同字段按顺序（含可能的对齐填充）布局成一段连续字节。

# 小例子（按字节寻址的直观感受）

假设 `int` 为 4 字节、起始地址为 `0x1000`：

```
int a = 0x11223344;   // 四个字节
```

* 这 4 个字节会占据地址 `0x1000..0x1003`。
* 小端机器上：

```
memory[0x1000]=0x44
memory[0x1001]=0x33
memory[0x1002]=0x22
memory[0x1003]=0x11
```

# 与上一页（寄存器/Load-Store）的联系

CPU 的算术/逻辑在**寄存器**里做；要访问上面这个“字节数组”，必须用**加载/存储指令**把连续字节搬进寄存器或写回去。
例如从地址 `addr` 读一个 64 位数（8 字节）：

```
LDR X0, [addr]   ; 取 memory[addr..addr+7] 组成一个 64 位值到寄存器 X0
```

> 记住一句话：\*\*内存就是一个以“字节”为单位的一维大数组；地址就是这个数组的下标。\*\*所有更复杂的数据、对象、数组、结构，最终都只是这串字节上的布局与解释。


---

## 第 8 页

![第 8 页](02_Assembly_assets/page-008.png)

这页是对“内存=字节数组”的继续说明，加入了**更大数据单位**与\*\*对齐（alignment）\*\*的概念，并结合 64 位 ARM 的寄存器宽度来直观化。

# 更大单位：word / double-word

* **double-word（双字）= 64 bit = 8 字节**
AArch64 的通用寄存器 `X0..X30` 一次就能装下 **64 bit** 数据，所以图上写 “Registers hold 64 bits of data”。
* **word（字）= 32 bit = 4 字节**
同一物理寄存器也有 32 位视图 `W0..W30`，即只操作低 32 位（= 一个 word）。

# 地址空间与步进

* 64 位地址可表示 **2⁶⁴ 个字节**，可编址范围是 **0 … 2⁶⁴−1**（以“字节”为单位计数）。
* 如果以\*\*双字（8 字节）\*\*为块来看，“块号”只有 **2⁶¹** 个，因为每块占 8 字节：

* 这些块的**起始字节地址**分别是 **0、8、16、…、2⁶⁴−8**（每次+8）。

# 对齐（alignment）

* **双字和字都按其大小对齐**：

* 64 位数据的地址必须是 **8 的倍数**；
* 32 位数据的地址必须是 **4 的倍数**。
这样硬件访问更快、更简单，也避免部分平台上的未对齐异常。
* 提问：“**一个双字地址的最低 3 个有效位是什么？**”

* 因为双字地址是 8 的倍数，二进制最低 3 位必为 **000**。
* 这 3 位之所以“无效”，是因为它们始终为 0；真正区分不同双字块的是更高位。

# 小例子（巩固）

* 若 `X0` 保存地址 `0x1000`：

* `LDR X1, [X0]` 取 **8 字节**（`0x1000..0x1007`）。
* `LDR W2, [X0,#4]` 取从 `0x1004` 开始的 **4 字节**（按 4 字节对齐仍合法）。
* 指针算术（C/C++）：

* `uint64_t *p; p++` → 地址加 **8**（下一个 double-word）；
* `uint32_t *q; q++` → 地址加 **4**（下一个 word）。

> 记住：**字节是最小编址单位**，但多数实际数据以 4 或 8 字节成组存放，并且**地址按大小对齐**。因此看地址的低几位，就能判断它能否作为对齐的 32/64 位数据地址（对 64 位，低 3 位应为 0；对 32 位，低 2 位应为 0）。


---

## 第 9 页

![第 9 页](02_Assembly_assets/page-009.png)

这页在讲**大小端（Endianness）**与**对齐（Alignment）**，用“一个 64 位 double-word（8 字节）”做例子说明**多字节数据在字节地址空间中的排布方式**。

# 1) 背景

* **按字节寻址**：内存是字节数组；一个 64 位数（double-word）由 **8 个相邻字节**组成。
* **对齐**：64 位数据的起始地址必须是 **8 的倍数**，所以它的**最低 3 位地址比特永远是 000**（图左侧/右侧边上的 000、001、010… 表示“起始地址 + 0、+1、+2 … 字节偏移”）。

# 2) 大端 vs. 小端（核心差别：哪个字节放在“低地址”）

设 64 位数的 8 个字节按**重要性**从高到低记为：
`[b63..56] [b55..48] [b47..40] [b39..32] [b31..24] [b23..16] [b15..8] [b7..0]`

* **Big Endian（大端）**

> “最高有效字节（MSB）在低地址”。
> 如果这个 64 位数存放在地址 A（A 是 8 的倍数），那么：

```
A+0: b63..56   A+1: b55..48   A+2: b47..40   A+3: b39..32
A+4: b31..24   A+5: b23..16   A+6: b15..8    A+7: b7..0
```

所以**double-word 的地址 = 最高有效字节的地址**。

* **Little Endian（小端）**

> “最低有效字节（LSB）在低地址”。
> 存放顺序相反：

```
A+0: b7..0     A+1: b15..8    A+2: b23..16   A+3: b31..24
A+4: b39..32   A+5: b47..40   A+6: b55..48   A+7: b63..56
```

因此**double-word 的地址 = 最低有效字节的地址**。

图中左右两列分别画出了这两种排布；中间的 “DWord 0/1/2/3/4 …” 表示**一块块相邻的 8 字节双字**，它们的起始地址依次是 `…, A-8, A, A+8, A+16, …`。

> 备注：
>
> * 经典大端处理器示例：Motorola 68k、早期 MIPS/IBM360/370、部分 SPARC 等。
> * 小端处理器示例：x86 家族、Z80 等。
> * **ARM 可以两种都支持**，但**本课程默认小端（Little-Endian）**。

# 3) 一个具体数值的直观演示

以 64 位数 `0x11 22 33 44 55 66 77 88`（左高右低）为例，基地址 A：

* **大端**（高位在前）

```
A+0 0x11  A+1 0x22  A+2 0x33  A+3 0x44
A+4 0x55  A+5 0x66  A+6 0x77  A+7 0x88
```
* **小端**（低位在前）

```
A+0 0x88  A+1 0x77  A+2 0x66  A+3 0x55
A+4 0x44  A+5 0x33  A+6 0x22  A+7 0x11
```

# 4) 为什么要关心？

* **跨平台/网络协议/文件格式**：必须明确字节序，否则读出来的多字节数会错。
* **调试与内存查看**：看内存窗口时，需要用正确的端序去还原数值。
* **位运算/位域**：理解“低地址≠低位”这一点能避免位操作与字节指针混用时的思维陷阱。


---

## 第 10 页

![第 10 页](02_Assembly_assets/page-010.png)

这页说明“不同数据在内存里怎么存”，并用一小段 C/C++ 代码配合**字节地址**来画出可能的内存布局（本课默认小端 Little-Endian、64 位机器）。

# 基本约定（这张页的简化模型）

* **字符（char）= 8 bit = 1 字节**
* **整数（int）= 64 bit = 8 字节**（为讲解统一，课上把 int 当成 64 位；真实 C/C++ 上各平台不一定相同）
* **数组（array）= 连续的一串地址**
* **指针（pointer）= 64 位“地址值”**（指向某个字节的编号）

> 右侧地址格子（0x1000…0x102F）表示“按字节寻址”的一维数组；每格 1 字节。

# 代码逐行解释与内存示意

```cpp
// G 的 ASCII 是十进制 71 = 0x47
char a = 'G';
int  x = 258;   // 0x0102
char *b;
int  *y;
b = new char[4];
y = new int[10];
```

### 1) `char a = 'G';`

* `a` 占 **1 字节**。
* 小端与大端对 1 字节无区别，内存里就是 **0x47**。
* 为了让接下来的 8 字节整数**按 8 字节对齐**，编译器常会在 `a` 之后插\*\*填充（padding）\*\*直到下一个 8 的倍数地址。

### 2) `int x = 258; // 0x0102`

* 课上把 `int` 视为 **8 字节**。
* **小端**存放：低位在低地址，所以 8 个字节依次为
`02 01 00 00 00 00 00 00`（从起始地址往上递增）。

### 3) `char *b;  int *y;`

* 两个**指针变量本身**各占 **8 字节**，里面保存“地址值”（它们**指向**哪儿）。
* 刚定义时未赋值，内容不确定；执行 `new` 之后会被写成相应的堆起始地址。

### 4) `b = new char[4];`

* 在**堆**上分配 **4 个字节的连续区域**（例如从地址 `0x2000` 到 `0x2003`），并把这个起始地址写入 `b`。
* 即：`b` 里存的是 `0x2000`（以小端方式存成 8 个字节）。

### 5) `y = new int[10];`

* 分配 **10 个 int** 的连续区域。按本页约定 `int`=8 字节，所以共 **80 字节**。
* 若起始地址是 `0x3000`，那么：

* `y[0]` 在 `0x3000..0x3007`
* `y[1]` 在 `0x3008..0x300F`
* …依此类推，每个元素相隔 **8 字节**。
* 指针变量 `y` 本身存放着 `0x3000`（同样以小端 8 字节表示）。

> 页脚的红字提醒：**真实编译器**通常把局部变量放在**栈**（地址空间一端向下长），`new` 的对象放在**堆**（另一端向上长）。这张图为了讲解把它们画在一块区域里，**忽略了栈/堆分离**与精确地址分配，只强调“字节序、对齐、连续性”。

# 关键概念串起来

* **按字节寻址**：每个地址编号对应 1 字节。
* **小端**：多字节数的最低有效字节在**最低地址**。
* **对齐**：64 位数据通常放在“地址能被 8 整除”的位置，可能引入填充字节。
* **数组=连续**：`base + i * sizeof(T)` 就是第 i 个元素的起始地址。
* **指针=地址**：指针变量自己也是 8 字节数据，只是它的值被解释为“去哪一块内存”的编号。

如果你愿意，我可以把这段代码编译成汇编，标出每个加载/存储指令对应的地址与字节布局，帮助你对齐与小端更直观地“对号入座”。


---

## 第 11 页

![第 11 页](02_Assembly_assets/page-011.png)

这页讲 **Load/Store 指令如何在“寄存器 ↔ 内存”之间搬数据**，并给了两条 AArch64 指令当例子。

# 核心概念

* **算术/逻辑都在寄存器里做**；要用到/写回内存，就必须用\*\*加载（Load）**或**存储（Store）\*\*指令。
* 本页用了 **AArch64 的“基址 + 立即数偏移”寻址**：

* `LDUR Xd, [Xn, #imm]`  →  从地址 `Xn + imm` 处**加载**到寄存器 `Xd`
* `STUR Xd, [Xn, #imm]`  →  把寄存器 `Xd` 的值**存到**地址 `Xn + imm`
* `LDUR/STUR` 的 **U** = *Unscaled*（**不按数据大小缩放**的字节偏移）；相对的 `LDR/STR` 常用**按数据大小缩放**的偏移。
* 备注：`LDURB/STURB` 是**按字节**（Byte）加载/存储；这里的示例是 `LDUR/STUR`（面向 64 位 X 寄存器，即双字）。

# 例子（按图中数值）

左侧寄存器：`X1=130`，`X2=723`，`X3=4`；右侧内存：`[144] = 66`（其余未示）。

1. `LDUR X0, [X1, #14]`

* 计算地址：`X1 + 14 = 130 + 14 = 144`
* 从 `Memory[144]` 取值到 `X0`
* 图中 `Memory[144] = 66`，所以 **执行后 `X0 = 66`**

2. `STUR X2, [X3, #20]`

* 计算地址：`X3 + 20 = 4 + 20 = 24`
* 把 `X2` 的内容存到 `Memory[24]`
* `X2 = 723`，所以 **执行后 `Memory[24] = 723`**

执行完两条指令后的状态（结合图）：

* `X0 = 66`
* `Memory[24] = 723`
* `Memory[144]` 仍是 66（未改）

# 小补充：常见变体与用法

* **数据宽度**：

* `LDUR/ STUR`（X寄存器）→ 64 位；`LDUR/ STUR`（W寄存器）→ 32 位；
* `LDURB/ STURB` → 8 位字节；`LDURH/ STURH` → 16 位半字。
* **其他寻址模式**（了解）：

* 预索引/后索引（访问同时更新基址）：`LDR X0, [X1, #8]!`、`LDR X0, [X1], #8`
* 寄存器偏移：`LDR X0, [X1, X2]`
* **与对齐**：为高效访问，常让 64 位数据放在 8 的倍数地址；`LDUR` 的不缩放偏移以**字节**计数，适合处理未对齐或特殊布局。


---

## 第 12 页

![第 12 页](02_Assembly_assets/page-012.png)

这页是个“寻址练习”。已知：字符数组（每个元素 1 字节）的**起始地址在 X0**。让你把若干元素取出来放到寄存器里。

因为是“character array”，每次只读 **1 字节**，所以要用**字节加载**指令（AArch64 用 `LDRB`/`LDURB`，会把读到的 1 字节**零扩展**到 32 位寄存器 `Wn` 里）。写法如下：

```asm
// X0 = &Array[0]

// 固定下标：用带立即数偏移的 LDRB（按字节寻址，偏移就是元素下标）
LDRB    W2, [X0]        // X2 = Array[0]
LDRB    W3, [X0, #1]    // X3 = Array[1]
LDRB    W4, [X0, #2]    // X4 = Array[2]

// 变量下标：k 在 X1
// 方式一：寄存器偏移（不缩放，正好按字节加 k）
LDRB    W5, [X0, X1]    // X5 = Array[k]

// 方式二：先算地址再读
// ADD     X9, X0, X1
// LDRB    W5, [X9]
```

小提示

* `LDRB` 把 1 字节**零扩展**写入 `W` 寄存器；如果你更想**符号扩展**（把 0x80..0xFF 当负数），用 `LDRSB Wd, [..]` 或 `LDRSB Xd, [..]`。
* 也可以用“未缩放偏移”的 `LDURB Wd, [X0, #imm]`，效果与上面类似；这里用 `LDRB` 更常见。
* 为了保持语义清晰，读字节请用 `W` 寄存器目标（`W2/W3/...`）；如果你写到 `X2`，上层汇编器也会当作对 `W2` 的字节加载处理。


---

## 第 13 页

![第 13 页](02_Assembly_assets/page-013.png)

这页用 C 代码

```c
/* 交换数组中第 k 个与第 k+1 个元素 */
swap(int v[], int k) {
int temp = v[k];
v[k]   = v[k+1];
v[k+1] = temp;
}
```

来练你把**数组下标 → 地址**并用 **Load/Store** 完成交换。题目给定：`v` 的地址在 `X0`，`k` 在 `X1`。右边内存示意每 8 字节一个槽（本课把 `int` 当 **64 位=8 字节**），地址按 8 递增：1000、1008、1016…（即双字对齐）。

## 关键点

* 按字节寻址、`int` 占 8 字节 ⇒ **v\[i] 的地址 = X0 + i \* 8**。
* AArch64 提供“**缩放的寄存器偏移**”：`[base, index, LSL #3]` 等价于 `base + index*8`（因为 1<<3 = 8）。
* 交换需要两次加载、两次存储。

## 一种标准 AArch64 写法

```asm
; 入口：X0 = &v[0]，X1 = k
; 使用：X2,X3 临时

LDR   X2, [X0, X1, LSL #3]     ; X2 = v[k]          （加载第 k 个元素）

ADD   X4, X1, #1               ; X4 = k + 1
LDR   X3, [X0, X4, LSL #3]     ; X3 = v[k+1]        （加载第 k+1 个元素）

STR   X3, [X0, X1, LSL #3]     ; v[k]   = X3        （写回第 k 个）
STR   X2, [X0, X4, LSL #3]     ; v[k+1] = X2        （写回第 k+1 个）

; 完成
```

### 等价写法（用地址先算出来）

```asm
ADD   X9, X0, X1, LSL #3       ; X9 = &v[k]
LDR   X2, [X9]                 ; X2 = v[k]

ADD   X10, X9, #8              ; X10 = &v[k+1]
LDR   X3, [X10]                ; X3 = v[k+1]

STR   X3, [X9]                 ; v[k]   = v[k+1]
STR   X2, [X10]                ; v[k+1] = temp
```

## 图里在说什么？

* **GPRs** 方框：例子里寄存器当前值（如 `X0=928`，`X1=10`）。
* **Memory** 方框：每行显示一个 8 字节（双字）槽，从 1000、1008、1016… 往上。
* 真正访问到的两个元素地址就是 `X0 + k*8` 和 `X0 + (k+1)*8` 这两个双字槽；执行后这两槽的内容互换，其它地址不变。

> 小贴士
>
> * 若题目中的 `int` 是 32 位，则把所有 `X`/`LDR`/`STR` 换成 `W`/`LDR`(W)/`STR`(W)，并把位移从 `LSL #3` 改为 `LSL #2`（因为 4 字节=2 的 2 次方）。
> * 这就是“缩放寻址”的好处：用位移立即表达了“元素大小”的乘法。


---

## 第 14 页

![第 14 页](02_Assembly_assets/page-014.png)

这页在演示**CPU 的取指—译码—执行循环（execution cycle）**，并把它和我们刚才的“数组相邻两元素交换”例子对应起来看。图里把**指令区**（上半部分内存、地址 0x0000 起）和**数据区**（下半部分内存、地址 0x1000 起）画在同一张“内存”图里，好让你看到：

* 指令本身也只是内存里的**数据**（机器码），
* CPU 每次从“程序计数器 PC 指向的地址”**取 1 条指令**（AArch64 每条 **32 位=4 字节**，因此指令地址步进是 0x0000、0x0004、0x0008 …），
* 译码后去寄存器/内存拿操作数、执行、把结果写回寄存器或内存，然后把 **PC += 4**（或按分支更新）继续下一条。

---

## 名词

* **PC（Program Counter）**：下一条要执行的指令的**字节地址**。
* **IR（Instruction Register）**：当前指令的**机器码副本**（CPU 刚取回的 32 位指令会先放在 IR 里，再进行译码）。

红字 “**Word addresses / Instructions are 32b**” 提醒你：这台机的**每条指令 32 位**，图中 0、4、8、12… 这样的地址就是**按字（4 字节）对齐**的指令起始地址。

---

## 内存两块内容

* **上半（0x0000 起）**：若干条 32 位机器码（图中显示为 8 位十六进制一串，如 `D3600C22`、`8B020002`、`F8400043`…）。它们就是实现“交换 v\[k] 与 v\[k+1]”的那几条 AArch64 指令的编码。
* **下半（0x1000 起）**：数据区（和上一页一样），每 8 字节一个“槽”：

* `[1000] = 0x0A12170D34BC2DE1`
* `[1008] = 0x1111111111111111`
* `[1016] = 0x0000000000000000`
* `[1024] = 0x0F0F0F0F0F0F0F0F`
* `[1032] = [1040] = 0xFFFFFFFFFFFFFFFF`
* 左侧寄存器初值：**X0=928**（即 `&v[0]`），**X1=10**（k=10）。

> 注意：本课把 `int` 当 **64 位（8 字节）** 来讲解，所以 `v[i]` 的地址 = `X0 + i*8`，也就是 `X0 + (i << 3)`。

---

## 一条指令在“取-译-执”中的样子（以加载 v\[k] 为例）

设将要执行的是：`LDR X2, [X0, X1, LSL #3]`（把 `v[k]` 读到 X2）：

1. **Instruction Fetch（取指）**：用 **PC** 去内存地址 `[PC]` 取 4 字节机器码到 **IR**。
2. **Instruction Decode（译码）**：IR 里的比特被识别为 `LDR`，寻址形式是“基址 X0 + (X1<<3)”。
3. **Operand Fetch（取操作数）**：读寄存器 `X0、X1`；ALU 计算有效地址 `EA = X0 + (X1<<3)`。

* 以图中数值：`EA = 928 + (10 << 3) = 928 + 80 = 1008`。
4. **Execute（执行）**：访存单元从 **内存\[1008..100F]** 读取 8 字节。
5. **Result Store（写回）**：把读到的 64 位数写入 `X2`。
6. **Next Instruction**：`PC += 4`，进入下一条（除非是分支/跳转）。

同理，加载 `v[k+1]` 会用地址 `X0 + ((X1+1)<<3) = 1008 + 8 = 1016`；随后两条 `STR` 把两个值对调写回 1008 和 1016。这就完成了 C 里的：

```c
temp = v[k];
v[k]   = v[k+1];
v[k+1] = temp;
```

---

## 为什么指令地址是 0、4、8、12…？

AArch64 的基础指令**定长 32 位**，所以每条指令占 4 字节；PC 每次前进 4，这就是图中“word addresses”的由来（**字节寻址**下的“word=4 字节”对齐）。

---

## 把流程记成 6 步

1. **Instruction Fetch**：从 `[PC]` 取 32 位指令到 **IR**
2. **Instruction Decode**：解码出操作类型与操作数位置
3. **Operand Fetch**：从寄存器/内存取到需要的数据或计算有效地址
4. **Execute**：ALU/访存/分支等执行实际动作
5. **Result Store**：把结果写回寄存器或内存
6. **Next Instruction**：更新 **PC**，转到下一条（或按分支跳转）

只要把这 6 步串起来看前后几条 `LDR/STR`，你就能把“机器码 → 汇编 → C 含义 → 内存变化”完整对上号了。


---

## 第 15 页

![第 15 页](02_Assembly_assets/page-015.png)

这页在演示**CPU 的取指—译码—执行循环（execution cycle）**，并把它和我们刚才的“数组相邻两元素交换”例子对应起来看。图里把**指令区**（上半部分内存、地址 0x0000 起）和**数据区**（下半部分内存、地址 0x1000 起）画在同一张“内存”图里，好让你看到：

* 指令本身也只是内存里的**数据**（机器码），
* CPU 每次从“程序计数器 PC 指向的地址”**取 1 条指令**（AArch64 每条 **32 位=4 字节**，因此指令地址步进是 0x0000、0x0004、0x0008 …），
* 译码后去寄存器/内存拿操作数、执行、把结果写回寄存器或内存，然后把 **PC += 4**（或按分支更新）继续下一条。

---

## 名词

* **PC（Program Counter）**：下一条要执行的指令的**字节地址**。
* **IR（Instruction Register）**：当前指令的**机器码副本**（CPU 刚取回的 32 位指令会先放在 IR 里，再进行译码）。

红字 “**Word addresses / Instructions are 32b**” 提醒你：这台机的**每条指令 32 位**，图中 0、4、8、12… 这样的地址就是**按字（4 字节）对齐**的指令起始地址。

---

## 内存两块内容

* **上半（0x0000 起）**：若干条 32 位机器码（图中显示为 8 位十六进制一串，如 `D3600C22`、`8B020002`、`F8400043`…）。它们就是实现“交换 v\[k] 与 v\[k+1]”的那几条 AArch64 指令的编码。
* **下半（0x1000 起）**：数据区（和上一页一样），每 8 字节一个“槽”：

* `[1000] = 0x0A12170D34BC2DE1`
* `[1008] = 0x1111111111111111`
* `[1016] = 0x0000000000000000`
* `[1024] = 0x0F0F0F0F0F0F0F0F`
* `[1032] = [1040] = 0xFFFFFFFFFFFFFFFF`
* 左侧寄存器初值：**X0=928**（即 `&v[0]`），**X1=10**（k=10）。

> 注意：本课把 `int` 当 **64 位（8 字节）** 来讲解，所以 `v[i]` 的地址 = `X0 + i*8`，也就是 `X0 + (i << 3)`。

---

## 一条指令在“取-译-执”中的样子（以加载 v\[k] 为例）

设将要执行的是：`LDR X2, [X0, X1, LSL #3]`（把 `v[k]` 读到 X2）：

1. **Instruction Fetch（取指）**：用 **PC** 去内存地址 `[PC]` 取 4 字节机器码到 **IR**。
2. **Instruction Decode（译码）**：IR 里的比特被识别为 `LDR`，寻址形式是“基址 X0 + (X1<<3)”。
3. **Operand Fetch（取操作数）**：读寄存器 `X0、X1`；ALU 计算有效地址 `EA = X0 + (X1<<3)`。

* 以图中数值：`EA = 928 + (10 << 3) = 928 + 80 = 1008`。
4. **Execute（执行）**：访存单元从 **内存\[1008..100F]** 读取 8 字节。
5. **Result Store（写回）**：把读到的 64 位数写入 `X2`。
6. **Next Instruction**：`PC += 4`，进入下一条（除非是分支/跳转）。

同理，加载 `v[k+1]` 会用地址 `X0 + ((X1+1)<<3) = 1008 + 8 = 1016`；随后两条 `STR` 把两个值对调写回 1008 和 1016。这就完成了 C 里的：

```c
temp = v[k];
v[k]   = v[k+1];
v[k+1] = temp;
```

---

## 为什么指令地址是 0、4、8、12…？

AArch64 的基础指令**定长 32 位**，所以每条指令占 4 字节；PC 每次前进 4，这就是图中“word addresses”的由来（**字节寻址**下的“word=4 字节”对齐）。

---

## 把流程记成 6 步

1. **Instruction Fetch**：从 `[PC]` 取 32 位指令到 **IR**
2. **Instruction Decode**：解码出操作类型与操作数位置
3. **Operand Fetch**：从寄存器/内存取到需要的数据或计算有效地址
4. **Execute**：ALU/访存/分支等执行实际动作
5. **Result Store**：把结果写回寄存器或内存
6. **Next Instruction**：更新 **PC**，转到下一条（或按分支跳转）

只要把这 6 步串起来看前后几条 `LDR/STR`，你就能把“机器码 → 汇编 → C 含义 → 内存变化”完整对上号了。


---

## 第 16 页

![第 16 页](02_Assembly_assets/page-016.png)

下面把两页一起讲清楚：\*\*标志/条件码（Flags/Condition Codes）**与**控制流（Control Flow）\*\*在 AArch64 里的用法。

---

# 标志寄存器（Flags / Condition Codes）

一次算术/逻辑运算后，CPU 会在**程序状态寄存器（PSTATE）**里更新若干**标志位**，用来描述这次结果的性质，后续的条件跳转会依据它们判断真/假。常见 4 个：

* **N (Negative)**：结果为负？（有符号视角）
* **Z (Zero)**：结果是否为 0？
* **C (Carry)**：进位/借位。对加法是**产生了进位**；对减法是**没有借位**（即 X ≥ Y）。
* **V (oVerflow)**：有符号溢出？（结果绝对值超出指定位宽能表达的范围）

> 这些位只有在**带 S 后缀**或专门“比较类”的指令后才会被更新。

会更新标志位的常见指令（课件列举）：

* `ADDS/ADDIS`（加法 + 立即数变体）
* `ANDS/ANDIS`（按位与 + 立即数变体）
* `SUBS/SUBIS`（减法 + 立即数变体）
* 一些浮点比较也会设置条件码（略）

### CMP 的本质

* **`CMP X0, X1` ≡ `SUBS XZR, X0, X1`**
也就是“做一次 `X0 - X1`，**只要标志，不要结果**（结果丢到零寄存器 XZR）”
* **`CMPI X0, #15` ≡ `SUBIS XZR, X0, #15`**

理解为：**比较 = 减法 + 丢弃结果，仅保留标志**。

---

# 控制流（Control Flow）

## 无条件跳转

* `B label`：直接跳到 `label`
* `BR Xn`：跳到寄存器 `Xn` 指定的地址（常见 `BR X30` = 返回）

## 条件跳转（满足条件才跳）

两大类：

### 1）对“一个寄存器是否为 0”的快速测试

* `CBZ Xn, label`：若 `Xn == 0` 则跳
* `CBNZ Xn, label`：若 `Xn != 0` 则跳
无需先 `CMP`，适合频繁的空指针/计数器为零检查。

### 2）基于**标志位**的有条件分支 `B.<cond>`

一般流程是：**先比较（设置标志）→ 再分支**

```asm
CMP   X0, X1        // 本质做 X0 - X1，设置 N,Z,C,V
B.EQ  foo           // 若相等跳转（Z==1）
```

常用条件（有符号语义）：

* `EQ`：相等（Z==1）
* `NE`：不相等（Z==0）
* `LT`：小于（N != V）
* `LE`：小于等于（Z==1 或 N!=V）
* `GT`：大于（Z==0 且 N==V）
* `GE`：大于等于（N==V）

> 还有**无符号**比较（因为 C 的含义不同）：
> `CS/HS`（≥，依赖 C=1），`CC/LO`（<，C=0），`HI`（>），`LS`（≤）等，这页未展开。

---

# 代码到汇编的映射（课件示例）

C 伪代码：

```c
// X0=a, X1=b, X2=c
if (a == b)
a = a + 3;
else
b = b + 7;
c = a + b;
```

对应汇编（与课件一致）：

```asm
CMP   X0, X1         // 比较 a 与 b，设置标志
B.NE  ELSEIF         // 若 a!=b 跳过 then 块

ADD   X0, X0, #3     // then: a = a + 3
B     DONE           // 跳过 else

ELSEIF:
ADD   X1, X1, #7     // else: b = b + 7

DONE:
ADD   X2, X0, X1     // c = a + b
```

要点：

* `CMP` 只为**后续分支**准备条件码，不保留算术结果。
* `B.NE` 使用 **Z==0** 的条件（不相等）控制流向。
* 用 `B DONE` 跳过 else，是典型的 if/else 结构展开。
* 真实编译器会根据寄存器分配/指令调度做更多优化，比如把小块用“条件选择/加法带条件码”减少跳转（如 `CSEL`、条件执行的 `ADDS` + `CINC` 等）。

---

## 小抄：判断逻辑（有符号）

* `a == b` → `CMP a,b; B.EQ label`
* `a != b` → `CMP a,b; B.NE label`
* `a <  b` → `CMP a,b; B.LT label`（N!=V）
* `a <= b` → `CMP a,b; B.LE label`（Z==1 或 N!=V）
* `a >  b` → `CMP a,b; B.GT label`（Z==0 且 N==V）
* `a >= b` → `CMP a,b; B.GE label`（N==V）

## 小抄：判断逻辑（无符号）

* `a <  b` → `CMP a,b; B.CC/B.LO label`（C==0）
* `a <= b` → `CMP a,b; B.LS label`（C==1 或 Z==1）
* `a >  b` → `CMP a,b; B.HI label`（C==1 且 Z==0）
* `a >= b` → `CMP a,b; B.CS/B.HS label`（C==1）

---

### 实战小贴士

* 只在**需要条件**时用带 `S` 的指令（或 `CMP`）去更新标志，避免无谓覆盖。
* 分支很多时，考虑**条件选择**类指令（`CSEL/CSINC/CSINV/CSNEG` 等）把控制依赖改成数据依赖，减少跳转失误代价。
* `CBZ/CBNZ` 是“判断是否为 0”的最快路径；其他比较先 `CMP` 再 `B.<cond>`。


---

## 第 17 页

![第 17 页](02_Assembly_assets/page-017.png)

这页让你把这段 C 循环

```c
// 计算 0..N-1 的和
int sum = 0;
for (int I = 0; I != N; I++) {
sum += I;
}
```

翻成 AArch64 思维：**寄存器持值、比较设置标志、条件分支回跳**。

讲义已约定：`X0=N`（输入），`X1=sum`，`X2=I`。

---

# 思路拆解

1. **初始化**

* `sum = 0` → `X1 = 0`
* `I = 0` → `X2 = 0`
2. **循环条件**：`I != N`

* 用 `CMP X2, X0` 设置标志，再用 `B.EQ` 退出或 `B.NE` 进入/继续。
3. **循环体**：`sum += I` → `ADD X1, X1, X2`
4. **自增**：`I++` → `ADD X2, X2, #1`
5. **回跳**：无条件 `B` 回到“条件判断”位置

---

# 直译版 AArch64（64 位寄存器）

```asm
MOV     X1, #0            // sum = 0
MOV     X2, #0            // I   = 0

LOOP_CHECK:
CMP     X2, X0            // I ? N   (设置标志)
B.EQ    LOOP_END          // 如果 I==N，结束

ADD     X1, X1, X2        // sum += I
ADD     X2, X2, #1        // I++

B       LOOP_CHECK        // 回到检查

LOOP_END:
// 结果在 X1
```

说明：

* `CMP` 本质是 `SUBS XZR, X2, X0`；`B.EQ` 依赖 Z 标志（相等）。
* 时间复杂度 O(N)，迭代 N 次（当 N≤0 时，第一次检查就直接结束）。

---

# 微调写法（先体后判 / do-while 风格）

如果想避免首次比较，也可以先判 `CBZ` 处理 N==0，然后在循环尾部比较：

```asm
MOV     X1, #0
MOV     X2, #0
CBZ     X0, LOOP_END      // N==0 直接结束

LOOP_BODY:
ADD     X1, X1, X2
ADD     X2, X2, #1
CMP     X2, X0
B.NE    LOOP_BODY

LOOP_END:
```

`CBZ` 是“是否为 0”的快捷判断。

---

# 小优化与思考

* **数学闭式**：和为 `N*(N-1)/2`。若允许用乘/移/除，可以不用循环：

```asm
MUL   X1, X0, X0           // X1 = N*N
SUB   X1, X1, X0           // N*(N-1)
LSR   X1, X1, #1           // 除以 2（N*(N-1)/2）
```

（仅当 `N` 非负、且不需检测溢出时可直接用；乘法/右移比循环快得多）
* **32 位版本**：把 `X*` 改为 `W*` 即可（对低 32 位运算）。
* **条件变化**：若写成 `I < N`，就用 `CMP X2, X0; B.GE LOOP_END`（有符号）或 `B.HS`（无符号）。

这正体现了控制流页讲的套路：**比较 → 设置条件码 → 依条件分支**，并用**无条件分支**把控制流连成环。


---

## 第 18 页

![第 18 页](02_Assembly_assets/page-018.png)

这页要你把一段把字符串转成大写的 C 代码，换成“按字节加载/存储 + 条件分支”的 AArch64 思维。

C 版逻辑（以 0 结尾的 C 字符串）：

```c
char *index = string;
while (*index != 0) {             // 直到遇到 '\0'
if (*index >= 'a' && *index <= 'z')
*index = *index + ('A' - 'a'); // 把小写变大写
index++;
}
```

要点：

* ASCII：'A'=65，'a'=97，'z'=122，且 `'A' - 'a' = -32` ⇒ 把小写改大写就是**减 32**。
* 每次处理 **1 字节**：读取字节 → 判断是否在 `[97,122]` → 是则减 32 → 写回 → 指针加 1。
* `*index != 0`：遇到 0（空字符）表示字符串结束。

---

# AArch64 汇编（常见写法）

假设：**X0 = index（字符串当前字符的地址）**。若你需要先从某个内存位置取到指针，再把它放进 X0，也可以在前面加一条 `LDR X0, [<addr>]`。

```asm
// X0 = index（指向当前字符）
LOOP:
LDRB    W1, [X0]          // 取 1 字节到 W1（零扩展）
CBZ     W1, DONE          // 若 *index == 0，结束

CMP     W1, #'a'          // 和 97 比较
BLT     NOCHANGE          // < 'a'：不是小写
CMP     W1, #'z'          // 和 122 比较
BGT     NOCHANGE          // > 'z'：不是小写

SUB     W1, W1, #32       // *index = *index - 32 (等价于 +('A'-'a'))
STRB    W1, [X0]          // 写回 1 字节

NOCHANGE:
ADD     X0, X0, #1        // index++
B       LOOP

DONE:
// 完成。若需要，X0 此时指向字符串结尾的 '\0'
```

说明与细节：

* **按字节访问**：用 `LDRB/STRB`（B = Byte）。`LDRB` 会把那个字节零扩展到 32 位 `W1`；我们用 `W1` 做比较和减法即可。
* **比较与分支**：`CMP` 设置标志位；`BLT/BGT` 根据有符号比较分支。这里 ASCII 都在 0..127，符号/无符号结果一致。
* **转换**：不能写 `ADD W1, W1, #-32`（立即数不支持负号）；用 `SUB W1, W1, #32`。
* **循环条件**：`CBZ W1, DONE` 是判断是否 0 的最快路径。

---

# 如果“string 的指针保存在内存地址 80”

幻灯片脚注写了这点，可在进入循环前先把指针装到 `X0`（这里只示意“绝对地址”加载的样子，实际程序里通常通过全局符号/栈取）：

```asm
// 仅示意：把 Memory[80] 里的 64 位指针装到 X0
LDUR    X0, [XZR, #80]    // 或者用合适的伪指令/常量池加载
B       LOOP              // 然后进入上面的循环
```

这样就完整实现了“把字符串原地转换为全大写”。


---

## 第 19 页

![第 19 页](02_Assembly_assets/page-019.png)

这页在对比**汇编语言**和**机器语言**，并用我们前面写过的“交换 `v[k]` 与 `v[k+1]`”示例，展示“每条汇编 ≈ 一条32位机器码”的一一对应关系。

# 汇编 vs 机器码

* **Assembly Language（汇编）**

* 用**助记符**（`ADD/LDUR/STR/BR` 等）和**寄存器名**（`X0`…）来写，**可读性强**。
* 用**标签**（如 `SWAP:`、`DONE:`）而不是硬编码地址。
* 对程序员友好；和机器码**几乎一一对应**（RISC/定长编码）。

* **Machine Language（机器语言）**

* **纯数字比特表示**（右列的 32 位 0/1 串）。
* 这是 CPU 真正取用、解码、执行的格式。
* 每条 AArch64 指令都是 **32 位**（4 字节），所以 PC 每次 +4。

---

# 例子：交换相邻两个元素（`int` 按 8 字节算）

左侧是汇编，每一行右边是它编码后的**32 位机器码**（二进制）。

```asm
SWAP:
LSL   X9, X1, #3            ; X9 = X1 << 3     // 计算 k*8
ADD   X9, X0, X9            ; X9 = X0 + X9     // &v[k]
LDUR  X10, [X9, #0]         ; X10 = v[k]
LDUR  X11, [X9, #8]         ; X11 = v[k+1]
STUR  X11, [X9, #0]         ; v[k]   = X11
STUR  X10, [X9, #8]         ; v[k+1] = X10
BR    X30                   ; 返回（X30=LR）
```

逐句说明：

* `LSL X9, X1, #3`
把 k 左移 3 位得到 `k*8`（因为元素是 8 字节）。这条在 AArch64 里是“带立即数的逻辑左移（对 64 位宽度）”，编码里含：操作码 + 目标寄存器 Rd(=X9) + 源寄存器 Rn(=X1) + 立即数字段 imm(=3)。
* `ADD X9, X0, X9`
计算 `&v[0] + k*8` ⇒ `&v[k]`。编码里有：`ADD` 的 opcode、Rd(=X9)、Rn(=X0)、Rm(=X9)。
* `LDUR X10, [X9, #0]`
**Unscaled** 负载：从 `X9+0` 读 **8 字节**（因为是 X 寄存器变体）到 X10。编码有：负载/存储类 opcode、位宽位、目的寄存器 Rt、基址 Rn、**字节偏移** imm=0。
* `LDUR X11, [X9, #8]`
从 `X9+8` 读下一个元素到 X11。
* `STUR X11, [X9, #0]`、`STUR X10, [X9, #8]`
把两个值对调写回去；`STUR` 的编码类似 `LDUR`，只是 opcode 表示“存储”。
* `BR X30`
无条件跳转到寄存器 `X30` 指定的地址（`LR`），也就是**返回调用者**。编码里包含分支类 opcode 和寄存器字段 Rn(=X30)。

> 右侧每条机器码的 0/1 串就是上述字段拼起来的结果：
> **\[操作码 | 宽度/寻址模式位 | 立即数/移位 | Rm/Rn/Rd/ Rt]**。
> 这正体现了“汇编≃机器码”的**近乎 1:1**关系：换个助记符/寄存器/立即数，机器码里对应的字段就换成相应的比特。

---

## 为什么先 `LSL` 再 `ADD`？

因为数组元素是 **8 字节**，第 `k` 个元素相对基址的偏移是 `k*8`。左移 3 位（×8）再相加，正好算出 `&v[k]`。
（也可用“缩放寄存器偏移”的寻址形式一条写成 `LDR X10, [X0, X1, LSL #3]`，但这里分成两步更直观。）

---

## 小贴士

* `LDUR/STUR` 的偏移是**字节**，适合任意布局；常见的 `LDR/STR` 则多用“缩放偏移”（偏移单位按数据大小缩放），写数组时更简洁。
* `BR X30` 与 `RET` 效果等价（`RET` 是 `BR X30` 的别名/专用语法）。
* 你可以把右边二进制转成十六进制来查看（更常见的机器码展示方式），本质一样。

这页的 takeaway：**汇编是“贴着机器码的人类可读层”**；理解了每条指令的字段，你就能从汇编直接联想到它在硬件里的 32 位编码与执行行为。


---

## 第 20 页

![第 20 页](02_Assembly_assets/page-020.png)

这页在讲“**标签（labels）**与**分支是相对 PC 的**”，并用“求 0…N-1 的和”的循环当例子。

# 标签是干嘛的

* **标签本质就是“这一条指令的地址的别名”**。
例如 `TOP:` 代表紧随其后的那条指令地址。以后分支到 `TOP`，汇编器会自动把“当前 PC 到 TOP 的距离”换算成机器码里的**分支位移**。
* **好处**：程序员不用自己数第几行、也不用手动改地址。中间插／删指令后，汇编器会**重新计算偏移**，你的 `B TOP` 等语句不需要改。

# 例子逐行解释

（讲义依然用课堂记号：`X31` 代表零寄存器 `XZR`，`ADDI` 表示“带立即数的 ADD”）

```asm
// 约定：X0=N，X1=sum，X2=I
ADD  X1, X31, X31      // sum = 0    (X1 = 0)
ADD  X2, X31, X31      // I   = 0    (X2 = 0)

TOP:
CMP  X2, X0            // 比较 I 与 N，设置标志
B.GE END               // 若 I >= N 则结束（! (I < N)）

ADD  X1, X1, X2        // sum += I
ADDI X2, X2, #1        // I++

B    TOP               // 回到循环开头

END:
```

* `ADD X1, X31, X31`：用**零寄存器**给 `X1` 置 0（课堂简写；常见写法也可用 `MOV X1, #0`）。
* `CMP` 只是为了设置标志位（Z/N/V/C），不给任何寄存器存结果。
* `B.GE END` 用“有符号 ≥”条件（`N==V`），判断 `I` 是否到达/超出 `N`。
* `B TOP` 是**无条件分支**，跳回 `TOP:`。

# 关键笔记：**分支是相对 PC（PC-relative）**

* AArch64 的分支机器码里存的不是“绝对地址”，而是**相对位移**（当前 PC 到目标的距离）。
* 由于**每条指令 4 字节**，偏移单位是“指令字”（word），所以：

```
PC_new = PC_old + 4 * (BranchOffset)
```
* **BranchOffset > 0**：向下跳（到**更高地址**的后面指令）
**BranchOffset < 0**：向上跳（回到**更低地址**的前面指令，也就是“回环”）

这些细节都是**汇编器自动完成**的：你写 `B TOP`，它会把 `TOP` 的地址减去“这条分支之后的 PC”，得到位移，填进机器码字段。你只需要记住**用标签写程序**即可，维护成本低、可读性好。


---

## 第 21 页

![第 21 页](02_Assembly_assets/page-021.png)

这页要你**算出各个标签（LOOP/NEXT/END）的地址**，以及分支到这些标签时的**偏移量**。给定前提：

* 程序从 **地址 100** 开始；
* **每条指令 32 位=4 字节**；
* 分支是 **PC-relative**，课件公式：`PC = PC + 4*(BranchOffset)`
⇒ `BranchOffset = (TargetAddr - (BranchAddr+4)) / 4`（单位是“指令字”）。

---

## 逐条标地址

```
100: LDUR   X0, [X31, #100]

104: LOOP:  LDURB  X1, [X0, #0]
108:        CBZ    X1, END
112:        CMPI   X1, #97
116:        B.LT   NEXT
120:        CMPI   X1, #122
124:        B.GT   NEXT
128:        SUBI   X1, X1, #32
132:        STURB  X1, [X0, #0]

136: NEXT:  ADDI   X0, X0, 1
140:        B      LOOP

144: END:
```

**标签地址：**

* `LOOP = 104`
* `NEXT = 136`
* `END  = 144`

---

## 计算各分支的 BranchOffset

按 `BranchOffset = (Target - (Addr+4)) / 4`：

* `CBZ X1, END` 在 **108**：
`off = (144 - (108+4)) / 4 = (144 - 112)/4 = 8`
* `B.LT NEXT` 在 **116**：
`off = (136 - (116+4)) / 4 = (136 - 120)/4 = 4`
* `B.GT NEXT` 在 **124**：
`off = (136 - (124+4)) / 4 = (136 - 128)/4 = 2`
* `B LOOP` 在 **140**：
`off = (104 - (140+4)) / 4 = (104 - 144)/4 = -10`

> 正偏移＝**往下跳**（到更高地址）；负偏移＝**往上跳**（回到更低地址），这也正是循环回跳的样子。


---

## 第 22 页

![第 22 页](02_Assembly_assets/page-022.png)

这页在教你：**按“用到的寄存器个数”来给指令分类型**。只**统计寄存器操作数**，**不把立即数、标签/地址算作寄存器**。这么分有助于理解指令编码字段和使用场景。

# 怎么数？

* 只看形如 `Xn / Wn` 的寄存器数量。
* 立即数（`#100`、`#4`）、位移、标签（`START`、`DEST`）、内存偏移（`#14`）都**不算寄存器**。

# 各类与示例

## 3-register（三寄存器）

典型“寄存器-寄存器”算术/逻辑：**一个目的寄存器 + 两个源寄存器**

* `ADD X0, X1, X2`  → `X0 = X1 + X2`
* `AND X0, X1, X2`  → `X0 = X1 & X2`
特点：结果不必覆盖输入，表达力强，编码里会有 Rd/Rn/Rm 三个寄存器字段。

## 2-register（两寄存器）

**一个目的 + 一个源**（另一个操作数是立即数/位移），或**访存类指令的 目的/基址 两个寄存器**

* 立即数字/移位：`ADDI X0, X1, #100`，`ANDI X0, X1, #7`，`LSL X0, X1, #4`，`LSR X0, X1, #2`
* 访存（目的是 Rt，基址是 Rn）：

* 读：`LDUR X0, [X1, #14]`，`LDURB X0, [X1, #14]`
* 写：`STUR X0, [X1, #14]`，`STURB X0, [X1, #14]`
特点：编码里有两个寄存器字段（例如 Rd/Rn 或 Rt/Rn），外加一个立即数/偏移字段。

## 1-register（一寄存器）

只涉及一个寄存器的控制类：

* **寄存器间接跳转**：`BR X30`（跳到 `X30` 指向地址）
* **按寄存器为零分支**（有的资料也归到“1-reg”）：`CBZ X0, FOO` / `CBNZ X0, FOO`
特点：编码里只有一个寄存器字段。

## 0-register（零寄存器）

既不读也不写通用寄存器，只依赖**标签或条件码**：

* 无条件到标签：`B START`（不含寄存器，仅标签）
* 条件码分支：`B.EQ DEST`、`B.NE …`、`B.GE …`（依据 N/Z/C/V 标志，不显式写寄存器）

# 为何这样分有用？

* **看指令就能估寄存器压力**（需要几个寄存器参与）。
* **理解编码**：3R 指令会有 Rd/Rn/Rm 三个字段；2R 指令常配一个立即数字段或内存偏移字段。
* **写汇编时更顺手**：想到“内存↔寄存器”通常是 2R，算术寄存器-寄存器多是 3R，控制流多是 0/1R。


---

## 第 23 页

![第 23 页](02_Assembly_assets/page-023.png)

这页在讲 **AArch64 指令编码格式**：所有指令都是**32 位定长**，把“操作类型（opcode）+ 操作数（寄存器/立即数/位移）”装进不同的字段。下面按图中的 5 类说明每种格式的**字段含义、位宽**，以及它们跟汇编的对应关系。

---

## 总则

* 每条指令 32 位：`Instr[31:0]`。
* 高位的 **Instr\[31:21]** 基本决定“是哪一大类/子类”（右侧给了若干十六进制范围，表示这个位段取这些值时属于该类）。
* 其余位段存放寄存器号、立即数、位移、条件码等。

---

## 1) Branch (B-Type)：无条件跳转

**字段**：`Opcode | BrAddr26`

* **BrAddr26**：26 位**有符号位移**，单位是**指令字**（4 字节）。

* 真实跳转字节位移 = `sign_extend(BrAddr26) << 2`。
* 例：`B label`

* 汇编器算出 `label - (PC+4)`，除以 4 填到 `BrAddr26`。

**用途**：长距离无条件分支（前后都能跳，范围≈±128MB）。

---

## 2) Conditional Branch (CB-Type)：带条件的“按寄存器为零/非零”或“条件码”

**字段**：`Opcode | CondAddr19 | Rd`（讲义的 Rd 一般指**被测试的寄存器**）

* **CondAddr19**：19 位**有符号位移**（同样按 4 字节缩放）。
* **Rd / Rt**：参与条件的寄存器（例如 `CBZ/CBNZ` 的目标寄存器）。
* 两大用法：

1. `CBZ Rt, label` / `CBNZ Rt, label`：测试 **Rt==0 / !=0** 则跳。
2. `B.<cond> label`（另一种编码称 “B.cond”，低位还包含 4 位条件码；课件把它们都归到 CB-Type）。

**范围**：≈±1MB（19 位位移）。

---

## 3) Register (R-Type)：三寄存器类（寄存器-寄存器运算）

**字段**：`Opcode | Rm | SHAMT | Rn | Rd`

* **Rd**：目的寄存器
* **Rn**：源寄存器 1
* **Rm**：源寄存器 2
* **SHAMT**：6 位**移位量**（对“带移位的第二操作数”或“显式移位指令”使用）
* 例：

* `ADD X0, X1, X2`：把 X1、X2 编到 `Rn/Rm`，X0 编到 `Rd`。
* `LSL X0, X1, #4`：`Rm` 常为 X1，`SHAMT=4`，`Rd=X0`，对应“逻辑左移”。

---

## 4) Immediate (I-Type)：两寄存器 + 立即数（寄存器-立即数运算）

**字段**：`Opcode | ALU_Imm12 | Rn | Rd`

* **ALU\_Imm12**：12 位**立即数/掩码**（有些指令还带“移位一位域”形成更大的立即数）。
* 例：

* `ADDI X0, X1, #100`：`Imm12=100`，`Rn=X1`，`Rd=X0`。
* `ANDI/ORRI/EORI` 也属于此类（立即数需满足 ARM 的可编码形状）。

---

## 5) Memory (D-Type)：访存（Load/Store）

**字段**：`Opcode | DT_Address9 | 00 | Rn | Rd`

* **Rd**（或 `Rt`）：载入/存储的寄存器。
* **Rn**：基址寄存器。
* **DT\_Address9**：9 位**有符号字节偏移**（**Unscaled** 形式，对 `LDUR/STUR/LDURB/STURB/…`）。
* 例：`LDUR X0, [X1, #14]`：`Rt=X0`，`Rn=X1`，`Address9=14`。

* 若用 `LDR/STR` 的\*\*缩放偏移（scaled）\*\*变体，编码格式会换另一个子类（立即数位宽常为 12 位无符号，偏移单位按数据宽度缩放），本页专门画的是 **D-Type（Unscaled）**。

---

## 小抄 & 细节

* **PC 相对位移**都以**指令字**为单位：
`实际字节位移 = sign_extend(imm) << 2`，因此 `PC_next = (PC_of_this + 4) + (imm << 2)`。
* **寄存器号**：`X0..X30`/`W0..W30` 都会编码成 5 位字段；`XZR/WZR` 与 `SP` 在不同指令里有特判/复用。
* **SHAMT**（R-Type 的移位量）是 6 位 → 64 位指令最大移 0..63。
* **I-Type 立即数**常 12 位（0..4095），很多 ALU 指令允许把该立即数预先**左移 12 位**来扩展范围（由另一个 1 位字段控制）。
* **D-Type 的 9 位偏移**是**有符号**（支持负偏移），适合结构体/栈帧附近的地址；**缩放 LDR/STR** 用 12 位**无符号**偏移，适合数组按元素大小访问。

---

## 把汇编“看成字段”

举两个直观映射：

1. `ADD X0, X1, X2`（R-Type）

```
[31:21]=opcode(ADD, 64b) | Rm=X2 | SHAMT=0 | Rn=X1 | Rd=X0
```

2. `B label`（B-Type）

```
[31:26]=opcode(B) | BrAddr26 = (label - (PC+4)) >> 2
```

理解了这些“版面”，你就能把一行汇编直接联想到它的 32 位机器码**各个字段放了什么**，也更容易读反汇编/写手工编码。


---

## 第 24 页

![第 24 页](02_Assembly_assets/page-024.png)

这页在讲 **B-Type（无条件跳转）指令的编码**。

# 它做什么

`B label` 用 **PC 相对**的方式跳到 `label`。
编码结构（32 位）：

```
[31..26]   [25..0]
opcode     BrAddr26
```

* `opcode`= `000101`（即 0x05，对应 B 指令）
* **BrAddr26**：26 位**有符号位移（以“指令字”为单位）**
真正的字节位移 = `sign_extend(BrAddr26) << 2`
执行后 PC 变为：`PC_next = (PC_of_this + 4) + (BrAddr26 << 2)`

> 由于位移是 26 位带符号，范围约为 **±2²⁵ 条指令**，折算成字节是 **±2²⁷ B ≈ ±128 MB**。

# 汇编器如何算这个位移

```
BrAddr26 = (target - (PC_of_this + 4)) >> 2
```

* `PC_of_this`：这条分支指令的地址
* 先求**字节差**，再右移 2（因为按 4 字节对齐计数）

# 例子：`B  -3`

注释里写了：`PC = PC + 4 * (-3)`，也就是 **跳回 3 条指令**（回退 12 字节）。

* 要编码到指令里：`BrAddr26 = -3`（26 位二补数表示）
* 26 位的 `-3` 等于 `0x3FFFFFD`（= 2²⁶ − 3）。
* 整条指令比特就是：`opcode(000101)` 接上 `BrAddr26 = 0x3FFFFFD`。

# 小抄

* **向下跳**（到更高地址）⇒ `BrAddr26` 为正
* **向上跳**（回环）⇒ `BrAddr26` 为负
* 汇编时只写 `B label`，**汇编器自动**把 `label` 换算成 `BrAddr26`，你无需手动数地址。


---

## 第 25 页

![第 25 页](02_Assembly_assets/page-025.png)

这页讲的是 **CB-Type（Conditional Branch 类型）**指令——也就是**有条件跳转**的两大族：

1. **按寄存器是否为 0** 的快速分支：`CBZ/CBNZ`
2. **按条件码**（NZCV 标志）判断的分支：`B.<cond>`（又叫 `B.cond`）

---

# 编码版式（32 位定长）

```
[31..24]  [23........5]   [4..0]
Opcode     CondAddr19      Rd
```

* **Opcode**：决定是哪一类

* `0x54` → `B.cond`（条件码分支）
* `0xB4` → `CBZ`（==0）
* `0xB5` → `CBNZ`（!=0）
* **CondAddr19**：**19 位有符号位移**（单位是**指令字**=4B）。
实际跳转字节位移 = `sign_extend(imm19) << 2`，因此
`PC_next = (PC_of_this + 4) + (imm19 << 2)`

> 范围 ≈ ±2¹⁸ 条指令 ≈ **±1 MB**。
* **Rd**：

* 对 `CBZ/CBNZ`：这是**被测试的寄存器**（例如 `CBZ X12, label` → Rd=12）。
* 对 `B.cond`：这里存**4 位条件码**（课件写在右侧“Reg or Cond. Code”）。

---

# 条件码（对 `B.cond`）

课件列出的一些编码（十六进制）与含义（有符号语义）：

| 编码     | 条件   | 含义             |
| ------ | ---- | -------------- |
| `0x00` | `EQ` | 等于（Z==1）       |
| `0x01` | `NE` | 不等（Z==0）       |
| `0x0A` | `GE` | ≥（N==V）        |
| `0x0B` | `LT` | ＜（N!=V）        |
| `0x0C` | `GT` | ＞（Z==0 且 N==V） |
| `0x0D` | `LE` | ≤（Z==1 或 N!=V） |

> 还有无符号条件：`HS/CS`(≥)、`LO/CC`(<)、`HI`(>)、`LS`(≤) 等，这页未列出。

---

# 两种常见用法

### 1) 按是否为零分支：`CBZ/CBNZ`

* `CBZ Xn, label`：若 `Xn == 0` 则跳
* `CBNZ Xn, label`：若 `Xn != 0` 则跳
无需先 `CMP`，最适合做“空指针/计数为 0”检查。
例（来自图）：

```
CBZ X12, -3      // 若 X12==0，则 PC ← PC + 4 * (-3)
```

汇编器会把 `-3` 编成 19 位二补数填进 `imm19`。

### 2) 按条件码分支：`B.<cond>`

通常先用算术/比较**设置 NZCV**，再分支：

```asm
CMP   X0, X1       // 设置 N Z C V
B.LT  label        // 若 X0 < X1（有符号：N!=V）则跳
```

图中例子：

```
B.LT -5            // 若 (lessThan) 则 PC ← PC + 4 * (-5)
```

---

# 计算位移的小抄

> **imm19 = (Target - (PC\_of\_this + 4)) >> 2**（四字节对齐，所以要除以 4）

* 正数 → **向下**跳（去更高地址）
* 负数 → **向上**跳（回环）

---

# 什么时候用哪一个？

* 只需要判断“是否为 0” → 用 `CBZ/CBNZ`（编码短、执行快）。
* 需要比较大小、等于、不等等 → 先 `CMP/ADDS/SUBS…` 设置标志，再 `B.cond`。

掌握这页后，你能看懂 **条件跳转**在机器里是怎么被编码成“**Opcode + 19 位相对位移 +（寄存器/条件码）**”，并能手算它到底跳了几条指令。


---

## 第 26 页

![第 26 页](02_Assembly_assets/page-026.png)

这页讲 **AArch64 的 R-Type 指令格式**——也就是“**三寄存器**（或带移位量）的 ALU/移位类指令”的32位编码长相，以及常见操作在这个格式里的具体占位。

# 1) R-Type 格式长相（32 位）

```
[31..21]     [20..16] [15..10] [9..5] [4..0]
Opcode        Rm      SHAMT     Rn     Rd
源2寄存    移位量    源1     目的
```

* **Rd / Rn / Rm**：各 5 位，表示 `X0..X30` / `W0..W30`（哪一套由 opcode 决定 32 位还是 64 位变体）。
* **SHAMT**：6 位移位量（0–63）。

* 对“显式移位”（`LSL/LSR`）就是移多少位；
* 对“普通算术/逻辑（不带移位）”应 **置 0**。
* 部分特殊指令（如 `SDIV/MUL`）该字段固定填某个模式值（图里备注 `shamt=02/1F`）。

# 2) 这些操作都用 R-Type

幻灯片列了 `Instr[31:21]` 的取值（十六进制范围）对应的操作族（只需知道“它们都落在 R-Type”即可）：

* `0x450`: `AND`          → `Xd = Xn & Xm`
* `0x458`: `ADD`          → `Xd = Xn + Xm`
* `0x4D6`: `SDIV`（shamt=02）
* `0x4D8`: `MUL`  （shamt=1F）
* `0x550`: `ORR`          → `Xd = Xn | Xm`
* `0x558`: `ADDS`         → 同 `ADD` 但**更新 NZCV 标志**
* `0x650`: `EOR`          → `Xd = Xn ^ Xm`
* `0x658`: `SUB`          → `Xd = Xn - Xm`
* `0x69A`: `LSR`          → 逻辑右移（`SHAMT`=移位量）
* `0x69B`: `LSL`          → 逻辑左移（`SHAMT`=移位量）
* `0x6B0`: `BR`           → `BR Xn`（这里“除了 Rd 其余位全 0”的特例，编码落在这片区）
* `0x750`: `ANDS`         → `AND` 且更新标志
* `0x758`: `SUBS`         → `SUB` 且更新标志

> “S” 结尾（`ADDS/ANDS/SUBS`）表示**写 NZCV**，便于随后 `B.<cond>` 分支使用。

# 3) 两个例子看字段怎么填

* `ADD X3, X5, X6`

```
Opcode(ADD, 64b) | Rm=X6 | SHAMT=0 | Rn=X5 | Rd=X3
```
* `LSL X10, X4, #6`

```
Opcode(LSL, 64b) | Rm=X4 | SHAMT=6 | Rn=XZR(或按该变体约定) | Rd=X10
```

（很多汇编器把 `LSL Xd, Xn, #k` 视为“带移位的寄存器操作”专门编码，`SHAMT=k`）

# 4) 常见注意点

* **32 位/64 位变体**：同一助记符有 `W*` 与 `X*` 两版，由 Opcode 的位型区分；`W` 运算只影响低 32 位并清零高 32 位。
* **SHAMT 必须合法**：超过位宽（W=0..31 / X=0..63）无定义。
* **R-Type 也可表示“带移位的第二操作数”**：例如某些 `ADD` 允许对 `Rm` 先 `LSL #k` 再参与相加，其本质就是把 `SHAMT=k` 编在 R-Type 里。
* **`BR` 属控制流，但编码落在此类表中的一个子区**；实质只用到一个寄存器字段（目标地址寄存器）。

掌握了这个版式，你基本能从一条三寄存器/移位指令直接“看到”它在 32 位机器码里各字段是怎么摆放的，也就更容易读/写和核对编码。


---

## 第 27 页

![第 27 页](02_Assembly_assets/page-027.png)

这页讲 **I-Type（Immediate Type）** 指令格式——也就是“**两个寄存器 + 一个常数**”的 ALU 指令在 AArch64 里的 32 位编码方式与用法。

# 它长什么样（32 位定长）

```
[31..22]   [21..10]      [9..5] [4..0]
Opcode    ALU_Imm12       Rn     Rd
（12 位立即数）  源1     目的
```

* **Rd**：目的寄存器（X/Wn）
* **Rn**：源寄存器
* **ALU\_Imm12**：12 位立即数（0..4095）。
对于 **ADD/SUB** 家族，还有一个**可选左移 12 位**的变体（由另一位控制，PPT 为简化没画出），等价把常数当 `imm12 << 12` 使用，常见于加/减偏移量（如 4096 的倍数）。
* **Opcode**：决定是哪条具体指令及其 32/64 位变体、是否更新标志位（S）。

# 这类指令都归 I-Type

（讲义右侧给出了部分 “Instr\[31:21]” 范围的助记符）

* `ADDI`   → `Rd = Rn + imm`
* `SUBI`   → `Rd = Rn - imm`
* `ADDIS` / `SUBIS` → 同上但**更新 NZCV 标志位**（供后续 `B.<cond>` 用）
* 逻辑立即数族：`ANDI / ORRI / EORI`（按位与/或/异或一个常数）

> 注意：**逻辑立即数**在真实 AArch64 中使用“**位掩码立即数**”编码，允许的常数是有限形状（不是单纯 0..4095）。PPT 为入门把它们也放到同一“2寄存器+立即数”的 I-Type 框里理解即可。

# 一个例子（来自投影片）

```
ADDI X8, X3, #35   // X8 = X3 + 35
```

字段填法：

* `Rd = X8`，`Rn = X3`
* `ALU_Imm12 = 35`
* `Opcode = ADD (64 位、立即数字形)`

# 小抄与细节

* **W 寄存器变体**：若写 `Wn/Wd` 则在 32 位内运算，结果会**清零高 32 位**。
* **更新标志位**：`…IS` 版本（如 `ADDIS/SUBIS/ANDIS`）会写 NZCV，普通版不会。
* **加/减立即数的“移 12 位”变体**：当常数是 4096 的倍数（如 0x1000, 0x2000…）时，用带 `sh=1` 的编码可一次性加/减大常数（等价 `Rn + (imm12<<12)`），常用于栈帧、结构体大偏移。
* **逻辑立即数**：`ANDI/ORRI/EORI` 的常数不是任意 12 位；汇编器会在可编码范围内接受/拒绝你写的值（常见如 `ANDI W0, W0, #0xFF00FF00` 这类“重复掩码”）。

掌握这页后，看见“**一个寄存器 + 一个立即数**”的算术/逻辑，就知道它会被编码成：**Opcode + 12 位常数 + Rn + Rd**（再加上少量控制位，比如是否 32/64 位、是否写标志、是否把 imm 左移 12 位等）。


---

## 第 28 页

![第 28 页](02_Assembly_assets/page-028.png)

这页讲 **D-Type（用于访存的“未缩放偏移”格式）**，也就是像 `LDUR/STUR/LDURB/STURB` 这类**寄存器 ↔ 内存**搬数据的指令在 AArch64 里的 32 位编码。

# 它长什么样（32 位）

```
[31..21]   [20..12]   [11..10] [9..5] [4..0]
Opcode     DAddr9       00      Rn     Rd
9位有符号偏移         基址   目标寄存器
```

* **Opcode**：决定读/写、字节宽度（byte/halfword/word/dword）等。
* **DAddr9**：**9 位有符号“字节偏移”**（−256..+255）。因为是**未缩放（unscaled）**，写多少就是加/减多少字节。
* **Rn**：**基址寄存器**（地址从它开始加偏移）。
* **Rd**（或 `Rt`）：**目标寄存器**（load 的接收者 / store 的来源）。
* 中间固定的 **`00`** 是这个编码族的标识位。

# 对应的助记符（示例）

* `0x1C0: STURB`  （存 1 字节）
* `0x1C2: LDURB`  （读 1 字节 → 零扩展进 W 寄存器）
* `0x7C0: STUR`   （存 double-word，X 寄存器→8 字节）
* `0x7C2: LDUR`   （读 double-word，8 字节→X 寄存器）

> 例：`LDUR X6, [X15, #12]`
> 语义：`X6 = Memory[ X15 + 12 ]`（从 `X15+12` 地址处**读 8 字节**到 `X6`）

# 和缩放寻址的对比

* **未缩放（本页 D-Type）**：偏移单位就是**字节**，9 位有符号 → 适合结构体/栈帧附近的任意字节偏移，哪怕未对齐也行（性能可能差）。
* **缩放（常见的 `LDR/STR` 另一类编码）**：偏移是**无符号 12 位**，但**按数据宽度缩放**（对 64 位元素偏移单位=8，对 32 位=4…）。数组访问更方便，范围更大（0..4095 单位）。

# 数据宽度与寄存器

* `LDUR/STR`（X/W 决定**读取 64/32 位**）
* `LDURB/STURB`（**8 位**；`LDRB` 读取时零扩展到 `W`）
* 还有 `LDURH/STURH`（**16 位**，读入 `W`）等。

# 读/写语义（统一记法）

```
LDUR  Rt, [Rn, #imm]   → Rt = *(width) ( Rn + imm )
STUR  Rt, [Rn, #imm]   → *(width) ( Rn + imm ) = Rt
```

* `imm` = `DAddr9` 的符号扩展值（单位：**字节**）。
* `width` 由指令决定（B/H/W/X）。

# 常见注意点

* **范围**：偏移 ±256 字节；超出这个范围可以：

1. 先用 `ADD/SUB` 调整基址；或
2. 改用**缩放的 `LDR/STR`**（若数据对齐且符合“元素大小”的访问）。
* **对齐**：架构允许未对齐，但对齐（如 8 字节对 8 对齐）通常更快。
* **SP 与 XZR 复用**：部分访存编码里 `Rn` 可写 `SP` 做栈访问（不是零寄存器），由 opcode 位区分；写 `XZR` 则当作普通基址 0 的简便写法在某些汇编器中并不总是允许。
* **符号 vs 零扩展**：按字节/半字的 **Load** 有 `LDRSB/LDRSH`（**符号扩展**）和 `LDRB/LDRH`（**零扩展**）两类，按需要选择。

掌握这页：看到 `LDUR/STUR/LDURB/STURB` 就知道它们属于 **D-Type 未缩放偏移**，字段分别是 **Opcode + 9 位有符号字节偏移 + 基址 Rn + 目标 Rd**。


---

## 第 29 页

![第 29 页](02_Assembly_assets/page-029.png)

这页把“求 0…N-1 的和”从 C 循环**完整落到汇编**，并让你把每条汇编和它各自的\*\*编码格式（R/I/B/CB-Type 的字段）\*\*对上号。代码如下（课件约定：`X0=N，X1=sum，X2=I`，`X31`=零寄存器 XZR）：

```asm
ADD  X1, X31, X31     // sum = 0
ADD  X2, X31, X31     // I   = 0
B    TEST             // 先跳到条件检查

TOP:
ADD   X1, X1, X2    // sum += I
ADDI  X2, X2, #1    // I++

TEST:
SUBS  X31, X2, X0   // “比较 I 与 N”：SUBS XZR, X2, X0 只要标志
B.LT  TOP           // 若 I < N 则回到 TOP（继续循环）

END:
```

## 逐句解释（和执行逻辑）

1. `ADD X1, X31, X31`、`ADD X2, X31, X31`

* 把 `sum`、`I` 清零（用零寄存器相加得到 0）。
* **R-Type**：`Opcode | Rm | SHAMT=0 | Rn | Rd`。

2. `B TEST`

* 无条件跳到 `TEST` 处先做条件检查——等价 C 里的“先判后进循环”。
* **B-Type**：`Opcode(000101) | BrAddr26`（26 位相对位移，单位=4B）。

3. `ADD X1, X1, X2`

* 累加 `sum += I`。
* **R-Type**。

4. `ADDI X2, X2, #1`

* 自增 `I++`。
* **I-Type**：`Opcode | ALU_Imm12 | Rn | Rd`（这里 `imm12=1`）。

5. `SUBS X31, X2, X0`

* 本质做 `X2 - X0`，**只更新标志（NZCV）不保留结果**（因为写到 `XZR`）。
* 就是 `CMP X2, X0` 的等价形式。
* **R-Type（带 S）**：`Opcode(SUBS) | Rm=X0 | SHAMT=0 | Rn=X2 | Rd=XZR`。

6. `B.LT TOP`

* 读取上一步设置的 **N、V** 标志：若 `N ≠ V`（有符号小于），则跳回 `TOP`。
* **CB-Type / B.cond**：`Opcode(0x54) | imm19 | cond(LT)`；`imm19` 是到 `TOP` 的相对位移（单位=4B，可能为负数，因为“回跳”）。

> 这段流程就是：**初始化 → 条件检查 → 循环体 → 自增 → 再比较 → 条件回跳**。和你在上一页学到的“比较→条件分支”套路完全一致。

## 与“指令格式”一一对应（右侧空格的意义）

* 两条 `ADD`、一条 `SUBS`：**R-Type** 方框（会填 `Opcode/Rm/SHAMT/Rn/Rd`）。
* `ADDI`：**I-Type** 方框（会填 `Opcode/Imm12/Rn/Rd`）。
* `B TEST`：**B-Type** 方框（会填 `Opcode/BrAddr26`）。
* `B.LT TOP`：**CB-Type（B.cond）** 方框（会填 `Opcode/imm19/cond`）。

## 小抄

* `CMP a,b` ≡ `SUBS XZR, a, b`（只设标志）。
* B-Type/CB-Type 的**位移是相对 PC 且以“指令字”为单位**：
`PC_next = (PC_of_this + 4) + (imm << 2)`；向上回跳 ⇒ `imm` 为负。
* R-Type 的 `SHAMT` 对不带移位的算术应为 0；带移位（如 `LSL`) 则写移位量。

如果你愿意，我可以把这段汇编“假设起始地址”，替你**算出每条分支的具体位移**并画出它们 32 位机器码的每个字段。


---

## 第 30 页

![第 30 页](02_Assembly_assets/page-030.png)

这页是收尾：把“**汇编语言**”和“**机器语言**”放在一起对照，提醒你两者几乎一一对应，只是表现形式不同。

# 汇编（Assembly）

* **面向人**：用助记符（`ADD/LDUR/B.EQ`）、寄存器名（`X0`…）、标签（`LOOP:`）写程序。
* **抽象友好**：不用记具体地址和位字段；插删指令、改标签位置，**汇编器**会自动重算分支位移、生成常量池等。
* **几乎 1:1 到机器码**：RISC（如 AArch64）每条汇编通常对应一条 32 位指令。

# 机器语言（Machine Language）

* **面向硬件**：CPU 真正执行的**32 位二进制指令**。
* **结构固定**：由“操作码 + 操作数字段”拼成，比如

* **R-Type**：`Opcode | Rm | SHAMT | Rn | Rd`
* **I-Type**：`Opcode | Imm12 | Rn | Rd`
* **B/CB-Type**：`Opcode | 相对位移 |（条件/寄存器）`
* **PC 相对**：分支位移以“指令字”为单位（4 字节），回跳为负、向下为正。

# 从汇编到机器码：汇编器干了什么

1. **解析**助记符、寄存器、立即数、寻址形式（如 `[X1,#16]`）。
2. **两趟/多趟**解析**标签**：把 `B LOOP` 换算成相对位移字段。
3. **选定指令格式**并**填字段**：如 `ADD X0,X1,X2` → R-Type 里填 `Rd=0,Rn=1,Rm=2,SHAMT=0`。
4. （需要时）放入**常量池/重定位**信息，生成目标文件。
5. 链接器把多个目标文件合并，修正重定位，产出可执行文件；最终内存里看到的就是**纯机器码**。

# 一个迷你对照例子

| 汇编                 | 语义         | 编码思路                     |                             |           |        |        |
| ------------------ | ---------- | ------------------------ | --------------------------- | --------- | ------ | ------ |
| `ADD X3, X5, X6`   | `X3=X5+X6` | R-Type：\`Opcode(ADD,64)  | Rm=6                        | SHAMT=0   | Rn=5   | Rd=3\` |
| `ADDI X8, X3, #35` | `X8=X3+35` | I-Type：\`Opcode(ADDI,64) | Imm12=35                    | Rn=3      | Rd=8\` |        |
| `B LOOP`           | 跳到 `LOOP`  | B-Type：\`Opcode(B)       | BrAddr26=(LOOP-(PC+4))>>2\` |           |        |        |
| `B.LT END`         | 若 `<` 跳    | CB/B.cond：\`Opcode(0x54) | imm19                       | cond=LT\` |        |        |

# 反过来：反汇编

把内存里的 32 位机器码按这些格式拆回助记符与操作数，就是**反汇编**。这也是你在调试器/objdump 里看到的内容。

> takeaway：**汇编是“人类可读的机器码”**。理解了各类指令的字段布局，你就能在两者之间自如切换，看懂执行流程与编码细节。
