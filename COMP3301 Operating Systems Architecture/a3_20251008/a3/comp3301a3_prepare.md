

---

## 第 1 页

![第 1 页](comp3301a3_assets/page-001.png)

**提问：** 这张截图里的内容是什么意思？请面向初学者详细解释，分点讲清楚。

下面这页是\*\*《COMP3301——作业3》\*\*的封面和“学术诚信（Academic Integrity）”说明，面向初学者我分点解释一下：



# 这份作业概况



* **课程/作业**：COMP3301（2025学期）作业3，主题是\*\*“Mass Storage and File Systems – Cache Me If You Can”\*\*（文件系统与存储，标题是个双关：Cache↔Catch）。

* **截止时间**：第13周周一下午1点（标注为 **10月27日**）。

* **提交方式**：



  * 代码走 **Git 仓库**（你平时开发的那个 repo）。

  * 反思/说明走 **Blackboard**（学习平台上的提交入口）。

  * **批改**：第13周你的\*\*实验课（prac）\*\*上当场按你 Git 里的代码批改。

* **发布日期**：页脚写着最近一次更新为 **2025年10月6日**。



# 学术诚信要点（一定要看）



1. **个人独立完成**

   允许和同学聊概念、API、思路，但**不能**一起写代码、对方给你代码、或你给对方代码。

2. **禁止抄袭与串通**

   看别人的代码、让别人看你的代码、共享代码片段都算违规。课程会用**自动查重工具**比对代码。

3. **遇到困难找老师/助教**

   可以寻求教学团队帮助，不要向同学**要具体代码**或**给代码**。

4. **不要公开你的代码**

   不要把作业代码放公开仓库/公开帖子（私人帖可以）。假设有人拿到了延期，你公开代码就可能影响到他/她。

5. **遵守引用与来源规则**

   你仓库里**所有代码**（不仅是你提交的版本）都要符合来源与引用规范；违规会按不当行为处理。



# 代码来源与能否使用（表格速查）



| 代码来自哪里                                   | 能否使用    | 需要怎么做                                                                       |

| ---------------------------------------- | ------- | --------------------------------------------------------------------------- |

| **本学期教学团队提供的代码**（讲义/示例/老师在讨论区发的）         | ✅ 允许    | 可直接用。最好保留出处（被问及时能指出来源）。                                                     |

| **你自己本学期为本课写的代码**                        | ✅ 允许    | 可直接用，但前提是你**没对外分享/发布**这段代码。                                                 |

| **你以前写但没公开过的代码**（你在别的课或私下写的，且没被别人获得/没发布） | ⚠️ 条件允许 | **两点**：①你**理解**这段代码；②在代码**邻近位置**用注释**标注来源**（比如“我于2024-08在XX项目中编写”）。不标注就算违规。 |

| **来自 AI 工具生成的 C 代码**                     | ⚠️ 条件允许 | **必须标注**这是 AI 生成/改写，并确保你**完全理解**其含义与行为；否则可能被判不当使用。                          |



> 小白友好提示：\*\*“理解代码”\*\*不是嘴上说说。你要能在批改/问答时解释它做了什么、为什么这样写、复杂度/边界条件如何等。



# 正确引用示例（可直接照抄格式）



把引用**写在用到的那段代码上方**或文件头，例如：



```c

// Source: COMP3301 Week 7 lab example (teaching staff, 2025-09-15).

// Adapted by <你的名字> for Assignment 3.

```



或（你以前写的）：



```c

// Source: Personal project "kvstore" (written by me, 2024-08, never published).

// Reused and modified for COMP3301 Assignment 3. I confirm I understand this code.

```



或（AI 生成）：



```c

// Source: AI-assisted draft (generated on 2025-10-10, prompt summarized).

// Reviewed and modified by me; I understand the logic and verified edge cases.

```



# 常见踩坑与对策



* **把仓库设成公开** → ❌ 违规高风险。**务必私有**，不要把链接发给他人。

* **用到论坛里同学贴的代码** → ❌ 不行（除非是**老师/助教**发布的）。

* **“只看一下同学的实现思路/函数名”** → 也可能触发雷同。保持**思想交流**，但**不要看对方代码**。

* **AI 一键生成就提交** → 高风险。即便允许，也要**标注**并**亲自审查/测试/能讲清楚**。

* **忘记给“旧代码”加注释说明来源** → 可能被判不当引用。**就近写注释**最保险。



# 你现在可以做什么



1. **检查仓库权限**：设为 private。

2. **列个“来源清单”**：记录每个文件/函数是否来自自己、教学示例、旧代码或 AI。

3. **在代码里补注释**：参考上面的模板，贴在对应位置。

4. **自测与自述**：给每个关键模块准备 1–2 句“我能解释什么”的要点，避免被问住。

5. **提交路径**：代码推到 Git；反思写到 Blackboard；第13周实验课准备好演示/答疑。



如果你想，我也可以根据你现有代码帮你**逐段标注来源**并做一份\*\*“来源与修改说明”\*\*清单，减少合规风险。


---

## 第 2 页

![第 2 页](comp3301a3_assets/page-002.png)

**提问：** 这张截图里的内容是什么意思？请面向初学者详细解释，分点讲清楚。

这段话是 **Assignment 3 的“学术诚信”+“作业简介”** 部分，语气非常严肃，目的是告诉你：

> **哪些代码能用、哪些不能用、哪些必须引用、哪些绝对不能碰**；  
> 以及 **这个作业你到底要干什么**。

---

## ⚠️ 第一部分：AI、翻译工具、代码来源的规定（非常严格）

### ✅ 你可以用 AI/翻译工具，但：
- **不能依赖它们写代码**；
- **必须自己完全理解你提交的每一行代码**；
- **必须标注你用了 AI 或翻译工具**；
- **否则就是学术不端（misconduct）**，可能挂科甚至上报学校。

---

### 🚫 绝对禁止的代码来源（用了就算抄袭）：

| 禁止的代码来源     | 举例                                  | 后果                                                        |
| ------------------ | ------------------------------------- | ----------------------------------------------------------- |
| 网站/论坛          | Stack Overflow、CSDN、博客            | 没标注：学术不端；标注了：代码无效，可能编译不过，直接 0 分 |
| 公开/私有仓库      | GitHub、Gitee、学长 GitLab            | 同上                                                        |
| 教材/视频/APP      | 教科书、B站、YouTube、知乎            | 同上                                                        |
| 往年课程代码       | 以前老师给的、学长传的                | 同上                                                        |
| 别人写的           | 同学、朋友、网友、AI 不是你亲自交互的 | 同上                                                        |
| 你写但给别人用过的 | 你自己写的但发给别人看过              | 同上                                                        |

---

### ✅ 可以用的代码（但必须满足三个条件）：

| 条件            | 解释                          |
| --------------- | ----------------------------- |
| 1. 没有直接复制 | 你不能 copy-paste，必须自己写 |
| 2. 你真正理解   | 面试/答辩时能讲清楚每一行干嘛 |
| 3. 明确引用     | 在代码旁边写注释：参考了哪里  |

#### ✅ 举例：
```c
// 参考：man page of bufctl(9)
// 理解了 bufctl 是用于管理缓存控制块的
struct bufctl *bc;
```

---

## 🧪 第二部分：作业简介（Introduction）

### 📌 你要干什么？

> 在 **OpenBSD 内核**里，写一个 **块设备驱动**，支持 **FVD（Forkable Virtual Disk）** 格式。

#### ✅ 通俗解释：
- 你现在有 `vnd(4)`，它能把一个 **普通文件** 当成 **磁盘设备**（比如 `/dev/vnd0`）；
- 但这次你要支持的 **不是普通文件**，而是 **FVD 格式** 的虚拟磁盘；
- FVD 支持：
  - **按需分配空间**（写多少占多少）；
  - **快照/分支**（像 Git 一样分叉磁盘）；
  - **写时复制（COW）**；

---

### 🧩 你已经有什么？
- 老师给你一个 **“最小块设备模板”**（base code patch）；
- 你**不能抄**，但可以**在这个模板基础上扩展**；
- 你要**自己读 FVD 格式规范**，然后**实现驱动**。

---

### 📚 作业考察你什么？

| 知识点           | 来源            | 你要做的事         |
| ---------------- | --------------- | ------------------ |
| 块设备、文件系统 | 第 6、8、9 周课 | 理解块设备怎么工作 |
| 虚拟内存、COW    | 第 5 周课       | 实现写时复制、分支 |
| 文件格式规范     | FVD spec        | 自己读文档，写代码 |

---

## ✅ 总结一句话：

| 你不能                   | 你能                         |
| ------------------------ | ---------------------------- |
| 抄任何代码               | 自己写，参考但理解并引用     |
| 用 AI 写代码但不理解     | 用 AI 问概念，但自己写并标注 |
| 靠 GitHub/Stack Overflow | 看文档、问老师、自己调试     |

---

### 🎯 最终目标：

> 写一个 **能挂载、能读写、支持分支、支持按需分配** 的 **FVD 块设备驱动**，  
> 并且 **每一行代码你都能讲清楚它为什么在那里**。

---

如果你愿意，我可以帮你：
- 梳理 FVD 格式规范；
- 分析老师给的模板补丁；
- 一步步讲怎么开始写这个驱动。




---

## 第 3 页

![第 3 页](comp3301a3_assets/page-003.png)

**提问：** 这张截图里的内容是什么意思？请面向初学者详细解释，分点讲清楚。

这段文字是 **COMP3301 2025 年 Assignment 3** 的**背景介绍**，目的是让你理解：

> 你这次要在 **OpenBSD 内核**里实现一个**类似 vnd(4)** 的驱动，但支持的是 **FVD 格式的磁盘镜像**，而不是传统的“原始磁盘镜像”。

---

下面我**逐段翻译+详细解释**，让你真正看懂它在说什么。

---

### 🔧 背景（Background）

> 这个作业的目标是扩展 OpenBSD 内核，使其支持 **FVD 磁盘镜像**作为**块设备**（block device）。  
> 这类似于现有的 `vnd(4)` 驱动，它可以把一个**文件**当作**磁盘设备**来用。

#### ✅ 关键词解释：
- **块设备（block device）**：像硬盘、U盘那样，**按块（通常是512字节）读写**的设备。
- **FVD（Flexible Virtual Disk）**：一种**支持按需分配空间、支持快照/分支**的虚拟磁盘格式。
- **vnd(4)**：OpenBSD 的一个驱动，**把一个普通文件当成磁盘来用**。

---

### 📁 文件 vs 磁盘（Files vs Disks）

> 从高层看，**物理磁盘**就是一个**字节序列**，可以读、写、跳转到任意位置。  
> **文件**也差不多，也是一个字节序列，支持读、写、跳转。  
> 所以，操作系统可以把它们**抽象成一样的接口**，比如 `open/read/write/seek`。

#### ✅ 举个例子：
你可以用 `tar` 命令：
- 把文件打包成一个 `.tar` 文件（存在文件系统里）；
- 或者直接打包到 **磁盘设备**（比如 `/dev/sd0c`）里。

---

### 🧩 vnd(4) 驱动是干什么的？

> `vnd(4)` 是 OpenBSD 的一个驱动，它**把一个文件当成磁盘设备**来用。  
> 这样你就可以：
> - 用 `newfs` 在这个文件上建文件系统；
> - 用 `mount` 挂载它；
> - 像用真硬盘一样用它。

#### ❗ 但有个缺点：
> `vnd(4)` 只支持**原始磁盘镜像（raw disk image）**。  
> 也就是说，**虚拟磁盘有多大，文件就有多大**。

#### ✅ 举个例子：
- 你建了一个 **32GB 的虚拟磁盘**，那它的镜像文件就是 **32GB 大**；
- 即使你只存了 1MB 数据，**文件还是 32GB**；
- 这**浪费空间**，尤其是传镜像、备份、部署时。

---

### 💡 On-Demand Space Allocation（按需分配空间）

> 这是 FVD 的核心优势之一。  
> 虚拟磁盘**逻辑上可以是 32GB**，但**实际文件只存你写过的数据**。  
> 一开始可能只有几 MB（存元数据），你写 8GB 数据，文件就长到 8GB。

#### ✅ 类比：
- 就像 **Git 仓库**：你本地可能只检出部分历史，**不会把整个仓库都下载下来**；
- 或者像 **虚拟机快照**：只存**变化的部分**，而不是整个磁盘复制一份。

---

### 🌲 State Forking and Copy-on-Write（状态分叉 + 写时复制）

> FVD 支持**像 Git 一样分叉磁盘状态**。  
> 你可以：
> - 从一个基础镜像**分叉出多个分支**；
> - 每个分支**逻辑上独立**，但**共享未修改的数据**；
> - 只有**修改过的块**才会被复制（写时复制，Copy-on-Write）。

#### ✅ 举个例子：
- 你有一个基础镜像 `base.fvd`，装了 Ubuntu；
- 你可以分叉出：
  - `dev.fvd`（开发环境）
  - `test.fvd`（测试环境）
- 它们**共享基础数据**，但你在一台机器上装软件，**不会影响另一台**；
- **节省空间**，又**隔离状态**。

---

### ✅ 总结一句话：

| 功能             | vnd(4)       | FVD（你要做的）    |
| ---------------- | ------------ | ------------------ |
| 支持原始镜像     | ✅            | ✅                  |
| 支持按需分配空间 | ❌            | ✅                  |
| 支持快照/分支    | ❌            | ✅                  |
| 文件大小         | = 虚拟盘大小 | = 实际写入数据大小 |

---

### 🧠 你现在要做什么？

你要写一个 **内核驱动**，让 OpenBSD 可以：

- 打开一个 `.fvd` 文件；
- 把它**当成一个磁盘设备**（比如 `/dev/svnd0`）；
- 支持**按需分配空间**；
- 支持**多分支、写时复制**；
- 就像 `vnd(4)`，但更强大。

---

如果你愿意，我可以给你画个图，说明 FVD 是怎么把“虚拟扇区”映射到“文件中的记录”的，以及分支是怎么工作的。


---

## 第 4 页

![第 4 页](comp3301a3_assets/page-004.png)

**提问：** 这张截图里的内容是什么意思？请面向初学者详细解释，分点讲清楚。

好的！这页（第 4 页）在讲一种**可分叉的虚拟磁盘格式 FVD（Forkable Virtual Disk）**。它把“进程的 fork/写时复制（copy-on-write, COW）”的思想搬到了**磁盘镜像**上。给你分点、用大白话解释：



# 先把几个词讲清



* **虚拟磁盘镜像**：一个大文件，看起来像一块硬盘。操作系统把它当“磁盘”读写，但其实数据都在这个文件里。

* **扇区（sector）**：磁盘最小读写单位（常见 512B/4KB）。

* **记录（record）**：FVD 把镜像文件切成一块块**固定大小**的小段，就叫一个 record。数据就存放在这些 record 里。

* **写时复制（COW）**：多个“分支”共享同一份数据，只有当某个分支**要修改**那块数据时，才真的复制出一份新数据去改，其他分支继续用旧的；这样能**省空间**。

* **分叉（fork/branch）**：对当前磁盘状态拍一个“快照分支”。之后各分支可以独立演化、互不影响（像 Git 分支）。



# 这页的主旨



> **FVD 是一个支持“按需分配 + 写时复制 + 任意时刻分叉”的虚拟磁盘格式。**

> 这样做比传统的“整块原始镜像（raw/vnd）”更省空间、也更灵活。



# FVD 由两个文件组成



1. **`.fvd`（磁盘容器文件）**



   * 里面就是一条条**固定大小的 record**（记录）。

   * 记录里既可以放“数据块”，也可以放“元数据块”（比如索引/映射表）。

2. **`.fvd.ref`（引用计数文件）**



   * 每个字节对应 `.fvd` 里**同序号**的一个 record，存放它的**引用计数**（有多少分支在用这块）。

   * 有了引用计数，写时复制时就能判断“这块还能不能共享、是否需要复制、何时可以回收”。



# FVD 如何“按需用空间”



* FVD 用一张**块映射表（block map）**：把**虚拟磁盘里的每个扇区**映射到 `.fvd` 内**哪一个 record**。

* **还没写过**的扇区不会真的占用空间，统一映射到一个**特殊的 record 号 0**（表示“全是 0 的空数据”）。

* 只有当某个扇区**第一次被写入**时，FVD 才会给它**分配一个新的 record**来存真实数据——这就叫**按需分配**。



# FVD 如何“写时复制”



* 多个分支可以让它们的块映射都指向**同一份数据 record**（因此 `.fvd.ref` 里该 record 的计数会是 2、3、…）。

* 当某个分支要**修改**某扇区时：



  1. 发现这扇区对应的 record **被多个分支共享**（refcount > 1），

  2. 就**复制**出一个新的 record，先把旧内容拷过去，

  3. 在**当前分支**的块映射里把这个扇区改指向**新 record**，

  4. **再写入**修改后的数据，

  5. 旧 record 的引用计数减 1。

* 这样做的好处：**不动**其他分支，也**不浪费**空间。



# 图里的结构在说什么（从左到右）



* **Branch Descriptor Record（分支描述记录）**



  * 保存某个分支的基本信息，最重要的是一个**指向块映射（Block Map）的指针**。

* **Block Map（块映射）**



  * 一个“表”，把**扇区 0/1/2/…** 映射到 `.fvd` 里**具体哪个 Data Record**。

  * 也可能由\*\*多条“块映射记录”\*\*拼起来（因为映射表本身也可能很大）。

* **Data Record（数据记录）**



  * 真正存放扇区数据的记录们。

* **Root Record（根记录）**



  * 存放全局的**磁盘信息**，以及**指向各个分支描述**的指针。

  * 可以理解为“总目录”，能找到每个分支的入口。



> 小比喻：

>

> * **Root** 像 Git 的“refs”，记录有哪些分支；

> * **Branch Descriptor** 像分支的“HEAD/元信息”；

> * **Block Map** 像页表/索引，把“虚拟扇区号”翻译成“物理记录号”；

> * **Data Record** 就是实际的数据块；

> * **`.fvd.ref`** 像共享计数器，保证 COW 正确回收空间。



# 一个 60 秒小例子



1. 只有一个分支 `main`，很多扇区还没写 → 都映射到**record 0（空）**，几乎不占空间。

2. 你写了扇区 7，分配了一个新的 **record 42**，Block Map：`sector 7 → record 42`，`.fvd.ref[42]=1`。

3. 你从 `main` **fork** 出 `test`：两者的 Block Map 初始完全相同，`.fvd.ref[42]=2`（共享）。

4. 在 `test` 里修改扇区 7：因为共享，触发 **COW** → 复制到 **record 99**，`test` 的映射改为 `7→99`，写入；

   引用计数变化：`.fvd.ref[42]=1`，`.fvd.ref[99]=1`；`main` 仍然看到旧内容。



# 这和操作系统里的页表很像



* 文中把块映射和页表类比：**页表**把“虚拟页”映射到“物理帧”，

* **Block Map** 则把“虚拟扇区”映射到“.fvd 里的记录”。思想非常接近。



# 这页还说了什么



* FVD 的详细**规格说明书**（spec）可以在 Blackboard 或文末给的链接下载（就是你看到的蓝色超链接）。



---



如果你接下来要**实现/调试**相关代码，建议你先会回答这 5 个自检题：



1. “还没写过的扇区”在 FVD 里如何表示？为什么省空间？

2. fork 一个分支时，哪些结构需要复制？哪些只需要共享？

3. 写时复制发生在什么条件下？引用计数如何变化？

4. `.fvd` 和 `.fvd.ref` 分别存什么？它们如何一一对应？

5. Block Map 不够大时怎么存？（提示：映射表也由若干“记录”构成）



需要的话，我可以把这些概念做成一页速查卡或画个更简单的示意图，帮你记忆与答辩。


---

## 第 5 页

![第 5 页](comp3301a3_assets/page-005.png)

**提问：** 这张截图里的内容是什么意思？请面向初学者详细解释，分点讲清楚。

这页是“**第 5 页：Instructions（操作步骤）**”。它教你**在 OpenBSD 环境**里把课程提供的补丁打进内核源码、编译安装带 FVD 支持的新内核，并安装相关工具与设备节点。按顺序做就行。下面用新手友好方式逐步解释每一行在做什么：



---



# 前置小知识



* **doas**：OpenBSD 的提权命令，等价于 Linux 的 `sudo`（需要管理员权限的命令前都要加它）。

* **/usr/src**：系统源码目录（内核与用户态工具的源代码都在这）。

* **FVD**：Forkable Virtual Disk，作业要用到的虚拟磁盘驱动/工具。

* **(1)/(4)/(8)**：Unix 手册页分区。`fvdtool(1)`=用户态工具；`fvd(4)`=设备/驱动；`fvdctl(8)`=管理员命令。



---



# 一步步解释每条命令



## 1) 下载基础补丁



```sh

cd ~

ftp https://stluc.manta.uqcloud.net/comp3301/public/a3-base.patch

```



* 回到你的**家目录**，用 `ftp` 把**补丁文件**`a3-base.patch` 下载到本地（稍后喂给 git）。



## 2) 新建分支并应用补丁



```sh

cd /usr/src

git checkout -b a3 base

git am < ~/a3-base.patch

```



* 进入源码树。

* 以 `base` 分支为起点创建新分支 **a3**（保证作业修改都隔离在 a3 里）。

* `git am` 把补丁应用到当前分支（`am` 用于“邮件格式”的补丁，比 `git apply` 更保留提交信息）。



> 若 `git am` 报 “patch does not apply”，多半是你不在 `/usr/src` 或分支不对；回到步骤 2 重来。



## 3) 编译并安装**新内核**



```sh

cd /usr/src/sys/arch/amd64/compile/GENERIC.MP

make config

make -j4

doas make install

doas reboot

```



* 进入 **amd64** 的**多核**内核配置目录 `GENERIC.MP`。

* `make config` 生成当前配置对应的编译目录与文件。

* `make -j4` 并行编译（4 线程，可按机器调整）。

* `doas make install` 安装新内核到系统；然后 **重启** 让新内核生效。



## 4) 安装更新的头文件（includes）



```sh

cd /usr/src/include

doas make includes

```



* 把内核/系统相关**头文件**安装到 `/usr/include`，确保用户态工具用到的新接口能正确编译。



## 5) 编译并安装 `fvdctl(8)`（管理员控制工具）



```sh

cd /usr/src/usr.sbin/fvdctl

make obj

make

doas make install

```



* `make obj` 创建对象文件输出目录（OpenBSD 的标准做法）。

* 编译并安装到系统（通常是 `/usr/sbin/fvdctl`）。



## 6) 创建 `fvd(4)` 设备节点



```sh

doas cp /usr/src/etc/etc.amd64/MAKEDEV /dev

cd /dev

doas chmod 755 MAKEDEV

doas ./MAKEDEV fvd0 fvd1 fvd2 fvd3

```



* 把 `MAKEDEV` 工具拷到 `/dev` 并赋可执行权限。

* 用它生成 **/dev/fvd0\~fvd3** 这四个**设备文件**（用户态程序通过这些“节点”与内核驱动交互）。



## 7) 安装 `fvdtool(1)`（用户态工具）



```sh

curl https://stluc.manta.uqcloud.net/comp3301/public/fvdtool_install | doas sh -s --

```



* 下载安装脚本并**直接交给 shell 以管理员身份运行**，安装 `fvdtool`。

* 方便但有风险的一行式：只在你**信任课程源**的前提下使用。



---



# 完成后如何自检



* **确认新内核**：`uname -v`（或查看 `dmesg` 里是否加载了 fvd）。

* **确认设备节点**：`ls -l /dev/fvd*` 应看到 `fvd0`…`fvd3`。

* **确认工具就绪**：



  * `which fvdctl` 应该在 `/usr/sbin/fvdctl`

  * `which fvdtool` 一般在 `/usr/bin` 或 `/usr/local/bin`（视脚本而定）

* **手册页**：`man 4 fvd`、`man 8 fvdctl`、`man 1 fvdtool` 看用法说明。



---



# 常见坑与提示



* **忘记加 `doas` 导致权限失败**：报 “permission denied” 就在前面加上 `doas`。

* **`git am` 失败**：确认在 `/usr/src`、分支是 `a3`，补丁文件存在且完整。

* **`MAKEDEV` not found / 不可执行**：确保复制到 `/dev` 并 `chmod 755`。

* **内核没更新**：`make install` 后必须 `reboot` 才会跑新内核。

* **`curl | sh` 的安全性**：仅对可信课堂链接这么做；否则应先下载、打开脚本检查后再执行。



---



**一句话总结**：你在做的是——**把作业补丁打到系统源码 → 编译安装带 FVD 的新内核 → 安装 FVD 的管理员工具和用户工具 → 创建设备节点**。完成这些后，你就具备了运行/测试 FVD 的环境。需要的话我可以陪你一起跑一遍，并在每步出错时定位原因。


---

## 第 6 页

![第 6 页](comp3301a3_assets/page-006.png)

**提问：** 这张截图里的内容是什么意思？请面向初学者详细解释，分点讲清楚。

这页（第 6 页）开始进入**作业要做的功能**，重点是给 OpenBSD 的 **fvd(4)** 虚拟块设备加上对 **FVD 磁盘镜像**的支持，并实现若干 **ioctl** 控制指令。下面按新手视角分点解释：



---



## 1）这章在说什么？



* 你要在内核里把 **FVD 镜像**当作 **fvd(4)** 设备的“后端磁盘”来用。

* 课程已经给了**样板代码**（设备入口函数都搭好了），你主要补全：



  * **读/写**逻辑（read/write）

  * 本章列出的若干 **ioctl**（用户态控制接口）



> 类比：把一个 `.fvd` 文件“接到”一个虚拟硬盘 `/dev/fvd0` 后面，然后让系统能对它正常读写，还能通过 ioctl 做“附加/卸载/查询信息”等管理操作。



---



## 2）这些 ioctl 应该对哪个设备起作用？



* 只对 **字符设备**的**原始分区 c** 生效，也就是像：`/dev/rfvd0c`、`/dev/rfvd1c` 这样的设备节点。



  * 前缀 **`r`** 表示 **raw character device**（字符设备，原始 I/O）。

  * **`c` 分区**是“整盘”的原始分区。

* **例外**：`FVDIOC_ATTACH`（附加）在还没附加之前也要能用；**其他 ioctl** 要求设备**已经附加**到了某个 FVD 镜像才行。



---



## 3）“附加/卸载/信息”这一节（5.1）的目标



在使用 `.fvd` 镜像前，必须先把镜像“**附加**”到一个 `fvd(4)` 设备上（比如 `rfvd0c`）。

你需要实现的就是 **`FVDIOC_ATTACH`**。



### `FVDIOC_ATTACH` 要做什么？



它从用户态接收一个结构体参数，告诉内核：



* 要附加**哪个镜像文件**；

* 用镜像里的**哪个分支（branch）**；

* 以**只读**还是**可写**方式附加。



结构体长这样（文档已给出）：



```c

struct fvd_attach {

    const char *fa_path;     /* FVD 镜像路径（容器文件） */

    const char *fa_branch;   /* 要附加的分支名；空串=默认分支 */

    int         fa_readonly; /* 0=可写，非0=只读 */

};

```



* **`fa_path`**：`.fvd` **容器文件**的路径（磁盘数据就装在这个文件里；配套的 `.fvd.ref` 是引用计数文件）。

* **`fa_branch`**：镜像内部的**分支名字**；传空串表示附到**默认分支**。

* **`fa_readonly`**：是否**只读**附加。传 0 表示想要可写；非 0 表示只读。



  * 注意：如果你对镜像文件**没有写权限**，驱动只能**强制只读**附加。



### 失败时要返回什么错误？



* 如果 `fa_path` 指向的**不是合法的 FVD 镜像**（需要检查镜像的 **Root Record**、目标分支的 **Branch Descriptor Record** 等），这个 ioctl 要用合适的 **`errno(2)`** 返回错误（例如 `EINVAL`/`EIO` 等，视你的实现而定）。

* 如果 **分支不存在**，应返回 **`ESRCH`**。



> 小结：**验证镜像** → **验证目标分支** → **根据权限确定 ro/rw** → **把镜像挂到设备的“软状态”里** → 成功返回 0；否则返回相应 errno。



---



## 4）卸载（detach）



* 文档说明：**`FVDIOC_DETACH` 已经替你实现好了**，这里列出只是为了文档完整性。

* 含义：把已附加的镜像从 `rfvdXc` 上卸下来，设备回到未附加状态。



---



## 5）给初学者的实现思路（内核侧伪流程）



1. **copyin 参数**：从用户态把 `struct fvd_attach` 复制到内核缓冲区，并安全读取两条字符串（路径/分支名）。

2. **解析并打开镜像**：



   * 以 `fa_readonly ? FREAD : (FREAD|FWRITE)` 打开 `.fvd` 容器；

   * 如果无写权限但请求了可写，**降级为只读**；

   * 查找并打开对应的 `.fvd.ref`（只读或读写与容器保持一致）。

3. **校验镜像格式**：读取 **Root Record**，检查签名/版本/布局；

4. **定位分支**：按 `fa_branch` 找到 **Branch Descriptor Record**；找不到就返回 `ESRCH`；

5. **建立设备状态**：



   * 在 `softc`（设备软状态）里记录：打开的 vnode、只读标志、目标分支的块映射入口等；

   * 标记设备为**已附加**；必要时刷新容量/标签信息。

6. **错误处理与清理**：任何一步失败都要关闭已打开的 vnode，释放内存，并返回合适的 `errno`。



---



## 6）怎么在用户态用它（理解即可）



* 管理工具通常会对 **`/dev/rfvd0c`** 发出 `FVDIOC_ATTACH`：



  * 传入 `{fa_path="/path/to/disk.fvd", fa_branch="main", fa_readonly=0}`

  * 成功后，这块虚拟盘就“接上了”镜像。

* 卸载就发 **`FVDIOC_DETACH`**。

* 其他 ioctl（例如查询信息）和读/写在后续小节会讲。



---



## 7）容易混淆的点



* **为什么是 `/dev/rfvdXc` 而不是 `/dev/fvdX`？**

  ioctl 只在**字符设备的原始分区**上受理；这是 BSD 系的一贯做法（管理操作走 raw char 设备）。

* **只读/可写谁说了算？**

  既看 `fa_readonly`，也看**文件权限**；没有写权限只能只读附加。

* **“不是合法 FVD”怎么判断？**

  需要检查镜像里的**元数据记录**（Root Record、分支描述等），而不是只看文件扩展名。



---



**一句话总结**

这页要求你：在内核的 `fvd(4)` 驱动里实现一个 **`FVDIOC_ATTACH`** ioctl，把一个 `.fvd` 镜像（指定分支、指定读写模式）**安全地附加**到 `rfvdXc` 设备上；如果镜像不合法或分支不存在，要返回恰当的 `errno`。`DETACH` 已给好，你重点把 **参数校验、权限处理、元数据检查、设备状态建立**这几步写扎实。


---

## 第 7 页

![第 7 页](comp3301a3_assets/page-007.png)

**提问：** 这张截图里的内容是什么意思？请面向初学者详细解释，分点讲清楚。

下面这页（第 7 页）继续讲**作业要实现/会用到的 ioctl 与读写函数**。我把它拆成三块，用新手能看懂的方式说明：



# A. 卸载镜像：`FVDIOC_DETACH`



作用：把当前挂在 `fvd(4)` 设备上的 **FVD 镜像**卸下，并关闭后端文件（`.fvd` 与 `.fvd.ref`）。



* **参数**：一个整型，作为布尔值使用——



  * `0`：正常卸载；

  * 非 `0`：**强制卸载**（force detach）。

* **何时会失败**



  * `EBUSY`：**设备正在使用**（比如还有打开的文件/正在 I/O），且你没有传“强制”。

  * `ENXIO`：**根本没附加**任何 FVD 镜像。

* **绿色提示（超重要）**



  * 这个 ioctl **课程已帮你实现**。但：如果你在“attach”时**自己额外分配了资源**（缓存、结构体等），记得在“detach”时**一并释放**。

  * 真正关闭 `.fvd` / `.fvd.ref` 文件以及做统一清理的地方在 **`fvd_leave()`**，**不是** `fvd_detach()` / `fvd_close()`。



# B. 查询信息：`FVDIOC_INFO`



作用：把**当前已附加的镜像路径**与**分支名**返回给用户态。



* **输出结构体**（驱动往里写）：



  ```c

  struct fvd_info {

      char fi_path[1024];          /* 镜像路径（.fvd 容器文件） */

      char fi_branch[FVD_MAX_BNM]; /* 当前分支名 */

  };

  ```

* **字段含义**



  * `fi_path`：等同于当初 `FVDIOC_ATTACH` 传入的 `fa_path`。只需要写入前 **1023** 个字符，且以 **NUL 结尾**。

  * `fi_branch`：当前附加的分支名；如果挂的是**默认分支**，可能是**空串**或默认分支的真实名字（同样要求 **NUL 结尾**）。

* **成功/失败**



  * **应该总是成功**，只要设备**确实已附加**了某个 FVD 镜像；

  * 若没附加则返回 **`ENXIO`**。



> 小技巧：写字符串时一定保证 **NUL 结尾**，防止用户态读取越界；用 `strlcpy` 这类安全函数最省心。



# C. 虚拟磁盘 I/O：实现 `fvd_read_sect()` 与 `fvd_write_sect()`



你需要实现两个内核函数，支持对“当前分支”的**按扇区读/写**：



```c

static int

fvd_read_sect(struct fvd_softc *sc, uint32_t sec, void *buf);



static int

fvd_write_sect(...);   /* 原型在文档后半页，语义与 read 对称 */

```



* **访问入口**：用户态通过设备节点 `/dev/{,r}fvdX` 读写；

  其中 **`/dev/rfvdXc`**（`X` 是设备号）代表**整块虚拟盘**的“原始视图”，就像对一个普通文件那样顺序读写。

* **你在函数里要做的事（高层步骤）**



  1. **校验状态**：设备是否已附加？`sec` 是否在容量范围内？（越界返回错误）

  2. **定位映射**（Block Map 思想，前文第 4 页讲过）：



     * 找到扇区 `sec` 对应的 **record**（记录号）。
    
     * 若记录号为 **0**（表示“从未写过/全 0”）：



       * 读：把 `buf` **清零**后返回；
    
       * 写：需要**按需分配新 record**（见下一步）。

  3. **读路径（read）**：



     * 计算要读的 record 内偏移（取决于“每个 record 含多少扇区”和“扇区大小”——看 FVD 规格）。
    
     * 从 `.fvd` 文件把该位置的数据拷到 `buf`。

  4. **写路径（write）**：



     * 如果该 record **被多个分支共享**（引用计数 `>1`），先**写时复制（COW）**：



       * 分配新 record → 拷贝旧数据 → 更新**当前分支**的映射 → 调整 `.fvd.ref` 计数；
    
     * 如果是“从未写过”（记录号 `0`），则**按需分配**一个新 record，并更新映射与引用计数；
    
     * 计算偏移，把 `buf` 写入 `.fvd` 对应位置。

  5. **返回值**：`0` 表示成功；错误时返回合适的 `errno`（如 I/O 出错、越界等）。

* **实现小贴士**



  * **字符串/内存安全**：对用户态传入/传出的结构体使用 `copyin/copyout`；对内核分配的缓冲及时 `free`。

  * **引用计数同步**：写路径涉及 `.fvd.ref` 的增减，要保证一致性；必要时加锁保护。

  * **零扇区优化**：读到“未写过”的扇区直接 `memset(buf, 0, sector_size)`，不必访问磁盘。

  * **对齐与边界**：确认 `sec` 到 record 的换算公式（`record_size / sector_size`），避免跨 record 时的计算错误。

  * **错误传播**：底层 vnode I/O 失败要把错误码向上传递，不要吞掉。



---



## 一句话回顾



* `DETACH`：卸载镜像（支持强制），注意资源清理在 `fvd_leave()`。

* `INFO`：把**镜像路径**和**分支名**回传给用户态（NUL 结尾）。

* `读/写函数`：基于块映射与引用计数，实现**零扇区返回全 0、按需分配、写时复制**等核心逻辑。



如果你愿意，我可以根据你们给的头文件和样板代码，帮你把 `fvd_read_sect`/`fvd_write_sect` 的**伪代码**细化成“逐行待办清单”，方便你直接对照实现与自测。


---

## 第 8 页

![第 8 页](comp3301a3_assets/page-008.png)

**提问：** 这张截图里的内容是什么意思？请面向初学者详细解释，分点讲清楚。

下面这页（第 8 页）延续上一页，讲两件事：

① 把**按扇区读写**真正落地（尤其是“第一次写入”和“写时复制 COW”）；

② 实现**分支 fork 的 ioctl**。



---



# 5.2 虚拟磁盘 I/O：`fvd_read_sect` / `fvd_write_sect`



页首给出了写函数原型：



```c

fvd_write_sect(struct fvd_softc *sc, uint32_t sec, const void *buf);

```



* **sc**：设备“软状态”，里面放着当前已附加镜像的句柄、只读标记、块映射入口等。

* **sec**：要读/写的**扇区号**。

* **buf**：读/写的数据缓冲区地址。

* **返回值**：成功返回 `0`，失败返回一个 `errno(2)` 错误码。



核心行为（新手要点）：



* **第一次写这个扇区**（即它还没真正分配到某个 record）：

  → 必须**分配一个新 record**，更新块映射，把这个扇区指到新 record，然后再写入。

* **扇区当前映射到“被多个分支共享”的 record**（refcount > 1）：

  → 触发 **COW**：分配新 record → 先把旧内容拷过去 → 仅在**当前分支**的映射里改指向新 record → 再把 `buf` 写进去；同时更新 `.fvd.ref` 的引用计数。

* **读/写容器文件与引用计数文件**：可用 **`vn_rdwr()`** 做底层文件 I/O（绿色提示框）。



自测预期（实现正确后能做什么）：



1. 用 **`fdisk(8)`** 做 GPT；

   > 1. GPT 是 **GUID Partition Table** 的缩写，是一种 **现代磁盘分区表格式**，用来替代老旧的 **MBR（Master Boot Record）** 分区表。

2. 用 **`disklabel(8)`** 划分 BSD 分区；

3. 用 **`newfs(8)`** 在分区上建文件系统；

4. 用 **`mount(8)`/`umount(8)`** 挂载/卸载；

   （附录 Appendix 1 有示例命令与输出。）



> 简化伪流程（写）：检查已附加与只读→计算 sec 所在 record → 未分配则 alloc；共享则 COW → 用 `vn_rdwr()` 按偏移写 `.fvd` → 维护块映射与 `.fvd.ref` → 返回 0/错误码。



---



# 5.3 虚拟磁盘状态 Fork：`FVDIOC_FORK`



这是 FVD 相对 raw 镜像的“杀手锏”——**随时从当前分支 fork 出一个新分支**，而且**立刻切换**到新分支上工作。



* **语义**：新分支一开始与旧分支内容**完全一样**；之后的读写都只影响**新分支**。

* **ioctl 结构体参数**：



  ```c

  struct fvd_fork {

      char ff_name[FVD_MAX_BNM]; /* 新分支名，NUL 结尾 */

      int  ff_force;             /* 是否强制 fork（即使磁盘在用/挂载中） */

  };

  ```



  * **ff\_name**：新分支的名字。

  * **ff\_force**：非 0 表示强制 fork（即便当前有文件系统在用）。

* **失败条件**：如果名字**为空**或**已存在**，返回 **`EEXIST`**。



> 实现要点（思路）：检查名称合法性→判断是否在用（决定是否需要 `ff_force`）→创建新分支的**分支描述记录**与**块映射起点**（最初共享旧分支的数据，引用计数+1）→在设备状态中把“当前分支”切到新分支。



---



## 一句话总结



* 写扇区：**未分配就分配**，**共享就 COW**，底层 I/O 用 `vn_rdwr()`，维护好块映射与 `.fvd.ref`。

* `FVDIOC_FORK`：从当前分支**克隆**出新分支并**马上切换**过去；名字必须唯一，必要时可**强制** fork。


---

## 第 9 页

![第 9 页](comp3301a3_assets/page-009.png)

**提问：** 这张截图里的内容是什么意思？请面向初学者详细解释，分点讲清楚。

这页（第 9 页）分两部分：

A) **继续说明 FVD 分支 fork 的细节与出错条件**；

B) **让你实现“按扇区缓存 + LRU 置换”**，并配了一个 LRU 小例子。下面用新手能懂的方式展开。



---



# A. Fork 继续说明（与上一页的 FVDIOC\_FORK 接口配套）



* **如果磁盘“正在使用”而且你没开 `ff_force`**（参数为 0），**就返回 `EBUSY`**，不执行 fork。

  目的：防止在父分支上已经挂了文件系统时“热分叉”带来损坏。

* **Fork 不会复制数据块（record）**：采用**写时复制（COW）**。



  * 刚 fork 完，父子分支**指向同一批 record**；

  * 谁先修改哪个扇区，谁就**为那个扇区分配新 record** 并改映射；

  * 被父子共享的 record，其**引用计数要 +1**。



---



# B. 5.4 扇区缓存 & 替换（你需要实现）



> 目标：给每个 `fvd(4)` 设备做一个**小型扇区缓存**，减少磁盘 I/O，提高性能。



## 你要做的规则



* **缓存对象**：只缓存**虚拟磁盘的“扇区内容”**（sector data）。



  > *注：不是缓存 FVD 的元数据 record——如果你愿意，也可以额外做一套。*

* **缓存容量**：每个设备**16 个扇区**（也就是 16×扇区大小，通常 16×512B=8KiB）。



  > 现实里会缓存更多；作业要求小容量，便于测评。**请把实现写成可配置**，以后改大小不费劲。

* **读缓存策略**：



  * 第一次读某扇区：把数据读入缓存；

  * 后续再读同一扇区：**直接命中缓存**，不去访问 `.fvd` 文件。

* **写缓存策略（写回 / write-back）**：



  * 第一次写某扇区：**只写到缓存**并把条目标**记为“脏（dirty）”**，**不立刻写磁盘**；

  * 后续对同一扇区的读写都命中缓存；

  * 当该条目被\*\*淘汰（evict）\*\*时，**如果是脏的，就把它写回到 `.fvd`**，然后再丢掉。

* **替换算法**：使用 **LRU（Least Recently Used，最近最少使用）**。



  * 被访问过的条目越“新”，越不该被淘汰；

  * 缓存满时，淘汰**最久没被用**的那个。



## 简单的实现建议（数据结构）



* **哈希表（或红黑树）**：`sector → 缓存条目`，O(1) 定位命中与否。

* **双向链表**维护 LRU 顺序：



  * 命中一个条目：移动到**链表头**（代表“最新”）；

  * 插入新条目：放到链表头；

  * 淘汰：从**链表尾**拿走“最老的”条目；若 dirty → 先写回。

* **缓存条目结构**（示例字段）：



  * `sector`、`data[SECTOR_SIZE]`、`valid`、`dirty`、`lru_prev/next`。



## 与 FVD 的配合（关键点）



* **第一次写该扇区**且它在 FVD 里还没分配 record：



  * 仍然按“写缓存”记 dirty；

  * **在真正写回时**（或显式 flush 时），才执行**按需分配** / **COW** / **更新块映射与引用计数**。

  * 这样可以把“分配 + 写回”合并，减少 I/O。

* **读到“未写过（record=0）”的扇区**：放入缓存一条**全 0** 的条目即可。

* **只读设备**：写入请求直接返回 `EROFS`，或你可以让缓存不接受写（看你驱动上层判定）。



## 刷新（可选但实用）



* 提供一个**flush** 路径（在 `DETACH`、`CLOSE` 或显式 ioctl 时调用）：把缓存里所有 **dirty** 条目写回，再清空。避免数据丢失。



---



# LRU 图示例（文档里的小例子解释）



* **缓存大小**：4

* **访问序列**：`0x3301 → 0x3010 → 0x4011 → 0xBEEF → 0xDEAD → 0x4011 → 0x1234`（示例分多步画，截图到“访问 0xDEAD 前”）



1. 访问 `0x3301`：缓存变为 `[3301]`（左=最新，右=最旧）。

2. 依次访问 `0x3010、0x4011、0xBEEF`：缓存满，顺序变为

   `最新 [BEEF, 4011, 3010, 3301] 最旧`。

3. 访问 `0xDEAD`：缓存已满，要**淘汰最旧的 `0x3301`**；插入 `0xDEAD` 后为

   `最新 [DEAD, BEEF, 4011, 3010] 最旧`。



   > 若被淘汰的条目是 **dirty**，此刻要**写回**到 `.fvd` 文件。



（后续访问会继续移动条目位置或触发淘汰，思路同上。）



---



## 新手开发清单（照着做不容易错）



1. 在 `softc` 里加上**缓存结构**与**锁**。

2. 实现 `cache_lookup(sec)` / `cache_insert(sec)` / `cache_evict()` / `cache_mark_dirty()` / `cache_flush()`。

3. 在 `fvd_read_sect`：



   * 命中→拷贝缓存；

   * 未命中→从 `.fvd` 读入（或全 0），插入缓存并返回。

4. 在 `fvd_write_sect`：



   * 只读→报错；

   * 命中→写入缓存并 `dirty=1`、移动到 LRU 头；

   * 未命中→若满则 `evict()`（脏则写回），再插入新条目并标 `dirty=1`。

5. 在写回路径里，按需触发 **分配/COW/更新映射与 `.fvd.ref`**，最后用 `vn_rdwr()` 把数据落盘。

6. 在 **DETACH/关闭** 时 `cache_flush()`，确保数据不丢。



---



**一句话总结**：这一页让你把**fork 的安全性与 COW 语义**补完，同时实现一个**16 扇区、写回型、LRU 置换**的扇区缓存。命中不 I/O，淘汰脏块才写回，并在写回时与 FVD 的**分配/COW/引用计数**机制正确衔接。


---

## 第 10 页

![第 10 页](comp3301a3_assets/page-010.png)

**提问：** 这张截图里的内容是什么意思？请面向初学者详细解释，分点讲清楚。

这页（第 10 页）在两件事上“收尾并落地”：



1. 用\*\*LRU（最近最少使用）\*\*把上一页的缓存示例继续走完；

2. 给你一个**测试缓存实现**用的 ioctl：`FVDIOC_CACHE_LIST`（并预告下一个 `FVDIOC_CACHE_EMPTY`）。



---



# A. 把 LRU 例子走完（你要看懂“淘汰+写回”的节奏）



缓存大小=4，访问序列继续：



1. **访问 0xDEAD**



   * 缓存已满，淘汰**最久未用**的 `0x3301`；

   * 如果 `0x3301` 是 **dirty**，**先写回**到 `.fvd` 文件再丢；

   * 插入 `0xDEAD`，此时 LRU 顺序（左=最新，右=最旧）：

     `〔DEAD, BEEF, 4011, 3010〕`



2. **再次访问 0x4011**



   * 命中，不增删；

   * 但 `0x4011` 变成**最新**，移动到队头：

     `〔4011, DEAD, BEEF, 3010〕`



3. **访问 0x1234**



   * 满了，要淘汰**最旧**的 `0x3010`；若它是 dirty，先**写回**；

   * 插入 `0x1234` 后：

     `〔1234, 4011, DEAD, BEEF〕`



> 读写规则回顾：

>

> * **读**命中直接读；未命中从 `.fvd` 读入并放入缓存。

> * **写**采用**写回（write-back）**：先写缓存并标记 **dirty**，只有被淘汰或显式 flush 时才落盘。



---



# B. 为测试而实现的 ioctl：`FVDIOC_CACHE_LIST`



目的：**方便助教/你自己**查看缓存里有哪些扇区、哪些是脏的、数据校验是否一致，从而验证你的**LRU 与写回**实现是否正确。



### 结构体（驱动向用户态“填充输出”）



```c

struct fvd_cache_list {

    size_t         fc_nsects;        /* 当前缓存中扇区的数量 */

    struct sec_info fc_sects[16];    /* 扇区信息（最多 16 个） */

};



struct sec_info {

    uint32_t si_number;   /* 扇区号 */

    uint32_t si_checksum; /* 该扇区数据的校验和 */

    int      si_dirty;    /* 是否已被修改（脏） */

};

```



### 字段含义（新手要点）



* **`fc_nsects`**：当前缓存里**有效条目数**（≤ 16）。

* **`fc_sects`**：装每个缓存条目的三元信息：



  * `si_number`：扇区号；

  * `si_checksum`：对该条目**数据内容**调用 **`fvd_csum_sect()`** 的结果（课程给的辅助函数）；

  * `si_dirty`：1=脏，0=干净。



  > **顺序不要求**按 LRU 排，但**只需要填前 `fc_nsects` 个元素**，剩下的可以不写。

* **失败条件**：如果设备**没有附加**任何 FVD 镜像，返回 **`ENXIO`**；否则**应总是成功**。



### 实现小贴士



* 进入 ioctl 处理分支后：



  1. 检查设备是否**已附加**（否则 `ENXIO`）。

  2. 加锁保护缓存结构，遍历你的缓存条目，逐项填 `si_number/si_dirty`；

  3. 计算 `si_checksum = fvd_csum_sect(entry->data)`；

  4. 设置 `fc_nsects`，再 `copyout()` 给用户态。

* 注意 **N ≤ 16**：超过就截断（但你的缓存本来就只有 16 个扇区）。

* 不必暴露内部 LRU 链表，只需把“里头都存了谁、是否脏、校验和”告诉外部即可。



---



# C. 接下来要做什么？



* 这页底部出现了 **`FVDIOC_CACHE_EMPTY`** 的标题——下一页会要求你实现**清空缓存/写回**的 ioctl，用来配合测试写回逻辑（把所有 dirty 条目落盘并清空）。



---



## 常见坑 & 自检清单



* **忘了 ENXIO**：未附加时 `FVDIOC_CACHE_LIST` 必须失败。

* **校验和算错**：一定要对**缓存里的实际数据**调用 `fvd_csum_sect()`。

* **数组越界/未填满**：只填前 `fc_nsects` 个；`fc_nsects` 必须等于你缓存中**实际条目数**。

* **并发问题**：遍历缓存期间要**加锁**，避免与读写并发冲突。

* **脏块没写回**：在 LRU 淘汰和（下一页的）`CACHE_EMPTY`/detach/close 时，脏块一定要落盘。



**一句话总结**：这页把 LRU 示例跑完，告诉你如何通过 `FVDIOC_CACHE_LIST` 把“缓存里有什么、哪些是脏的、校验和是多少”暴露给用户态，方便检验你的**LRU+写回**实现是否正确。


---

## 第 11 页

![第 11 页](comp3301a3_assets/page-011.png)

**提问：** 这张截图里的内容是什么意思？请面向初学者详细解释，分点讲清楚。

> ⚠️ 未能复制为 Markdown，以下为纯文本回退：

# Review Problem 1

### A) 清空缓存的 ioctl：FVDIOC_CACHE_EMPTY
- **作用**：把扇区缓存中所有条目移除；对脏条目（dirty）先写回 `.fvd` 文件，再清空缓存。
- **参数**：无（不带参数的 ioctl）。
- **返回值/错误**：
  - 如果写回任一脏条目失败，返回合适的 errno(3)（具体错误码由你在写回路径里决定，如 EIO）。
  - 其它情况应当成功。
- **何时会触发**：
  - **fork 时**：文档要求把所有脏扇区先冲刷（flush）。你可以选择不清空（flush 后继续留在缓存），但允许清空。
  - **detach 时**：必须把缓存清空（并确保脏数据已写回）。
- **实现提示**：
  - 遍历缓存 → 对每个 dirty 调用你的“写回到 FVD”的函数（其中做按需分配/COW/更新映射+.fvd.ref）→ 清理条目 → 维护 LRU 结构与计数。

### B) 反思题（Reflection）
**场景**：虚拟用户 Puffy 不小心把最重要镜像的引用计数文件（`.fvd.ref`）删了，镜像无法使用；于是提 Feature：
- 把记录（records）和 refcount 都存进同一个 `.fvd` 文件；
- 觉得块映射（block map）太占空间，希望缩小。

你需要结合本课内容，简短论述下面四个问题（2 页内，无标准答案，重在思考）：
1. **只剩 `.fvd` 文件能否恢复数据？为什么？**
   - 提示：块映射在 `.fvd` 里；`.fvd.ref` 只有引用计数。读取内容可能还能做（至少只读），但写/COW/回收等需要 refcount；若驱动强制要求 `.fvd.ref` 才挂载会失败。可讨论扫描重建最小 refcount（把被映射到的 records 先当作 refcount=1），但无法区分“孤儿记录”、一致性与可靠性弱。

2. **把 refcount 元数据放进 `.fvd` 用“连续分配（contiguous allocation）”合适吗？**
   - 可从优点（顺序 I/O 快、实现简单）与缺点（镜像增长时难扩展、可能要搬迁元数据、空间预留/碎片管理麻烦）分析。

3. **如果用“链式分配（linked allocation）”存 refcount，有什么缺点？**
   - 随机访问慢（要走链表）、指针开销、局部性差导致 I/O 多、链损坏风险高（坏一处断全链），不适合频繁随机更新的计数。

4. **如何缩小 block map 的体积？至少给一个思路，并说明一个缺点。**
   - 例如：
     - **区间映射/运行长度（extents/RLE）**：把连续 sectors→同一 record 的范围合并；缺点：随机小写会把区间打碎、更新复杂。
     - **分层表/更大粒度（像多级页表或更大“页”）**；缺点：查找多一次跳转、大粒度造成内部碎片。
     - **稀疏+压缩（只存非零映射并压缩）**；缺点：CPU 开销、更新时可能需要重写较大块。

### C) 提供的工具/文件 —— fvdctl(8)
补丁里包含了管理工具 `fvdctl(8)` 的源码，它会调用你上面实现的 ioctl 来控制 `fvd(4)` 设备。
类似 `vnconfig(8)` 的用法。
打完补丁后源码位置：`src/usr.sbin/fvdctl/`。

### 小抄：你在本页需要完成/会被测的点
- **FVDIOC_CACHE_EMPTY**：flush 所有 dirty→清空缓存→错误处理到位。
- **fork**：确保在切分支前先 flush 脏缓存（可选是否清空）。detach 时必须清空。
- **反思题**：围绕可恢复性、元数据布局（连续/链式）和块映射缩减给出利弊分析与你自己的取舍理由。


---

## 第 1 页

![第 1 页](comp3301a3_assets/page-012.png)

**提问：** 这张截图里的内容是什么意思？请面向初学者详细解释，分点讲清楚。

这张截图是关于一个名为 `fvdctl` 的命令行工具的说明，它的主要用途是管理FVD（虚拟磁盘）镜像和与之相关的节点。`fvdctl` 命令用于控制FVD映像文件的挂载、卸载、信息查看和分支管理等操作。



让我们详细解释其中每个子命令的作用：



### 1. **`fvdctl attach`**



* **作用**：将FVD镜像文件（例如 `image.fvd`）附加到一个FVD设备节点（如 `fvd0`）上。

* **常用参数**：



  * `-D`：将 `fvdX` 参数视为设备特殊文件的路径，而不是FVD节点的名称。

  * `-r`：以只读方式挂载FVD镜像。

  * `fvdX`：指定要附加的FVD设备节点，例如 `fvd0` 或 `fvd1`。

  * `image.fvd`：指定要挂载的FVD镜像文件的路径。

  * `branch`：指定要挂载的分支（如果不提供，默认为当前分支）。



**使用示例**：

`fvdctl attach fvd0 image.fvd` 将 `image.fvd` 镜像附加到 `fvd0` 节点。



### 2. **`fvdctl detach`**



* **作用**：将FVD镜像从FVD设备节点上卸载。

* **常用参数**：



  * `-D`：将 `fvdX` 参数视为设备特殊文件路径，而非FVD节点名称。

  * `-f`：强制卸载虚拟磁盘，即使它当前正在使用中。

  * `fvdX`：指定要卸载的FVD设备节点，例如 `fvd0` 或 `fvd1`。



**使用示例**：

`fvdctl detach fvd0` 将卸载 `fvd0` 节点上的FVD镜像。



### 3. **`fvdctl info`**



* **作用**：打印出FVD镜像附加到FVD设备节点的路径和分支信息。

* **常用参数**：



  * `-D`：将 `fvdX` 参数视为设备特殊文件路径，而非FVD节点名称。

  * `fvdX`：指定要查看信息的FVD设备节点，例如 `fvd0` 或 `fvd1`。



**使用示例**：

`fvdctl info fvd0` 会显示 `fvd0` 节点的镜像路径和分支信息。



### 4. **`fvdctl fork`**



* **作用**：将当前的FVD镜像分支“分叉”，并切换到新的分支。

* **常用参数**：



  * `-D`：将 `fvdX` 参数视为设备特殊文件路径，而非FVD节点名称。

  * `fvdX`：指定要分叉的FVD设备节点，例如 `fvd0` 或 `fvd1`。

  * `name`：为新的分支指定一个名称。



**使用示例**：

`fvdctl fork fvd0 new_branch` 会从 `fvd0` 创建一个新的分支，并立即切换到 `new_branch`。



### 总结：



这些命令是用来管理虚拟磁盘（FVD镜像）和它们与设备节点（如 `fvd0`）之间的关系。每个命令都有不同的子命令，支持不同的操作，例如挂载、卸载、查看信息以及分支管理。


---

## 第 2 页

![第 2 页](comp3301a3_assets/page-013.png)

你提供的这段内容，看起来是某个**操作系统或虚拟磁盘系统（FVD, Floppy Virtual Disk）**的**命令行工具说明文档**，类似于 `man` 页面（manual page），解释了两个命令：

---

## 🧰 1. `fvdctl` 命令

这是一个**控制虚拟磁盘设备**的工具，类似于 Linux 的 `ioctl` 或 `fdisk`。

### 子命令：`fvdctl fork`

用于**分叉（fork）**一个虚拟磁盘分支（branch），可以理解为创建一个**新的版本或快照**。

#### 命令格式：
```bash
fvdctl fork [-D] [-f] fvdX name
```

#### 参数解释：

| 参数   | 含义                                                         |
| ------ | ------------------------------------------------------------ |
| `-D`   | 把 `fvdX` 当作**设备文件路径**（如 `/dev/fvd0`），而不是默认的节点名（如 `fvdo`）。 |
| `-f`   | **强制分叉**，即使该分支正在被使用（通常默认不允许）。       |
| `fvdX` | 虚拟磁盘节点名，如 `fvdo`、`fvd1`。                          |
| `name` | 新分支的名字，分叉后你会得到一个名为 `name` 的新分支。       |

---

### 子命令：`fvdctl io`

用于**对虚拟磁盘进行读写操作**，支持交互或脚本方式。

#### 命令格式：
```bash
fvdctl io [-D] fvdX [script]
```

#### 参数解释：

| 参数     | 含义                                                         |
| -------- | ------------------------------------------------------------ |
| `-D`     | 同上，把 `fvdX` 当作设备文件路径。                           |
| `fvdX`   | 虚拟磁盘节点名。                                             |
| `script` | 可选，脚本文件路径。如果不提供，就从标准输入（stdin）读取命令。 |

#### 脚本支持的命令（每行一个命令）：

| 命令                | 含义                                                     |
| ------------------- | -------------------------------------------------------- |
| `r <sector>`        | **读取**指定扇区（sector），并打印校验和（checksum）。   |
| `w <sector> <char>` | **写入**指定扇区，用某个字符填满整个扇区，并打印校验和。 |
| `e`                 | **清空**扇区缓存（cache）。                              |
| `l`                 | **列出**当前缓存中的扇区。                               |
| `q`                 | **退出**脚本模式。                                       |
| `#`                 | 注释行（以 `#` 开头的行会被忽略）。                      |

---

## 🛠️ 2. `fvdtool` 命令

这是一个**FVD 镜像文件管理工具**，类似于 `qemu-img` 或 `VBoxManage`，用于创建、查看、导出、操作虚拟磁盘镜像。

### 功能包括：
- 创建空的或基于原始镜像的 FVD 镜像
- 显示 FVD 镜像信息
- 导出 FVD 分支为原始镜像
- 分叉 FVD 镜像的任意分支
- 读写 FVD 镜像的扇区

---

### 子命令：`fvdtool create`

用于**创建一个新的 FVD 镜像文件**。

#### 命令格式：
```bash
fvdtool create [选项] <大小>
```

（你提供的文本中只提到了它“接受指定大小作为参数”，没有给出完整语法，但通常类似：）
```bash
fvdtool create -s 100M mydisk.fvd
```

---

## 🧠 总结一句话：

你看到的这段文档是**FVD（虚拟软盘）系统**的命令行工具说明，类似于：

- `fvdctl` 是**运行时控制工具**，用于**分叉分支**或**读写扇区**；
- `fvdtool` 是**镜像管理工具**，用于**创建、导出、操作磁盘镜像**。

---

## 🧩 举个例子帮助理解：

假设你有一个虚拟磁盘 `fvdo`，你想：

1. **创建一个新分支**叫 `backup`：
   ```bash
   fvdctl fork fvdo backup
   ```

2. **强制分叉**（即使它正在被使用）：
   ```bash
   fvdctl fork -f fvdo backup
   ```

3. **读取第100个扇区**：
   ```bash
   fvdctl io fvdo
   # 然后输入：
   r 100
   ```

4. **创建一个100MB的虚拟磁盘镜像**：
   ```bash
   fvdtool create -s 100M mydisk.fvd
   ```

---

如果你是在某个操作系统课程、虚拟化实验或操作系统项目中看到这段内容，那么它很可能是一个**教学用的虚拟磁盘系统**，用来模拟磁盘操作、快照、分支管理等高级功能。


---

## 第 3 页

![第 3 页](comp3301a3_assets/page-014.png)

**提问：** 这张截图里的内容是什么意思？请面向初学者详细解释，分点讲清楚。

这张截图继续介绍了 `fvdtool` 工具的使用，特别是关于如何创建、导出、分叉和读取FVD镜像的命令。以下是对这些命令的详细解释：



### 1. **`fvdtool create`**



`fvdtool create` 命令用于创建一个新的FVD镜像。它有一些可选的参数：



* **`-s C,H,S`**：指定虚拟磁盘镜像的几何结构，包含柱面（Cylinder）、磁头（Head）和扇区（Sector）的数目，格式为 `C,H,S`。这是磁盘的物理结构参数。

* **`-r raw_img`**：从一个原始镜像（raw image）创建FVD镜像，`raw_img` 是原始镜像的路径。

* **`fvd_img`**：这是要创建的FVD镜像的名称。



**命令示例**：



```bash
fvdtool create -s 1024,16,63 -r my_raw_image.img my_fvd_image.fvd

```



这条命令从 `my_raw_image.img` 创建一个名为 `my_fvd_image.fvd` 的FVD镜像，并且设置几何结构为 `1024` 个柱面、`16` 个磁头和 `63` 个扇区。



### 2. **`fvdtool info`**



`fvdtool info` 命令用于显示FVD镜像的详细信息，并绘制分支树：



* **`fvd_img`**：这是要显示信息的FVD镜像的名称。



**命令示例**：



```bash
fvdtool info my_fvd_image.fvd

```



这条命令会显示 `my_fvd_image.fvd` 镜像的详细信息，并绘制出该镜像的分支树。



### 3. **`fvdtool export`**



`fvdtool export` 命令用于将FVD镜像导出为原始镜像（raw image）。



* **`-b branch`**：指定要导出的分支，默认为当前分支。

* **`fvd_img`**：输入的FVD镜像。

* **`raw_img`**：输出的原始镜像。



**命令示例**：



```bash
fvdtool export -b default my_fvd_image.fvd my_raw_image.img

```



这条命令将 `my_fvd_image.fvd` 镜像中的 `default` 分支导出为 `my_raw_image.img` 的原始镜像。



### 4. **`fvdtool fork`**



`fvdtool fork` 命令用于创建一个新的FVD镜像分支：



* **`-b branch`**：指定要分叉的分支，默认为当前分支。

* **`fvd_img`**：要进行分叉操作的FVD镜像。

* **`new_brcn`**：新创建的分支名称。



**命令示例**：



```bash
fvdtool fork -b default my_fvd_image.fvd new_branch

```



这条命令将 `my_fvd_image.fvd` 镜像的 `default` 分支分叉成一个新的分支 `new_branch`。



### 5. **`fvdtool read`**



`fvdtool read` 命令用于读取FVD镜像中特定分支的一定数量的扇区：



* **`-b branch`**：指定要读取的分支，默认为当前分支。

* **`fvd_img`**：指定要读取的FVD镜像。

* **`sec`**：指定要读取的起始扇区。

* **`seccnt`**：指定要读取的扇区数。

* **`out_file`**：指定读取数据后保存的输出文件路径。



**命令示例**：



```bash
fvdtool read -b new_branch my_fvd_image.fvd 0 10 output.txt

```



这条命令将从 `my_fvd_image.fvd` 镜像的 `new_branch` 分支读取从第 0 个扇区开始的 10 个扇区，并将结果保存到 `output.txt` 文件中。



### 总结



这部分内容介绍了如何使用 `fvdtool` 命令来：



* **创建** 一个新的FVD镜像（可从原始镜像创建，并设置磁盘几何结构）。

* **查看** FVD镜像的详细信息和分支结构。

* **导出** FVD镜像到原始镜像格式。

* **分叉** FVD镜像的分支（创建一个新的分支）。

* **读取** 特定分支的扇区数据。



这些命令对于管理和操作虚拟磁盘镜像非常有用，特别是在处理不同版本、分支和数据恢复时。


---

## 第 4 页

![第 4 页](comp3301a3_assets/page-015.png)

**提问：** 这张截图里的内容是什么意思？请面向初学者详细解释，分点讲清楚。

这张截图包含了与 `fvdtool` 命令和编程作业的要求有关的部分内容。我们可以分为两大块来解释：一部分是关于 `fvdtool write` 命令的详细说明，另一部分是关于作业的代码要求。



### 1. **`fvdtool write` 命令**



这是用来将数据写入FVD镜像的命令。命令的格式如下：



* **`-b branch`**：指定要写入的分支，默认是当前分支（如果没有指定）。

* **`fvd_img`**：指定要写入数据的FVD镜像。

* **`sec`**：指定开始写入的扇区（sector）。

* **`in_file`**：指定包含要写入数据的输入文件。如果没有提供，默认从标准输入（stdin）读取数据。



**写入规则**：



* 如果提供的文件数据大小不是扇区大小的整数倍，数据会用零填充（NUL padding），直到达到下一个扇区边界。



**命令示例**：



```bash
fvdtool write -b default my_fvd_image.fvd 0 input_data.txt

```



该命令将 `input_data.txt` 文件的内容写入到 `my_fvd_image.fvd` 镜像的 `default` 分支，从第 0 个扇区开始。如果文件数据不是扇区大小的整数倍，它会被填充到下一个扇区边界。



### 2. **作业代码要求**



这部分要求关于如何编写和提交代码的一些具体要求，主要分为以下几个方面：



#### 7.1 **Code Style（代码风格）**



* **要求**：你的代码需要遵循 **OpenBSD** 的代码风格指南（参考 `style(9)` 手册页）。在提交时，会使用一个自动化工具来检查代码是否符合这些风格规范。

* **自动化检查工具**：提供了一个在线工具，用于检查是否存在代码风格的违规。链接地址是：[https://stluc.manta.uqcloud.net/comp3301/public/cstyle.pl](https://stluc.manta.uqcloud.net/comp3301/public/cstyle.pl)

* **评分标准**：评分会根据代码中你自己写的部分的风格违规数量来计算。如果你修改了OpenBSD源码树中的风格违规部分，这些将被计入。如果代码没有符合风格要求，将扣除代码风格分数。



#### 7.2 **Reliability, Robustness, Portability, and Modularity（可靠性、健壮性、可移植性和模块化）**



* **要求**：代码应该是可靠的、健壮的，能正确处理所有错误，并避免出现崩溃。

* **可移植性**：代码应该具有良好的可移植性，意味着你不能硬编码常量，避免类似代码在不同地方的重复。

* **模块化**：代码应该是模块化的，即各个功能应该分开，避免冗余代码。并且代码应该是无竞争条件（race conditions）和未定义行为的。



#### 7.3 **Compilation (Pass/Fail)（编译要求）**



* **要求**：代码必须能在 `GENERIC.MP` 配置下进行编译，这种配置适用于 **AMD64** 架构（即 x86-64 和 x64）。

* **编译失败**：如果代码包含编译错误，那么作业将被标记为失败。



### 总结：



* **`fvdtool write`** 命令允许你将数据写入到FVD镜像中的特定扇区，可以指定输入文件或通过标准输入读取数据。

* 在作业的**代码要求**部分，强调了编写符合OpenBSD风格的代码，确保代码的可靠性、健壮性、可移植性和模块化设计，并且代码需要能在指定的硬件配置下编译通过。如果不满足这些要求，可能会影响评分或导致作业失败。


---

## 第 5 页

![第 5 页](comp3301a3_assets/page-016.png)

**提问：** 这张截图里的内容是什么意思？请面向初学者详细解释，分点讲清楚。

这张截图提供了关于如何提交作业以及评分和演示要求的详细说明。主要涉及 Git 提交和作业演示部分。以下是每个部分的详细解释：



### 1. **Git 提交要求**



你需要通过 Git 提交作业到课程提供的 Git 仓库。具体的要求包括：



* **提交的方式**：所有代码必须提交到你在 `source.eait.uq.edu.au` 上的 Git 仓库。确保你提交的代码是推送到 `a3` 分支。如果代码提交到了其他分支，或者代码没有推送到 `a3` 分支（例如，只保存在你的虚拟机上），那么该部分作业将不会被评估。



* **提交的内容**：



    1. **OpenBSD 基础提交**（由课程提供）。

    2. **A3 基础补丁提交**（由课程提供）。

    3. **你自己编写的代码**：这部分代码包含实现所要求功能的部分。



* **其他注意事项**：



  * 遵循 `source.eait.uq.edu.au` 上的使用指南，**仅提交源代码和 makefile**。不要提交像 `cscope` 输出、核心转储文件或基础代码补丁文件等内容。

  * **提交历史和提交信息**不会影响评分，但建议你经常提交，并使用适当的提交信息，清楚描述你每次提交的内容。



### 2. **评分要求**



作业的评分将由课程工作人员在你实际课程（practical session）周的**面对面演示**中进行。具体的要求如下：



* **面对面演示**：你必须亲自参加演示，否则作业将不会被评分。**线上演示**（如通过 Zoom）是不允许的。



* **评分标准**：



  * 演示将在一个**评分虚拟机**（不是你的虚拟机）上进行，该虚拟机仅包含你推送到 `a3` 分支的最新代码。

  * 演示中会进行**手动和自动化测试**，并对代码进行检查。你提交的代码必须能够正确编译并运行，代码崩溃或无法编译会导致作业不被评分。



### 3. **演示要求**



在演示时，你将展示你的作业。具体要求如下：



* **演示虚拟机**：演示将在**评分虚拟机**上进行，这个虚拟机只会运行你已经提交的代码。确保你已经将所有代码推送到 `a3` 分支。



* **演示期间**：在演示过程中你不可以修改代码。如果你在演示时对代码进行了修改，这些修改将不被接受。



* **责任**：你需要确保你的代码能够编译并正常运行。任何编译失败或代码导致内核崩溃的问题都会导致作业无法评分。



* **答辩环节**：你可能需要解释你作业的某些方面，问题一般都是开放性问题，没有单一正确答案。如果你未能展示你对代码的理解，或者对代码的理解不正确，可能会导致学术不端的指控，即使你的代码是正确的。



### 总结：



* **Git 提交**：确保代码提交到正确的 `a3` 分支，并包含指定的基础提交和你编写的代码。

* **评分**：作业的评分依赖于你在实际课程中的面对面演示，线上提交不会被接受。

* **演示要求**：演示将在一个评分虚拟机上进行，演示前确保代码能够正确编译并运行。






---

## 第 17 页

![第 17 页](comp3301a3_assets/page-017.png)

**提问：** 这张截图里的内容是什么意思？请面向初学者详细解释，分点讲清楚。

这页（第 17 页）是**建议与测试指南**。面向初学者我分三块讲清楚👇



---



## 9.1 备份（Backups）



* **强烈建议频繁用 Git 备份**：内核调试/崩溃很容易把虚拟机文件系统弄坏；没备份就只能从头来。



  * 小步提交：`git add -A && git commit -m "step: attach works"`

  * 推到远端：`git push origin a3`（推到课程仓库的 **a3** 分支）

* **给虚拟机做快照**：在开始写代码或完成一个里程碑后，**VM Control** 里执行 `snapshot <name>`。



  * 好处：一键回到“干净状态”（比如“能顺利启动的新内核”）。



---



## 9.2 相关手册页（Relevant Manual Pages）



这些 **man 手册**对理解/实现作业很有帮助（并不是都必须看）。每条给你一句话用途与对本作业的价值：



* **`vnd(4)`**（vnode 磁盘驱动）：与本作业的 `fvd(4)` 类似的**虚拟磁盘设备**，看它的结构与 ioctl 设计有参考意义。

* **`vnode(9)`**：内核中文件对象 **vnode** 的概念与使用。

* **`VNSUBR(9)`**：对 vnode I/O 的**高级便捷函数**（如 `vn_rdwr()`），你会用它对 `.fvd`/`.fvd.ref` 读写。

* **`VOP_LOOKUP(9)`**：vnode 层**路径查找/打开**相关操作，理解文件访问路径。

* **`vfs(9)`**：内核**虚拟文件系统接口**的总览，帮助你把“设备”和“文件系统工具链”串起来。

* **`ioctl(2)`**：ioctl 的**用法与错误码**，实现 `FVDIOC_*` 时要遵守的行为。

* **`MAKEDEV(8)`**：**创建设备节点**；你要用它生成 `/dev/fvd0` 等设备文件。

* **`malloc(9)`**：内核**内存分配**接口（分配你的缓存条目、映射结构等）。

* **`queue(3)`**：内核里常用的**链表/队列宏**总览。

* **`TAILQ_INIT(3)`**：双向队列（TAILQ）宏；**实现 LRU** 很好用。

* **`RB_PROTOTYPE(3)`**：红黑树宏；可用于**按扇区快速查找**缓存条目/映射。

* **`KASSERT(9)`**：**内核断言**；在开发阶段快速发现不变量被破坏。

* **`rwlock(9)`**：读写锁；保护**缓存/映射**这类读多写少的数据结构。



*用法提示：* 终端里直接 `man 9 vnode`、`man 4 vnd`、`man 9 VNSUBR` 即可。



---



## 9.3 测试（Testing）



* **先 `sync` 再测**：运行任何测试前执行 `sync`，把缓存内容写盘，内核一旦崩溃就不容易把宿主文件系统搞坏。

* **课程会给公共测试（public tests）**：它们只覆盖**最基础功能**，全过也**不代表万无一失**。

* **自己再补充测试**（强烈建议），给你一份最小自测清单：



  1. **Attach/Info/Detach 基线**：



     * 附加不存在的镜像应报错；`info` 显示路径/分支；`detach` 后再次 `info` 应 `ENXIO`。

  2. **读未写过扇区**：应返回**全 0**；重复读应命中缓存、无底层 I/O。

  3. **基本读写回环**：`write → read → 校验和一致`。

  4. **只读附加**：任何写都报 `EROFS`；`read` 正常。

  5. **LRU 行为**：构造 16+N 扇区的访问序列，验证**最久未用**被淘汰；结合 `CACHE_LIST` 查看 `dirty` 标记。

  6. **写回策略**：写多个扇区但不 `e`/不淘汰，确认**不会立刻落盘**；触发淘汰或 `CACHE_EMPTY` 后才写回。

  7. **Fork 语义**：



     * `fork` 后父/子分支读取同一扇区应相同；
    
     * 在子分支写某扇区后，**父分支不变**（验证 **COW**）；
    
     * 父分支忙时 `fork` 无 `-f` 应 `EBUSY`，加 `-f` 成功。

  8. **Detach/关闭清理**：确保**脏缓存被 flush**、资源释放无泄漏（可配合 `KASSERT`/统计计数）。

  9. **边界条件**：越界扇区、极端小/大镜像、分支名为空或重复（`EEXIST`）、`.fvd.ref` 缺失等。



*工具组合建议：*



* 离线镜像检查：`fvdtool info/read/write/fork/export`；

* 在线设备测试：`fvdctl attach/info/fork/io/detach` + 系统工具 `fdisk/disklabel/newfs/mount`；

* 观察日志：`dmesg`、在关键路径加 `KASSERT` 与有限的 `printf`（注意性能与噪声）。



---



**一句话总结**：这页提醒你**常备份、会看 man、要自测**。用 Git + VM 快照兜底；按列表翻手册精准查接口；在课程公共测试之外，自己把 **读/写/缓存/LRU/COW/fork/错误码/清理** 全都跑一遍，才是拿到稳定分数的关键。


---

## 第 18 页

![第 18 页](comp3301a3_assets/page-018.png)

**提问：** 这张截图里的内容是什么意思？请面向初学者详细解释，分点讲清楚。

这页（第 18 页）教你**安装并使用公共测试套件 a3test**，用来本地自测你的作业实现。给你按新手视角分点说明👇



---



# 一、安装公共测试（24 个 public tests）



在你的 **VM** 里运行这几条命令：



```sh

cd ~

ftp https://stluc.manta.uqcloud.net/comp3301/public/a3_public_tests.tar

tar -xvf a3_public_tests.tar

cd a3test

./install

```



* 会安装测试程序 **`a3test`** 和 **24 个公共测试**。



---



# 二、a3test 的用法总览



命令格式：



```sh

a3test <public|custom|all> <run|info|dump> <all|name,name2...>

```



含义：



* 第 1 个参数：**要在哪类测试里找**



  * `public`：只找**公共测试**（安装包带的那 24 个）

  * `custom`：只找你**自己写的自定义测试**

  * `all`：两者都找

* 第 2 个参数：**对选中的测试做什么**



  * `run`：运行测试

  * `info`：显示测试信息（做什么、前置条件等）

  * `dump`：把**你的程序输出**（stdout/stderr）和**测试期望输出**都**导出**到当前目录（方便你用 `diff(1)` / `sdiff(1)` 对比）

* 第 3 个参数：**选择哪些测试**



  * `all`：选择所有

  * 逗号分隔的**编号列表**：如 `1.5,3.2,4.1`



---



# 三、示例命令（文档中的三个场景）



## 1) 运行测试



```sh

# 跑全部测试

a3test all run all



# 只跑某个测试（例如 3.2）

a3test all run 3.2



# 跑一组指定测试

a3test all run 1.5,3.2,4.1

```



## 2) 查看测试信息（不执行）



```sh

# 所有测试的说明

a3test all info all



# 单个测试说明（例如 1.6）

a3test all info 1.6



# 多个测试说明

a3test all info 1.3,2.1,3.1

```



## 3) 导出实际/期望输出（便于 diff）



```sh

# 导出全部测试的输出

a3test all dump all



# 导出某个测试（如 1.4）

a3test all dump 1.4



# 导出一组测试

a3test all dump 1.1,4.1,5.1

```



> 导出后，你可以在当前目录用 `diff` 或 `sdiff -w 160 <expected> <actual>` 对比差异。



---



# 四、实用小贴士



* **先 `sync` 再测**（上一页建议）：降低内核崩溃导致 FS 损坏的风险。

* **公共测试只覆盖基础功能**：全过≠万无一失；请再写自己的**custom**测试补充边界情况（缓存 LRU、COW、只读、错误码等）。

* **定位失败用 dump**：先 `a3test all dump <编号>`，再用 `sdiff` 看哪一行不一致。

* **选小集反复调试**：先锁定失败用例单独 `run`，修好后再跑全量。



> 说明：通过与未通过的示例（含截图）在 Ed 的 **A3 Tests** 帖子里也有展示。


---

## 第 19 页

![第 19 页](comp3301a3_assets/page-019.png)

**提问：** 这张截图里的内容是什么意思？请面向初学者详细解释，分点讲清楚。

这页（第 19 页）有两部分：**规范澄清**和**文件系统示例（附录）**。给你用新手能懂的话分点说明👇



---



## 10 Specification Clarifications（规范澄清）



* 以后如果作业说明有**更新/更正**，会通过 **Blackboard** 或 **Ed** 公告。

* 有疑问请去 Ed 的 **A3 Spec Clarification Megathread** 统一提问，不要给老师单独发邮件/单独开贴。

* 自文档首次发布以来的所有澄清，**在 PDF 里会用红色标出**。



---



## 11 Appendix 1：Filesystem Example（如何在 FVD 上玩文件系统）



> 黄色提示：这是**示例**，让你了解流程；具体输出（时间戳/大小等）不必一模一样。



下面的终端记录展示了**从创建 FVD → 挂到设备 → 建 GPT → 用 disklabel 划分 OpenBSD 分区**的流程。



1. **创建 1GB 的 FVD 镜像**



```sh

fvdtool create -s 514,16,255 1gb.fvd

```



* `-s 514,16,255` 指定 CHS（柱面/磁头/扇区），总扇区数=514×16×255≈2097120（约 1 GiB）。

* 工具会生成两个文件：`1gb.fvd`（容器）和 `1gb.fvd.ref`（引用计数）。



2. **看看文件是否生成**



```sh

ls -l 1gb.fvd

```



* 能看到 `1gb.fvd` 存在；`.fvd.ref` 也会在同目录。



3. **把镜像附加到 fvd0 设备**



```sh

doas fvdctl attach fvd0 1gb.fvd

```



* 让 `/dev/fvd0`（对应原始字符设备 `/dev/rfvd0c`）指向这份 FVD 镜像的默认分支。



4. **用 fdisk 写入 GPT 分区表**



```sh

doas fdisk -g fvd0

# 提示 "Write new GPT? [n]" 输入 y

```



* `-g` 创建/写入 **GPT**（GUID 分区表）。

* 接着 `doas fdisk fvd0` 可查看可用 LBA 范围与一个默认的 **OpenBSD** GPT 分区条目：



  ```

  Usable LBA: 34 to 2097086

  0: OpenBSD [ start:64 size:2097023 ]

  ```



5. **用 disklabel 在 OpenBSD 分区内再细分（BSD 分区）**



```sh

doas disklabel -eD fvd0

```



* 进入交互式编辑器（`p` 查看当前布局）。

* 看到 `c:` 是整盘占位（BSD 传统，**不要改**）；目前可用区域都**空闲**。

* 输入 `a` 新建一个 **a 分区**：



  * `offset: [64]` → 从 64 扇区开始（紧跟 GPT 之后）；

  * `size: [2097023]` → 占满可用空间；

  * `FS type: [4.2BSD]` → 选择 **FFS**（OpenBSD 的 4.2BSD 文件系统类型）。



> 到这里：磁盘有了 GPT（外层）+ disklabel（内层）+ 一个 a 分区。**下一步通常是格式化并挂载**：

> `doas newfs /dev/rfvd0a` → `doas mount /dev/fvd0a /mnt`（这些命令通常在后续附录/页面继续示例）。



---



### 你需要记住的要点



* **fvdtool** 负责**离线**创建/查看镜像；**fvdctl** 负责把镜像**挂到设备**供系统使用。

* **fdisk** 管 GPT（外层分区表）；**disklabel** 管 OpenBSD 的 BSD 分区（内层）。

* `c:` 分区是“整盘视图”，**不要动**；实际用的是你新建的 `a:`。

* 只有完成 **newfs → mount** 后，才能像普通磁盘那样读写文件树。

* 任何一步失败，先检查是否**已 attach**、路径是否正确，以及是否**用 doas 提权**。


---

## 第 20 页

![第 20 页](comp3301a3_assets/page-020.png)

**提问：** 这张截图里的内容是什么意思？请面向初学者详细解释，分点讲清楚。

这页（第 19 页）有两部分：**规范澄清**和**文件系统示例（附录）**。给你用新手能懂的话分点说明👇



---



## 10 Specification Clarifications（规范澄清）



* 以后如果作业说明有**更新/更正**，会通过 **Blackboard** 或 **Ed** 公告。

* 有疑问请去 Ed 的 **A3 Spec Clarification Megathread** 统一提问，不要给老师单独发邮件/单独开贴。

* 自文档首次发布以来的所有澄清，**在 PDF 里会用红色标出**。



---



## 11 Appendix 1：Filesystem Example（如何在 FVD 上玩文件系统）



> 黄色提示：这是**示例**，让你了解流程；具体输出（时间戳/大小等）不必一模一样。



下面的终端记录展示了**从创建 FVD → 挂到设备 → 建 GPT → 用 disklabel 划分 OpenBSD 分区**的流程。



1. **创建 1GB 的 FVD 镜像**



```sh

fvdtool create -s 514,16,255 1gb.fvd

```



* `-s 514,16,255` 指定 CHS（柱面/磁头/扇区），总扇区数=514×16×255≈2097120（约 1 GiB）。

* 工具会生成两个文件：`1gb.fvd`（容器）和 `1gb.fvd.ref`（引用计数）。



2. **看看文件是否生成**



```sh

ls -l 1gb.fvd

```



* 能看到 `1gb.fvd` 存在；`.fvd.ref` 也会在同目录。



3. **把镜像附加到 fvd0 设备**



```sh

doas fvdctl attach fvd0 1gb.fvd

```



* 让 `/dev/fvd0`（对应原始字符设备 `/dev/rfvd0c`）指向这份 FVD 镜像的默认分支。



4. **用 fdisk 写入 GPT 分区表**



```sh

doas fdisk -g fvd0

# 提示 "Write new GPT? [n]" 输入 y

```



* `-g` 创建/写入 **GPT**（GUID 分区表）。

* 接着 `doas fdisk fvd0` 可查看可用 LBA 范围与一个默认的 **OpenBSD** GPT 分区条目：



  ```

  Usable LBA: 34 to 2097086

  0: OpenBSD [ start:64 size:2097023 ]

  ```



5. **用 disklabel 在 OpenBSD 分区内再细分（BSD 分区）**



```sh

doas disklabel -eD fvd0

```



* 进入交互式编辑器（`p` 查看当前布局）。

* 看到 `c:` 是整盘占位（BSD 传统，**不要改**）；目前可用区域都**空闲**。

* 输入 `a` 新建一个 **a 分区**：



  * `offset: [64]` → 从 64 扇区开始（紧跟 GPT 之后）；

  * `size: [2097023]` → 占满可用空间；

  * `FS type: [4.2BSD]` → 选择 **FFS**（OpenBSD 的 4.2BSD 文件系统类型）。



> 到这里：磁盘有了 GPT（外层）+ disklabel（内层）+ 一个 a 分区。**下一步通常是格式化并挂载**：

> `doas newfs /dev/rfvd0a` → `doas mount /dev/fvd0a /mnt`（这些命令通常在后续附录/页面继续示例）。



---



### 你需要记住的要点



* **fvdtool** 负责**离线**创建/查看镜像；**fvdctl** 负责把镜像**挂到设备**供系统使用。

* **fdisk** 管 GPT（外层分区表）；**disklabel** 管 OpenBSD 的 BSD 分区（内层）。

* `c:` 分区是“整盘视图”，**不要动**；实际用的是你新建的 `a:`。

* 只有完成 **newfs → mount** 后，才能像普通磁盘那样读写文件树。

* 任何一步失败，先检查是否**已 attach**、路径是否正确，以及是否**用 doas 提权**。


---

## 第 21 页

![第 21 页](comp3301a3_assets/page-021.png)

**提问：** 这张截图里的内容是什么意思？请面向初学者详细解释，分点讲清楚。

这两页（第 20–21 页）是**附录示例的下半段**：把 FVD 盘做成文件系统、往里写真实数据，然后卸载与分离。每一步在验证你实现的**读写/按需分配/缓存落盘**是否工作。按顺序解释：



# 发生了什么（命令逐条看）



1. **查看 disklabel 结果**



   * `doas disklabel fvd0`：打印 fvd0 的几何与分区表。

   * 关键行：`bytes/sector: 512`、`total sectors: 2097120`、分区：



     * `a:` 从 **64** 扇区开始，大小 **2096992** 扇区，类型 **4.2BSD**（用于文件系统）。
    
     * `c:` 整盘（只读“全盘视图”）。



2. **在 a 分区上新建文件系统**



   * `doas newfs -q /dev/rfvd0a`：在 **原始字符设备**上创建 FFS（4.2BSD）文件系统。输出里能看到 cylinder groups、blocks、inodes 的统计。



3. **观察 .fvd 文件体积首次增长**



   * `ls -l 1gb.fvd`：从 \~84 MB 增到 \~88 MB —— 因为 **newfs** 写入了超级块、位图等**元数据**，触发 FVD 的**按需分配**。



4. **挂载文件系统并授权写入**



   * `doas mount /dev/fvd0a /mnt`：挂载（块设备）。

   * `doas chown <用户名> /mnt`：把挂载点所有权给当前用户，便于后续写入。



5. **往磁盘里写“真实数据”**



   * `git clone https://github.com/DoctorWkt/pdp7-unix` 到 `/mnt`：复制一大堆文件。

   * `rm -rf pdp7-unix/.git`：删掉 .git 目录（演示普通文件操作）。

   * `find .`：列出写入到虚拟盘里的文件树。



6. **卸载并分离**



   * `doas umount /mnt`：卸载文件系统（保证数据已落盘）。

   * `doas fvdctl detach fvd0`：把镜像从设备上**detach**（驱动会 flush 脏缓存并清理）。



7. **再次观察 .fvd 体积**



   * `ls -l 1gb.fvd`：变为 **\~119 MB**，说明因为克隆了仓库，FVD 又分配了更多记录。

   * 注意：虽然虚拟盘“标称 1 GB”，**.fvd 文件远小于 1 GB**，这正是 FVD 的**按需分配**效果——只为实际写过的扇区占空间。



# 你需要从示例里学到的点



* **raw vs block**：`/dev/rfvd0a`（raw/字符设备）用于 `newfs` 等底层操作；`/dev/fvd0a`（块设备）用于 `mount`。

* **按需分配**：看两次 `ls -l 1gb.fvd` 的大小变化，就能验证**初始化+写文件**确实触发了分配与写回。

* **流程闭环**：`attach → fdisk/disklabel → newfs → mount → 写文件 → umount → detach`，这条链路打通，基本说明你的 **读/写、缓存落盘、块映射更新**都在工作。

* **清理顺序**：先 `umount` 再 `detach`；若直接 detach，忙碌时会 `EBUSY`，强制可能导致未同步数据丢失。



# 小贴士（调试/自检）



* 卸载/分离前可手动 `sync` 或用你实现的 `CACHE_EMPTY` 做一次 flush。

* 若 `.fvd` 大小**没有**随写入明显增长：检查**写路径是否只写缓存未落盘**、**COW/分配是否触发**、`vn_rdwr()` 是否返回错误。

* 遇到 `umount: busy`：确认没有进程在 `/mnt` 下（终端目录也不要停在 `/mnt` 里）。


---

* 
