![image-20250411134025842](./READEME7.assets/image-20250411134025842.png)

这张图片讲解的是**图的邻接矩阵实现（Adjacency Matrix）**，并详细描述了如何通过邻接矩阵插入和删除图的顶点。下面我将详细解释每一部分内容：

### 1. **图的邻接矩阵**

首先，图片展示了一个有 4 个顶点（u, v, w, z）和 4 条边（a, b, c, d）的图。图的邻接矩阵是一个二维矩阵，**行列**对应图中的顶点，**矩阵的值**表示顶点之间是否有边。

举个例子，矩阵中的一个位置（i，j）如果有值，比如 1，说明顶点 i 和顶点 j 之间有边。如果为 0，则表示没有边。

在这个矩阵里，第一行和第一列分别对应顶点 u 和其他顶点。矩阵内的值表示这些顶点之间的连接关系。

### 2. **插入顶点（insertVertex）**

**操作：**

- **插入顶点（insertVertex）**是将一个新的顶点添加到图中。

  插入顶点的时间复杂度：

  - 添加到**顶点表**中的操作时间复杂度是 **O(1)**（常数时间）。
  - 如果矩阵已经满了，需要增加一个新行和新列，复杂度为 **O(n)**（n是当前顶点数，增加行列需要遍历矩阵一部分）。
  - 在矩阵的**上三角部分**（上三角矩阵的对角线以上部分），需要添加新列。

**总结：**

- 插入新顶点到图的邻接矩阵时，增加矩阵行列可能需要 O(n) 的时间。

### 3. **删除顶点（removeVertex）**

**操作：**

- **删除顶点（removeVertex）**是将图中的某个顶点从邻接矩阵中删除。

  删除顶点的时间复杂度也是 **O(n)**，这是因为删除顶点时必须遍历矩阵的每一行和每一列来调整矩阵的值。

**特殊说明：**

- **墓碑法（Tombstoning）**：为避免每次删除都重新调整矩阵大小，采用“墓碑法”，即用标记（如特殊符号）标记已删除的顶点，而不立即调整矩阵大小。这样可以避免频繁的矩阵大小调整，提高效率。

### 4. **邻接矩阵的表示**

在图中，矩阵的具体展示如下：

- **行和列**：表示顶点。
- **矩阵的内容**：表示顶点之间的边。例如，顶点 u 和 v 之间有一条边，矩阵的相应位置（u, v）就会被标记为 1，表示这两顶点之间有连接。

### 5. **总结**

- **插入顶点**和**删除顶点**的操作在邻接矩阵中的时间复杂度都是 O(n)，因为需要调整矩阵的维度或者更新矩阵值。
- **墓碑法**是处理删除操作的一种优化方式，它通过不立即调整矩阵来提高性能。

如果你有任何关于邻接矩阵的具体问题，或者想要进一步了解图的其他实现方法，欢迎继续提问！

![image-20250411134202729](./READEME7.assets/image-20250411134202729.png)

这张图片继续讲解**图的邻接矩阵（Adjacency Matrix）\**实现，重点是\**上三角存储**和**矩阵的空间优化**。下面是详细的解释：

### 1. **图的邻接矩阵表示**

图中的邻接矩阵仍然是一个二维矩阵，其中行和列对应图中的顶点，矩阵中的每个元素表示顶点之间是否有边。举个例子：

- 顶点 **u** 和 **v** 之间有一条边，矩阵的相应位置（u, v）是一个非零值。
- 顶点 **v** 和 **w** 之间有一条边，矩阵的相应位置（v, w）也会有值。

图的邻接矩阵依旧遵循前面提到的规则。

------

### 2. **上三角存储**

在这张图片中，提到了**上三角存储（Upper Diagonal Storage）**的概念：

- 在图的邻接矩阵中，如果是无向图，矩阵是对称的，即 **(i, j)** 位置和 **(j, i)** 位置的值是相同的。
- 采用上三角存储的方式，意味着**只存储矩阵的上三角部分**（即对角线以上的部分）。这样可以节省存储空间，因为下三角部分是冗余的。

**上三角存储的优势：**

- 只存储矩阵的一部分（上三角），这样可以节省空间，提高内存使用效率。
- 对于无向图，这样的存储方式是足够的，因为下三角和上三角是对称的。

------

### 3. **矩阵的空间优化**

在图片中，几个数组列出了如何通过上三角存储优化矩阵存储。

#### **作为列（As cols）**：

- **V = [A]**：表示顶点 A 所对应的列。
- **W = [C, B]**：表示顶点 W 所对应的列。
- **Z = [0, 0, D]**：表示顶点 Z 所对应的列。
- **X = [-,-,-,-]**：表示没有连接的顶点列。

#### **作为行（As rows）**：

- **u = [a, c, 0]**：表示顶点 u 所对应的行，它与顶点 a 和 c 有连接，0 表示与其他顶点没有连接。
- **v = [b, d, c]**：表示顶点 v 所对应的行，它与顶点 b 和 d 有连接。
- **w = [d]**：表示顶点 w 所对应的行，它与顶点 d 有连接。

------

### 4. **时间复杂度分析**

- **插入操作（insertVertex）**的时间复杂度为 **O(1)**：在上三角矩阵中添加新顶点的操作是常数时间的。
- **删除操作（removeVertex）**的时间复杂度为 **O(n)**：删除顶点时需要更新矩阵的相关部分。

------

### 总结：

- **上三角存储**是一种优化图的邻接矩阵存储方式，减少了冗余的数据存储，提高了内存效率。
- 这种方法对于无向图尤为有效，因为无向图的邻接矩阵是对称的。
- 在图的实现中，**空间优化**和**存储效率**是重要的考虑因素。

如果你有任何关于图的邻接矩阵实现的具体问题，或者想了解其他类型的图存储方式，可以继续提问！

![image-20250411134533853](./READEME7.assets/image-20250411134533853.png)

这张图片显示的是图的邻接矩阵实现的**优缺点（Pros and Cons）**，但优缺点部分尚未填写。我将为你提供邻接矩阵实现的一些**常见优缺点**。

### 优点（Pros）：

1. **快速检查边的存在**：邻接矩阵允许你在 **O(1)** 时间内检查任意两个顶点之间是否有边。只需要直接访问矩阵中的对应位置即可。
2. **简单直观**：邻接矩阵的结构非常简单，容易理解和实现，适合初学者。
3. **适合密集图**：对于边数接近顶点数平方的**密集图**，邻接矩阵的存储方式效率较高。
4. **容易实现**：邻接矩阵的实现比较简单，不需要复杂的数据结构。

### 缺点（Cons）：

1. **空间消耗大**：邻接矩阵的空间复杂度为 **O(n²)**，即使图是稀疏的，也需要为所有的可能边分配内存，这会造成空间浪费。
2. **处理稀疏图效率低**：对于边数远小于顶点数平方的稀疏图，邻接矩阵会浪费大量空间，导致内存效率低下。
3. **插入和删除操作复杂**：插入和删除顶点或边时，邻接矩阵的操作可能会比较麻烦，尤其是当图的结构发生变化时。
4. **不适合大规模图**：当图的规模非常大时，邻接矩阵的存储和操作可能导致性能瓶颈，尤其是在内存受限的情况下。

这些优缺点帮助你评估是否使用邻接矩阵作为图的表示方法。如果你对其他图的表示方法（如邻接表）有兴趣，可以继续了解。

![image-20250411134615540](./READEME7.assets/image-20250411134615540.png)

这张图片描述了图的实现方案的**头脑风暴**过程，特别是对比了不同图表示方法（例如**边列表**和**邻接矩阵**）的优缺点，并提出了一些要求。以下是对这张图片的详细解释：

### 图的实现目标

1. **比边列表更快（Faster than an edge list）**：
   - 边列表（Edge List）是一种简单的图表示方法，它将所有的边列出。在边列表中，寻找某个顶点的邻居（即与某个顶点相连的其他顶点）比较慢，因为你需要遍历所有的边。
   - 图片中提到我们希望找到一种**比边列表更快**的实现方法，尤其是在寻找顶点邻居时，这意味着我们希望能够更快速地查询图中顶点之间的连接关系。
2. **比邻接矩阵占用更少的空间（Less space than an adjacency matrix）**：
   - 邻接矩阵（Adjacency Matrix）是一个二维数组，用来表示图中顶点之间的连接关系。每个元素表示两个顶点之间是否有边连接，空间复杂度为 **O(n²)**，即使图是稀疏的也会浪费大量空间。
   - 图片中的要求是要找到一个**比邻接矩阵占用空间更少**的实现方法，特别是针对稀疏图，邻接矩阵的空间开销非常大。
3. **特别擅长找到所有邻接元素（Particularly good at finding all adjacent elements / neighbors）**：
   - 这是关于**查找邻居**的一个要求。图的邻居查找是图算法中的一个常见操作，特别是遍历图时，我们需要高效地找到某个顶点的所有邻接顶点。
   - 该图实现方案应该能**快速**地找到某个顶点的邻居，尤其是在稀疏图中，邻接矩阵或者边列表在此操作中可能会比较低效。

### 可能的解决方案

根据这些要求，**邻接表（Adjacency List）** 是一种可能的解决方案：

- **邻接表**：为每个顶点维护一个链表（或列表），该链表包含与该顶点直接相连的所有邻居顶点。对于稀疏图，邻接表占用的空间远少于邻接矩阵，因为只存储实际存在的边，不会浪费空间。
  - **邻接表的优点**：
    - **空间效率高**：只存储图中实际的边，因此对于稀疏图，空间复杂度为 **O(n + m)**，其中 **n** 是顶点数，**m** 是边数。
    - **快速查找邻居**：查找某个顶点的邻居通常只需要遍历该顶点的邻接链表，时间复杂度为 **O(k)**，其中 **k** 是该顶点的邻居数。

### 总结

这张图片的内容提出了一个问题：**我们需要一种既能高效查找邻居，又能节省空间的图表示方法**。基于这些要求，邻接表是一个合适的解决方案。它比边列表更高效，并且比邻接矩阵节省空间，尤其适合稀疏图。

![image-20250411134925183](./READEME7.assets/image-20250411134925183.png)

这张图片讲解了图的实现方式之一——**边列表（Edge List）**，并提供了关于其操作的时间复杂度分析和相关方法。下面是详细解释：

### 1. **边列表表示法（Edge List）**

边列表是一种图的表示方式，其中每一条边表示为一对顶点。对于每一条边，存储它所连接的两个顶点以及该边的属性（例如权重）。在图中，顶点间的连接关系通过边的列表表示。

例如，图中的边 **a** 连接了顶点 **u** 和 **v**，边 **b** 连接了顶点 **v** 和 **w**，边 **c** 连接了顶点 **u** 和 **w**，边 **d** 连接了顶点 **w** 和 **z**。这四条边可以在边列表中如下表示：

| u    | v    | a    |
| ---- | ---- | ---- |
| v    | w    | b    |
| u    | w    | c    |
| w    | z    | d    |

### 2. **边列表操作及其时间复杂度**

- **插入顶点（insertVertex(K key)）**：
  - 时间复杂度为 **O(1)**：插入一个新的顶点是一个常数时间操作，因为只需将顶点加入顶点列表中。
- **插入边（insertEdge(Vertex v1, Vertex v2, K key)）**：
  - 时间复杂度为 **O(1)**：插入一条新边也只需要将该边添加到边列表中，是常数时间操作。
- **删除顶点（removeVertex(Vertex v)）**：
  - 时间复杂度为 **O(m)**：删除一个顶点时，可能需要遍历整个边列表，查找并删除与该顶点相关的所有边。因此，操作的时间复杂度与图中的边数 **m** 成正比。
- **删除边（removeEdge(Vertex v1, Vertex v2, K key)）**：
  - 时间复杂度为 **O(m)**：删除一条边需要遍历边列表，找到并移除该边。对于每一条边，查找的时间复杂度为 **O(m)**。
- **查找与顶点相关的边（incidentEdges(Vertex v)）**：
  - 时间复杂度为 **O(m)**：要查找一个顶点的所有相关边，必须遍历所有边来检查每条边是否与该顶点相连。
- **判断两顶点是否相邻（areAdjacent(Vertex v1, Vertex v2)）**：
  - 时间复杂度为 **O(m)**：判断两个顶点是否相邻，必须遍历边列表并检查每一条边，看看是否存在连接这两个顶点的边。

### 3. **总结**

- **边列表的优点**：
  - **空间效率**：边列表通常比邻接矩阵节省空间，尤其适用于稀疏图，因为它只存储实际存在的边。
  - **实现简单**：插入和删除操作比较简单。
- **边列表的缺点**：
  - 查找邻接关系不高效。由于边列表没有直接记录顶点之间的关系，查找两个顶点是否相邻需要遍历整个边列表，时间复杂度是 **O(m)**，对于大型图来说效率较低。

边列表是处理稀疏图的一种有效方式，但当需要频繁查找邻接关系时，效率较低，可能需要考虑其他更高效的图表示方法（如邻接表）。

![image-20250411135103346](./READEME7.assets/image-20250411135103346.png)

这张图片介绍了**邻接矩阵（Adjacency Matrix）**的图表示方式，包括顶点存储和边存储的细节。

### 1. **顶点存储（Vertex Storage）**

图中的顶点（如 **u, v, w, z**）需要存储在某个结构中。此处提到的存储方式是使用**哈希表（Hash Table）**来存储顶点，具体内容如下：

- **哈希表存储**：哈希表能够在 **O(1)** 时间内通过顶点的标识符（如 **u**）查找它对应的索引位置。这是因为哈希表能够根据键值对快速定位数据。
- **隐式或显式存储索引**：顶点的索引可以**隐式**存储（例如，数组中按照顺序排列），或者**显式**存储（例如，哈希表存储顶点的名称及其对应的索引）。

在图中，**u, v, w, z** 的顶点索引分别为 **0, 1, 2, 3**。哈希表的作用就是将这些顶点的名称映射到它们的索引位置，以便能够高效地定位。

### 2. **边存储（Edge Storage）**

邻接矩阵是一个 **|V| x |V|** 的二维数组，其中 **|V|** 是图中的顶点数，矩阵中的每个元素表示一个边的存在与否。具体细节如下：

- **边存储**：矩阵中的行和列代表图中的顶点。对于每一对顶点 **(i, j)**，矩阵中的位置 **(i, j)** 会存储这两个顶点之间的边。如果存在边，存储边的**权重**；如果没有边，则存储 **0** 或者其他表示没有边的值。
  - 例如：图中有一条从顶点 **u** 到顶点 **v** 的边，权重为 **a**，在矩阵中 **(u, v)** 位置存储值 **a**。
  - 另一条边从 **u** 到 **w**，权重为 **c**，在 **(u, w)** 位置存储 **c**。
  - **(v, v)**、**(w, w)** 等对角线位置则通常存储 **0** 或者 **-**，表示没有自环。
- **矩阵维度**：邻接矩阵的维度是 **|V| x |V|**，即顶点数量的平方。如果图是稀疏的，这样的矩阵会浪费大量空间。

### 3. **权重存储**

- 在邻接矩阵中，边的权重存储在对应位置 **(u, v)**，这意味着矩阵的每个元素存储了从顶点 **u** 到顶点 **v** 的边的权重。
- 如果图是无权图，则直接用 **0** 或 **-** 表示没有边。如果是有权图，则在相应的矩阵位置存储权重值。

### 总结：

- **哈希表**用于存储顶点和它们的索引，以便能够高效地访问顶点的位置。
- **邻接矩阵**存储顶点之间的边以及边的权重，通过一个二维数组表示图的连接关系。
  - 对于每对顶点 **(i, j)**，矩阵 **(i, j)** 存储边的权重或 **0**（如果没有边）。
- **空间效率**：邻接矩阵对于稀疏图的空间利用率较低，因为即使没有边，矩阵中的每个位置也都需要存储数据。

如果图是密集图，邻接矩阵的使用可以比较高效，但对于稀疏图来说，其他数据结构（如邻接表）可能更加节省空间。

![image-20250411135346378](./READEME7.assets/image-20250411135346378.png)

这张图片介绍了如何在**邻接矩阵（Adjacency Matrix）\**中\**删除顶点**（removeVertex）及其实现步骤。

### 1. **删除顶点（removeVertex）**

在图的邻接矩阵中，删除顶点意味着你需要处理与该顶点相关的行和列。删除顶点的步骤如下：

#### 步骤 1：查找顶点的行和列

- 每个顶点在邻接矩阵中都有一个对应的行和列。例如，顶点 **u** 对应第 **0** 行和第 **0** 列，顶点 **v** 对应第 **1** 行和第 **1** 列，以此类推。
- 删除顶点时，首先需要**查找该顶点对应的行和列**，这些行列对应了该顶点与其他顶点之间的连接关系。

#### 步骤 2：用墓碑值替换

- 一旦找到了顶点对应的行和列，你需要用一个特殊的**墓碑值（tombstone value）**来替换这些位置的内容。墓碑值通常是一个标记，表示该位置的数据已经被删除，但并没有物理上从矩阵中移除。墓碑值的作用是防止数据丢失，同时允许后续操作（如重新调整矩阵）能够识别到这些删除的位置。
- 比如，**u** 顶点与其他顶点之间的边被删除后，矩阵中的 **(u, v)** 和 **(v, u)** 等位置会被替换成墓碑值。

### 2. **邻接矩阵的特点**

- **上三角存储**：图中还提到邻接矩阵使用**上三角存储**的方式，即只存储矩阵的上半部分，因为对于无向图，邻接矩阵是对称的。这样可以节省内存空间，只保存一部分数据。

### 总结：

- 删除顶点操作的核心是查找与该顶点相关的行和列，并将这些位置替换为墓碑值。
- **墓碑值**是一种常见的标记，用于处理删除操作中的空缺位置，避免完全删除数据，也便于后续的维护。
- 这种方法的优点是可以避免频繁重新调整矩阵的大小，但缺点是数据删除后仍然占用空间，且增加了额外的标记和管理工作。

如果你有任何关于墓碑法的具体问题，或想了解其他图的操作方式，可以继续提问！

![image-20250411135536508](./READEME7.assets/image-20250411135536508.png)

这张图片介绍了**墓碑法（Tombstoning）\**和\**渐进式删除（Amortized Removal）\**的概念，并将其应用于图的邻接矩阵。具体来说，这种方法用于\**删除元素**并**节省空间**，当删除的元素达到一定数量时，会进行整体的重调整。

### 1. **墓碑法（Tombstoning）**

墓碑法是一种处理删除操作的技术，在删除元素时并不立即从数据结构中移除该元素，而是将其标记为“已删除”状态。这种做法的优势在于：

- **不立即调整结构**：删除操作通过将元素标记为“删除”（墓碑值），而不是物理删除数据，避免了每次删除时都需要重新调整数据结构。这样，删除操作的时间复杂度可以保持在 **O(1)**，而不需要进行更昂贵的操作。
- **提高效率**：在没有足够删除元素时，数据结构不需要频繁的重新调整大小或进行其他复杂的操作。

### 2. **渐进式删除（Amortized Removal）**

在渐进式删除中，当**删除足够多的元素**后，才会**统一调整数据结构**，即进行整体的重新调整或压缩操作。具体做法如下：

- **当删除足够多的元素时**，可能会触发一次重新调整操作，这通常是为了节省空间。
- **整体调整**：此时，不是逐个删除，而是一次性对整个数据结构进行清理或压缩，从而提高性能。

例如，图片中提到的数组如下：

```
[2, 7, 5, 9, 7, 14, 1, 0, 8, 3]
```

当删除某些元素后，例如 **5** 和 **9**，数组中的位置会被标记为已删除（例如通过墓碑法）。在删除了足够多的元素后，可以一次性重新调整数组，使得数据结构更加紧凑。

### 3. **邻接矩阵中的墓碑法**

在**邻接矩阵（Adjacency Matrix）**中，删除顶点时：

- 使用墓碑法标记被删除的顶点。
- **删除顶点（removeVertex）**操作：使用墓碑法删除顶点，即通过将对应位置替换为墓碑值，而不是删除该元素。这样可以节省频繁调整矩阵的开销。

#### 具体步骤：

1. **查找行和列**：根据顶点的位置，查找并标记该顶点的行和列。
2. **替换为墓碑值**：将矩阵中对应位置替换为墓碑值，以表示该顶点已删除。

### 4. **总结**

- **墓碑法**允许我们高效地删除顶点或边，通过标记删除而不是物理移除数据。
- **渐进式删除**意味着只有在删除足够多的元素时，才会统一进行数据结构的重调整或压缩操作，从而减少频繁调整带来的开销。
- 这种方法提高了删除操作的效率，尤其是在处理大量数据时。

如果你对墓碑法的细节或其他图的实现方法有疑问，欢迎继续提问！

![image-20250411140108634](./READEME7.assets/image-20250411140108634.png)

这张图片详细解释了使用**邻接矩阵（Adjacency Matrix）**来实现图的操作，并提供了相关操作的时间复杂度分析。让我们逐个分析这些操作。

### 1. **操作和时间复杂度**

- **插入边（insertEdge）**:
  - **时间复杂度：O(1)**
     插入一条边的时间复杂度为 **O(1)**，意味着我们可以直接在矩阵中找到相应的位置（行和列的交点），并更新该位置的值。这对于**无权图**通常表示 **1**，而在**有权图**中表示边的权重。
- **删除边（removeEdge）**:
  - **时间复杂度：O(1)**
     删除边操作同样是 **O(1)**，因为我们直接查找并修改矩阵中相应位置的值即可。
- **判断两顶点是否相邻（areAdjacent）**:
  - **时间复杂度：O(1)**
     这个操作也非常快速，可以直接查找矩阵中相应的行列位置，判断是否有连接的边（或者值为 1 或边的权重）。
- **查找某个顶点的所有邻接边（incidentEdges）**:
  - **时间复杂度：O(n)**
     查找一个顶点的所有邻接边时，需要遍历矩阵的该行（对应顶点的行），因此需要 **O(n)** 的时间，其中 **n** 是图中顶点的数量。
- **插入顶点（insertVertex）**:
  - **时间复杂度：O(n) 到 O(n²)**
     在邻接矩阵中插入一个顶点时，通常需要扩展矩阵的行和列，这需要 **O(n)** 的操作。如果矩阵已满，还需要调整存储结构，可能会达到 **O(n²)** 的时间复杂度。
- **删除顶点（removeVertex）**:
  - **时间复杂度：O(n) 到 O(n²)**
     删除一个顶点时，需要修改矩阵中的相关行列，同样涉及到调整矩阵的大小或处理墓碑值，时间复杂度可能是 **O(n)** 到 **O(n²)**，具体取决于实现。

### 2. **邻接矩阵的实现**

在邻接矩阵中，矩阵的每个位置都表示了两个顶点之间的边。行和列的索引分别对应图中的顶点。例如，矩阵中的元素 **(u, v)** 表示从顶点 **u** 到顶点 **v** 的边。如果存在边，则存储 **1** 或边的权重，否则存储 **0** 或其他标记。

### 3. **总结**

- **O(1)** 的操作包括插入边、删除边和判断顶点是否相邻，因为这些操作可以直接通过矩阵的行列位置访问。
- **O(n)** 的操作涉及查找顶点的所有邻接边，因为需要遍历顶点对应的整行。
- **O(n²)** 的操作主要出现在插入或删除顶点时，特别是需要重新调整矩阵的大小。

**邻接矩阵**是实现图操作时的一种常见数据结构，它对密集图（边数接近顶点数平方）非常有效，但对于稀疏图来说，它可能会浪费大量空间。

![image-20250411140537043](./READEME7.assets/image-20250411140537043.png)

这张图片讲解了图的实现方式之一——**边列表（Edge List）**，并探讨了它与其他技术（如指针和查找操作）结合的效果。

### 1. **边列表（Edge List）**

**边列表**是图的一种常见表示方式。它将图的每条边表示为一对顶点，并且通常包括边的权重信息。图中的每条边通过一对顶点（例如 **u, v**）以及一个表示权重的值（例如边 **a**）来表示。

在图片中，我们可以看到如下的结构：

- **边列表**存储了顶点对和边的权重：

  ```
  u, v, a
  v, w, b
  u, w, c
  w, z, d
  ```

  其中每一行表示一条边。比如，第一行表示从顶点 **u** 到顶点 **v** 之间有一条权重为 **a** 的边。

### 2. **指针（Pointers）**

图中的蓝色箭头表示**指针**。这可能是指在边列表中使用指针来表示顶点之间的连接关系。

- **指针**可以帮助快速连接顶点和它们的边。在图的实现中，指针可以用来连接边列表中的顶点和它们对应的边，这样可以更灵活地管理图的连接。
- 例如，从 **u** 顶点出发，使用指针可以快速找到与它相连的其他顶点和边。

### 3. **遍历整个列表（Look through entire list）**

在图片的右侧，红色标记的部分说明了**查找相邻元素**的操作。

- **查找顶点的邻居**：如果要查找顶点的邻居（即与该顶点相连接的所有其他顶点），则需要**遍历整个边列表**，检查每条边是否与该顶点相关。
  - **时间复杂度：O(m)**，其中 **m** 是图中边的数量。因为在最坏的情况下，需要遍历所有的边来找到与某个顶点相关的边。

### 4. **优缺点分析**

- **优点**：
  - 边列表简单、直观，对于**稀疏图**来说占用空间较少，因为只存储实际存在的边。
  - 可以通过指针高效地管理图中顶点的连接。
- **缺点**：
  - 查找顶点的邻接边比较慢。为了查找某个顶点的所有邻居，需要遍历整个边列表，时间复杂度是 **O(m)**，这对于边数较多的图可能效率较低。
  - 插入或删除操作需要修改边列表，可能会带来一定的性能开销。

### 5. **总结**

- **边列表**是一种存储图的方式，适用于稀疏图，存储每条边的两个顶点和可能的权重。
- **指针**可以用于连接图中的顶点和它们的边，提高操作的灵活性。
- 查找邻接边时需要**遍历整个列表**，这对于大型图的操作可能会影响效率。

![image-20250411140643489](./READEME7.assets/image-20250411140643489.png)

这张图片讲解了图的**邻接表（Adjacency List）\**实现方式，并描述了一种简单的邻接表实现，其中每个顶点对应一个链表，存储它的邻居。图片展示了这种实现的\**优缺点**以及如何表示图的边。

### 1. **邻接表实现（Naive Adjacency List）**

邻接表是一种图的常见表示方法，每个顶点有一个链表，链表中存储与该顶点直接连接的其他顶点。对于每一条边，它会出现在两个顶点的链表中（对于无向图）。

在这张图片中，邻接表如下所示：

- **顶点 u** 的链表包含 **v** 和 **w**，即顶点 **u** 与 **v** 和 **w** 相连。
- **顶点 v** 的链表包含 **u** 和 **w**，即顶点 **v** 与 **u** 和 **w** 相连。
- **顶点 w** 的链表包含 **v**、**u** 和 **z**，即顶点 **w** 与 **v**、**u** 和 **z** 相连。
- **顶点 z** 的链表仅包含 **w**，即顶点 **z** 与 **w** 相连。

### 2. **图的度（Degree）**

每个顶点的**度（degree）**表示与该顶点相连的边的数量。在图片中，每个顶点的度如下：

- **顶点 u** 的度为 **2**，因为它与 **v** 和 **w** 相连。
- **顶点 v** 的度为 **2**，因为它与 **u** 和 **w** 相连。
- **顶点 w** 的度为 **3**，因为它与 **v**、**u** 和 **z** 相连。
- **顶点 z** 的度为 **1**，因为它仅与 **w** 相连。

度是计算图中每个顶点的连接数的指标，通常用于图的分析。

### 3. **双向边（Bidirectional Edge List）**

在这张图中，边被描述为**双向的（bidirectional）**。这意味着，如果 **u** 和 **v** 之间有边，那么这条边会出现在 **u** 的链表中，并且也会出现在 **v** 的链表中。这适用于**无向图**，因为无向图中的每条边是双向的。

- 例如，边 **a** 将 **u** 和 **v** 连接，这意味着边 **a** 在 **u** 和 **v** 的邻接链表中都会出现。

### 4. **邻接表的优缺点**

#### 优点：

- **空间高效**：邻接表仅存储实际存在的边，对于稀疏图而言，邻接表比邻接矩阵节省空间。
- **快速遍历邻居**：可以快速遍历一个顶点的所有邻居。访问某个顶点的邻接边的时间复杂度是 **O(k)**，其中 **k** 是该顶点的度。

#### 缺点：

- **查找是否相邻较慢**：若要查找两个顶点是否相邻，需要遍历其中一个顶点的邻接链表，时间复杂度是 **O(k)**，其中 **k** 是该顶点的度。对于密集图来说，这个操作较慢。

### 5. **总结**

- **邻接表**适用于稀疏图，它节省了存储空间并允许高效的邻居遍历。
- 每个顶点通过一个链表记录它的邻居，可以实现简单的插入和删除操作。
- **度**表示了每个顶点的连接数量，并且通过邻接表可以很容易地获取每个顶点的度。

如果你有任何关于邻接表的细节问题，或想了解其他图的实现方式，请随时提问！

![image-20250411140811534](./READEME7.assets/image-20250411140811534.png)

这张图片详细讲解了使用**邻接表（Adjacency List）**表示图时的几个重要操作：**查找邻接边（incidentEdges）\**和\**判断两个顶点是否相邻（areAdjacent）**。它还涉及了操作的时间复杂度分析。

### 1. **邻接表（Adjacency List）**

邻接表是一种图的存储方式，其中每个顶点都对应一个链表，该链表存储与该顶点相连的所有邻接顶点。在这张图片中，邻接表存储的是每个顶点与其相连的顶点和边的关系。

例如：

- **顶点 u** 的邻接链表包含顶点 **v** 和 **w**，与它们分别通过边 **a** 和 **c** 相连。
- **顶点 v** 的邻接链表包含顶点 **u** 和 **w**，与它们分别通过边 **a** 和 **b** 相连。
- **顶点 w** 的邻接链表包含顶点 **v**、**u** 和 **z**，与它们分别通过边 **b**、**c** 和 **d** 相连。

### 2. **查找顶点的所有邻接边（incidentEdges）**

**操作：**
 查找某个顶点的所有邻接边（即找到与该顶点相连的所有边）。在邻接表中，这个操作通过遍历顶点的邻接链表来完成。

**时间复杂度：**

- **O(deg(v))**，其中 **deg(v)** 表示顶点 **v** 的度，即与顶点 **v** 相连的边的数量。这个操作是最优的，因为它只需要遍历顶点 **v** 的邻接链表中的 **deg(v)** 条边。

### 3. **判断两个顶点是否相邻（areAdjacent）**

**操作：**
 判断两个顶点是否相邻。该操作需要检查是否在某个顶点的邻接链表中找到另一个顶点。

**时间复杂度：**

- **O(min(deg(v1), deg(v2)))**，其中 **deg(v1)** 和 **deg(v2)** 分别是顶点 **v1** 和 **v2** 的度。由于我们只需要遍历较小度数顶点的邻接链表来查找是否存在对方，因此复杂度为 **min(deg(v1), deg(v2))**。

### 4. **总结**

- **查找邻接边（incidentEdges）**：该操作的时间复杂度是 **O(deg(v))**，适用于需要获取一个顶点的所有邻接边的情况。
- **判断是否相邻（areAdjacent）**：该操作的时间复杂度是 **O(min(deg(v1), deg(v2)))**，适用于判断两个顶点是否通过一条边相连。

**邻接表**是处理**稀疏图**的高效方式，因为它只存储实际存在的边。对于每个顶点，操作的时间复杂度通常与该顶点的度成正比。

如果你有任何关于邻接表操作的进一步问题，或者其他图表示方法的疑问，可以继续提问！

![image-20250411141042296](./READEME7.assets/image-20250411141042296.png)

这张图片讲解了在**邻接表（Adjacency List）**中删除顶点的操作及其相关的复杂度分析。

### 1. **删除顶点（removeVertex）**

**操作：**

- **删除顶点**意味着不仅要从该顶点的邻接链表中删除它的连接边，还需要从所有与该顶点相连的其他顶点的邻接链表中删除指向该顶点的边。
- 例如，删除顶点 **u** 时：
  - 在 **u** 的邻接链表中删除 **v** 和 **w**。
  - 同时，在 **v** 和 **w** 的邻接链表中，也需要删除指向 **u** 的边。

**复杂度分析：**

- **时间复杂度：O(n²)**：最坏情况下，删除一个顶点可能需要遍历图中所有的顶点，尤其是在图密集的情况下，**删除操作的时间复杂度是 O(n²)**。因为你需要检查每个顶点的邻接链表，删除指向该顶点的所有边。

### 2. **删除操作的步骤**

- **遍历该顶点的边列表**：首先，你需要遍历顶点 **v** 的邻接链表，删除与该顶点相关的所有边。
- **删除邻接链表中的指向该顶点的边**：接下来，需要检查图中所有与顶点 **v** 相邻的顶点，并从它们的邻接链表中删除指向顶点 **v** 的边。

### 3. **删除操作的影响**

- 删除顶点会改变图中其他顶点的邻接链表，因此每个邻接链表都需要更新。这使得删除操作相对复杂，因为它不仅仅影响删除的顶点，还需要修改与它相邻的所有顶点的链表。

### 4. **图的最终状态**

在图的最终状态中，我们看到顶点 **u** 已被删除，并且其邻接链表中的边也被删除。同时，与 **u** 相邻的顶点 **v** 和 **w** 的邻接链表也已更新，移除了指向 **u** 的边。

### 5. **时间复杂度**

- **O(n²)**：最坏情况下，删除一个顶点需要在邻接表中进行广泛的删除操作，尤其是在图密集时，每个顶点的邻接链表可能都包含大量边。因此，最坏情况下的时间复杂度为 **O(n²)**。

### 总结：

- 在**邻接表**中，**删除顶点**操作需要遍历该顶点的所有邻接链表，并从其他顶点的邻接链表中删除与该顶点相关的边。最坏情况下的时间复杂度为 **O(n²)**，尤其在图比较密集时。

![image-20250411141201649](./READEME7.assets/image-20250411141201649.png)

这张图片继续讲解了**邻接表（Adjacency List）**的实现，并指出了当前实现的一些问题以及如何通过使用**指针（Pointers）**来解决这些问题。

### 1. **问题：删除顶点时的复杂度**

- **问题描述**： 在当前的邻接表实现中，删除一个顶点涉及到**删除该顶点的邻接链表**中与它相连的所有边。同时，还需要遍历**其他所有顶点的邻接链表**，并从每个邻接链表中删除指向该顶点的边。

  这意味着，**删除顶点的操作**可能会涉及到图中**所有顶点的邻接链表**，即最坏情况下，删除一个顶点需要遍历图中的 **n** 个顶点和 **m** 条边，时间复杂度可能接近 **O(n²)**。

- **为什么是问题**： 这种方法效率较低，特别是在图较大时，删除顶点的操作会导致很大的性能开销。

### 2. **如何解决？使用指针（Pointers）**

- **解决方案**： 图片中提到的解决方案是使用**指针**。通过在邻接表中使用指针，我们可以使删除操作更加高效。
- **指针的使用**：
  - **使用指针**来连接邻接表中的元素。通过指针，边的删除操作不再需要遍历整个邻接链表，而是可以通过直接修改指针的引用来删除。
  - 通过指针，可以在图的实现中动态地维护顶点之间的连接关系。当删除一个顶点时，我们只需要修改指针，而不必重新调整每个邻接链表中的元素顺序。

### 3. **邻接表实现的结构**

- 在图片中，邻接表结构仍然是由每个顶点的邻接链表组成：
  - **顶点 u** 的邻接链表包含 **v** 和 **w**，对应的边分别是 **a** 和 **c**。
  - **顶点 v** 的邻接链表包含 **u** 和 **w**，对应的边分别是 **a** 和 **b**。
  - **顶点 w** 的邻接链表包含 **v**、**u** 和 **z**，对应的边分别是 **b**、**c** 和 **d**。
  - **顶点 z** 的邻接链表包含 **w**，对应的边是 **d**。

### 4. **指针的优势**

- **提高删除操作的效率**：使用指针后，当删除顶点时，不需要遍历整个邻接表，可以通过直接操作指针来删除相应的边，减少了时间复杂度。
- **动态调整**：指针使得图的结构更加灵活，顶点的删除或添加不需要重新排列邻接链表中的元素，只需要调整指针的指向。

### 5. **总结**

- **邻接表**是一种常用的图的表示方法，尤其适用于**稀疏图**，因为它节省了存储空间。
- 删除操作可能导致性能问题，尤其是在图较大时，删除顶点需要遍历所有邻接链表。
- **使用指针**是一个优化方法，通过动态调整指针，可以有效提升图操作的效率，特别是删除操作。

如果你对指针如何应用于图的实现有更多问题，或者想了解其他图的表示方法，欢迎继续提问！

![image-20250411142521643](./READEME7.assets/image-20250411142521643.png)

这张图片解释了在**邻接表（Adjacency List）\**中使用\**指针**来连接**列表节点（list nodes）\**的概念。它强调了如何在邻接表中通过指针来\**连接每个顶点**的邻接边，从而建立顶点之间的连接关系。

### 1. **邻接表的结构**

在邻接表中，每个顶点都有一个对应的链表，链表中存储该顶点所有相邻的顶点及与它们的边。例如：

- 顶点 **u** 与 **v** 和 **w** 相连，且边的权重分别是 **a** 和 **c**。
- 顶点 **v** 与 **u** 和 **w** 相连，边的权重分别是 **a** 和 **b**。
- 顶点 **w** 与 **v**、**u** 和 **z** 相连，边的权重分别是 **b**、**c** 和 **d**。
- 顶点 **z** 与 **w** 相连，边的权重是 **d**。

### 2. **指针的作用**

图片中用红色、蓝色和绿色的箭头表示**指针连接**。这些箭头表示顶点之间的连接关系：

- **红色箭头**：表示从 **u** 到 **v**，边的权重为 **a**。
- **蓝色箭头**：表示从 **w** 到 **u**，边的权重为 **c**。
- **绿色箭头**：表示从 **v** 到 **w**，边的权重为 **b**。

在邻接表的实现中，**指针**用于在链表中建立顶点之间的连接。每个**列表节点**（存储顶点和边的信息）都通过指针相连，形成一个链表结构。通过这种方式，可以高效地表示和维护图的边。

### 3. **我们希望连接邻接表中的列表节点**

- **列表节点之间的连接**：通过指针，邻接表中的每个顶点的邻接链表节点指向与之相邻的其他顶点。这种结构帮助我们动态地管理图的连接关系，特别是在添加、删除顶点或边时，只需要调整指针，而无需重新排序整个链表。
- **优化操作**：指针连接让删除或修改边时，操作变得更为高效。你可以直接更新链表中的指针，而不需要重新排列或遍历整个邻接链表。

### 4. **总结**

这张图片强调了**指针在邻接表中的作用**，指针使得图的表示更加高效，尤其是在删除或插入顶点和边时，操作变得更加高效。通过使用指针来连接邻接表中的元素，可以避免不必要的内存移动和排序，从而提高图操作的效率。

如果你还有其他关于图结构或指针优化的疑问，欢迎继续提问！

![image-20250411144714089](./READEME7.assets/image-20250411144714089.png)

这张图展示了两种邻接表（Adjacency List）实现方式的对比，重点在于右边的结构是一个**改进型邻接表实现**，通过引入**共享边对象和指针连接**来优化传统做法，主要解决的问题是**边的重复存储和操作效率问题**。

------

## 左侧：**传统邻接表实现**

这是我们常见的做法，每个顶点的邻接链表中会**分别存储所有与它相连的边的信息**。

例如：

- 顶点 `u` 的邻接链表是 `[v, a] -> [w, c]`，分别代表边 `a` 和 `c`。
- 顶点 `v` 的邻接链表是 `[u, a] -> [w, b]`，注意这里的 `a` 边在 `u` 和 `v` 的邻接表中**各自存了一份**。

### 问题：

- 每条边被**存储了两次**（一次在每个端点的邻接表中），比如 `a` 同时出现在 `u` 和 `v` 的链表中。
- 修改一条边时（如更新权重），必须修改两处，容易出错。

------

## 右侧：**优化后的邻接表实现（带指针的边对象）**

右边的结构通过引入一个**中心边表**（右下角的表）和**指针链接机制**来优化存储：

### 关键特性：

1. **边只存一次（No more double storing）**
   - 边的信息（如端点和权重）只在一个地方存储，即下方的边列表（右下角表格）中。
   - 每个顶点的邻接链表不再直接存储目标顶点和边值，而是存储一个**指向边对象的指针**（如 `*a`、`*b` 等）。
2. **共享边对象**
   - 顶点 `u` 和 `v` 不再分别各自存储边 `a`，而是它们的邻接表都指向同一个 `*a` 对象。
3. **双向连接（红色和蓝色箭头）**
   - 图中红色箭头表示顶点 `u`、`v` 的邻接表节点指向 `*a` 对象，蓝色箭头表示从 `*a` 对象能反指回顶点链表节点（可以方便删除时快速定位链表中的节点）。
   - 每个边对象 `*a`、`*b` 等也可以通过双向指针连接（灰色箭头），形成一个全局的边集结构。

------

## 优势总结：

### 为什么这样设计好？

| 问题                     | 改进                       |
| ------------------------ | -------------------------- |
| **每条边被存两次**       | 每条边只存一次（节省空间） |
| **修改边值需要修改两处** | 只需改一次即可同步         |
| **删除边时要找两份位置** | 指针可快速定位两个端点     |
| **冗余多、易错**         | 结构清晰，可维护性更强     |

------

## 结尾总结：

这张图演示了如何通过**指针**和**边对象共享机制**来优化传统的邻接表结构。该设计使得图的结构更加紧凑高效，尤其在需要频繁增删边、修改边属性（如权重、标记等）时，可以极大减少重复操作和数据不一致的风险。

如果你想进一步了解如何用代码实现这种结构，或者在某种语言中应用它，我也可以帮你写个例子！是否需要？

![image-20250411144928720](./READEME7.assets/image-20250411144928720.png)

这张图介绍了一个优化的**邻接表（Adjacency List）**的实现，采用了指针和双向链表的方式来存储图的连接。图中描述了**邻接链表节点（Adj List Node）**和**边表（Edge List）**的结构，以及如何通过指针更有效地管理图中的顶点和边。

### 1. **邻接链表节点（Adj List Node）**

每个邻接链表节点由三个部分组成：

- **Prev**：指向前一个邻接链表节点的指针（在双向链表中使用）。
- **Edge**：指向实际边的指针，表示该顶点和相邻顶点之间的连接。
- **Next**：指向下一个邻接链表节点的指针（在双向链表中使用）。

这种结构允许邻接链表中的节点具有**双向连接**，即不仅可以从一个顶点遍历到另一个顶点，还可以反向遍历，从而提高操作效率。

### 2. **边表（Edge List）**

边表包含了所有图的边的信息，通常包括：

- **V1** 和 **V2**：分别表示边的两个端点。
- **Weight**：表示边的权重。

在图的优化实现中，边表不仅存储了两个端点的信息，还通过指针**回到邻接表**，使得边和邻接关系更加紧密地连接。

### 3. **优化的邻接表和边表（图右侧）**

- **邻接表优化**：通过使用指针，邻接表中的每个顶点不仅存储它的邻接节点，还可以快速找到相应的边。
- **边表优化**：每条边不仅存储端点和权重信息，还通过指针**回到对应的邻接链表节点**，这样可以避免在图的不同位置重复存储相同的边信息。

#### 具体解释：

- **红色箭头**和**蓝色箭头**表示指针之间的连接。红色箭头表示顶点 `u` 和 `v` 之间的边 `a`，蓝色箭头表示顶点 `w` 和 `z` 之间的边 `d`。通过指针，我们可以快速地在图的不同部分之间建立连接关系。
- **边 `a`**：通过指针 `*a`，它可以指向顶点 `u` 和 `v` 之间的连接，且通过边表直接关联到对应的邻接链表节点。

### 4. **优化的好处**

- **减少重复存储**：每条边的信息仅存储一次，不需要在多个邻接链表中重复存储。
- **便于更新**：如果图发生变化（例如，删除或更新边的权重），可以通过指针直接修改边表，而不需要遍历所有邻接链表。
- **提高操作效率**：通过双向指针，可以快速地进行删除和插入操作，不需要重新调整邻接链表中的所有节点。

### 总结：

这张图展示了如何通过**双向指针**和**优化后的边表**来改进传统邻接表的实现。通过这种方式，图的数据结构更加紧凑，并且在进行修改和删除操作时更加高效。通过指针的引入，我们避免了边的重复存储，并使得图的更新更加高效。

如果你有任何问题，或者需要进一步了解如何在代码中实现这种结构，请随时告诉我！

![image-20250411145133941](./READEME7.assets/image-20250411145133941.png)

这张图展示了一种**改进版的邻接表（Adjacency List）\**实现，采用了\**双向链表**和**边表（Edge List）**的优化结构来存储图的数据。

### 1. **顶点存储（Vertex Storage）**

- **双向链表**：图的顶点存储结构采用**双向链表**，每个链表节点是一个指向**边表**中相应边的指针。
- **大小可变**：每个顶点的链表大小是可变的，表示该顶点的度（与它相连的边的数量）。
- **哈希表**：顶点通过哈希表管理，哈希表将顶点与其链表节点对应，使得访问顶点的操作更高效。

### 2. **边存储（Edge Storage）**

- **边表（Edge List）**：边的信息（两个顶点和边的权重）被存储在一个边表中。边表包含多个条目，每一条记录包含一条边的两个端点和权重：
  - 每个条目存储了两个顶点（`v1`, `v2`）以及该边的权重（`weight`）。
- **指向顶点的指针**：除了存储边的信息，边表中的每一条边还存储了指向顶点的指针。这个指针指向存储该边的**邻接链表节点**。

### 3. **优化后的图结构（右侧示意图）**

- **双向连接**：边表通过指针连接到每个顶点的邻接链表。通过双向链表，可以快速地从一个顶点找到其所有相邻的顶点，同时也能反向遍历（从邻接的顶点回到原顶点）。
- **箭头表示指针的方向**：图中箭头表示顶点与边之间的连接：
  - **红色箭头**表示顶点 `u` 与 `v` 之间的边 `a`，并且通过指针连接到边表中的 `a`。
  - **紫色箭头**表示顶点 `w` 和 `z` 之间的边 `d`，也通过指针连接到边表中的 `d`。

### 4. **优点：**

- **节省空间**：通过边表和指针共享边信息，避免了在每个顶点的邻接链表中存储相同的边多次。
- **高效的更新和删除操作**：在这种优化下，删除顶点或边时不需要修改整个邻接链表的顺序，只需要操作指针，减少了不必要的操作。
- **增加双向访问能力**：双向链表和边表的结合允许我们从顶点出发遍历邻接边，同时也能反向操作，便于删除和修改边。

### 5. **总结**

这张图展示了如何通过优化顶点存储和边存储结构来提高邻接表的效率。通过**双向链表**和**边表**，图的数据存储变得更加紧凑，且在进行修改、删除操作时更加高效。这种结构特别适用于需要频繁更新和删除的图结构操作。

如果你对如何在代码中实现这种结构有更多问题，或有其他问题，欢迎继续提问！

![image-20250411145241363](./READEME7.assets/image-20250411145241363.png)

这张图讲解了**邻接表（Adjacency List）**中**查找顶点的所有邻接边（incidentEdges）**操作的过程，并展示了如何使用指针来高效地获取与某个顶点相连的所有边。

### 1. **查找顶点的所有邻接边（incidentEdges）**

**操作说明**：

- **目标**：给定一个顶点 **v**，我们希望能够快速找出与该顶点相连的所有边（即**查找该顶点的邻接边**）。
- **方法**：
  1. 首先，在顶点的邻接表中查找与顶点 **v** 相关的**邻接链表**（即查找顶点的邻接链表节点）。
  2. 然后，通过**指针**查找指向边表的指针，获取与顶点 **v** 相连的边。

### 2. **操作过程（如图所示）**：

图中的顶点 **u**, **v**, **w**, **z** 各自都有一个指向边的链表，其中存储了与这些顶点相连的边。例如：

- 顶点 **u** 的邻接链表包含了与其相连的边 **a**（与 **v** 相连）和 **c**（与 **w** 相连）。
- 顶点 **v** 的邻接链表包含了与其相连的边 **a**（与 **u** 相连）和 **b**（与 **w** 相连）。

### 3. **时间复杂度（O(deg(u)))**

- 查找顶点 **v** 的所有邻接边时，我们只需要遍历与该顶点相连的边的数量，即**顶点的度数**（`deg(v)`）。因此，操作的时间复杂度为 **O(deg(v))**。
- **deg(v)** 表示顶点 **v** 的度数，即与该顶点直接相连的边的数量。

### 4. **指针优化的作用**

- 图中的箭头表示了通过**指针**进行的连接。每个顶点的邻接链表中的节点存储了一个指向边表的指针，这样我们可以快速获取到边的信息，而不需要重新存储边的数据。
- **边表**中的每一条边对象包含了边的端点信息（`v1`, `v2`）和边的权重，并且这些边对象通过指针回指向相应的邻接链表节点。

### 5. **总结**

- **查找邻接边**：通过遍历顶点的邻接链表并使用指针来访问边，可以高效地获取与顶点相关的所有边。
- **时间复杂度**：该操作的时间复杂度为 **O(deg(v))**，即与顶点的度数成正比。
- **指针优化**：通过指针，图的数据结构更加紧凑，并且修改和删除边的操作变得更加高效。

这个方法使得图的存储和操作更加高效，尤其是在需要频繁查找或更新图结构时。

![image-20250411145412452](./READEME7.assets/image-20250411145412452.png)

这张图讲解了如何在**邻接表（Adjacency List）\**中实现\**判断两个顶点是否相邻**的操作，具体是通过一个叫做 **`areAdjacent`** 的方法来判断两个顶点之间是否存在边连接。

### 1. **`areAdjacent` 方法**：

这个方法的目的是判断两个顶点 **`v1`** 和 **`v2`** 是否通过一条边相连。

- **步骤**：
  1. **查找度数较小的顶点**：首先，方法会根据两个顶点的度数（即与每个顶点相连的边的数量）来选择遍历度数较小的顶点的邻接链表。选择度数较小的顶点能加速查找，因为度数较小的顶点的邻接链表较短，遍历时会更高效。
  2. **遍历邻接链表**：在选择的邻接链表中，逐一检查其中的边是否连接到另一个顶点 **`v2`**。如果找到了对应的边，则说明这两个顶点是相连的。
- **时间复杂度**：查找相邻顶点的操作的时间复杂度为 **O(deg(v))**，其中 **deg(v)** 是选定顶点的度数，即与该顶点相连的边的数量。

### 2. **图的结构（右侧示意图）**：

- **邻接表**存储了每个顶点与其他顶点的连接信息。例如，顶点 `u` 的邻接链表中包含了指向顶点 `v` 和 `w` 的指针，表示顶点 `u` 与顶点 `v` 和 `w` 有边相连。
- **边表**中的每一条边被指针链接到顶点的邻接链表中，这样可以通过指针直接访问边，避免了重复存储边的信息。

### 3. **如何操作**：

- 例如，如果我们要判断顶点 **`u`** 和 **`z`** 是否相邻，首先我们选择度数较小的顶点 **`z`**（因为 `z` 的度数是 1，而 `u` 的度数是 2）。然后，我们遍历 **`z`** 的邻接链表，检查它是否与 **`u`** 连接。
  - 在图中，**`z`** 与 **`w`** 相连，而 **`w`** 又与 **`u`** 相连，所以 **`u`** 和 **`z`** 之间没有直接的边。

### 4. **总结**：

- **查找最小度数顶点**：通过选择度数较小的顶点来优化查找过程。
- **高效的相邻判断**：通过遍历邻接链表和边指针连接，可以高效地判断两个顶点是否相邻。
- **时间复杂度**：该操作的时间复杂度是 **O(deg(v))**，即与度数较小的顶点的度数成正比。

这种方法通过指针和优化策略，使得图的查询操作更高效，尤其是当图中包含大量顶点时，查找相邻顶点的效率得到了很大的提升。

![image-20250411145625916](./READEME7.assets/image-20250411145625916.png)

这张图展示了如何在**邻接表（Adjacency List）**中实现**添加边（insertEdge）**的操作，并且说明了具体的步骤。

### 1. **`insertEdge(Vertex v1, Vertex v2, K key)` 操作**

这个方法的目的是向图中添加一条边，连接两个顶点 **`v1`** 和 **`v2`**。边的权重或其他信息通过 **`K`** 提供。

#### 步骤：

1. **将边添加到边表**：首先，我们需要在**边表（Edge List）**中添加这条边，记录两个端点 **`v1`** 和 **`v2`** 之间的边，并且存储边的权重 **`K`**。
2. **将边添加到两个邻接链表**：接下来，我们将这条边的信息添加到**顶点 `v1`** 和 **`v2`** 的邻接链表中。
   - 对于顶点 **`v1`**，我们将新边指向顶点 **`v2`** 和该边的权重 **`K`**。
   - 对于顶点 **`v2`**，我们将新边指向顶点 **`v1`** 和该边的权重 **`K`**。

通过这种方式，我们在**邻接链表**中同时维护了从 **`v1`** 到 **`v2`** 和从 **`v2`** 到 **`v1`** 的边信息，从而实现了**双向连接**。

### 2. **图示和箭头的说明**

- **箭头**表示从一个顶点到另一个顶点的边。在图中，红色箭头表示一条新添加的边，连接了顶点 **`u`** 和 **`v`**。同样的，其他箭头表示图中的现有边。
- 在边表中，边的信息（包括顶点对和权重）通过指针连接到邻接链表中的每个顶点。

### 3. **优化和连接方式**

- **通过指针连接**：在图中，边 **`\*a`**、**`\*b`** 等通过指针连接到相应的顶点的邻接链表节点，这样可以避免重复存储边的数据，只需在边表中存储一次即可。
- **双向添加**：每个边不仅在一个顶点的邻接链表中添加，也在另一个顶点的邻接链表中添加，确保图的连接是双向的。

### 4. **总结**

- **添加边**：通过 `insertEdge` 方法，边被添加到边表中，同时更新顶点的邻接链表。
- **双向图**：通过同时更新两个邻接链表，实现了无向图的双向连接。
- **指针连接**：通过指针连接，避免了冗余的存储，优化了空间使用。

这种方式使得图的操作更加高效，特别是在添加边时，能够通过指针快速访问并更新相应的结构。

![image-20250411145821242](./READEME7.assets/image-20250411145821242.png)

这张图展示了如何在**邻接表（Adjacency List）\**中实现\**插入边（insertEdge）\**的操作，并讲解了如何使用\**指针**和**数组**来优化该操作的效率。

### 1. **`insertEdge(Vertex v1, Vertex v2, K key)` 操作**

这个方法用于向图中添加一条边，连接顶点 **`v1`** 和 **`v2`**，并为该边赋予权重或其他信息 **`K`**。

#### 步骤：

1. **将边添加到边表**：
   - 这一步骤将边 **`v1`** 和 **`v2`** 的连接信息（包括权重 `K`）添加到边表中。
   - 由于在图的结构中，边是唯一的，因此边表中每条边只存储一次信息。
2. **将边节点添加到每个顶点的邻接链表**：
   - 对于顶点 **`v1`**，我们将新添加的边节点（指向 **`v2`**）插入到顶点 **`v1`** 的邻接链表中。
   - 对于顶点 **`v2`**，同样地，我们将新添加的边节点（指向 **`v1`**）插入到顶点 **`v2`** 的邻接链表中。
   - **注**：这使得图成为**无向图**，即每条边在两个方向上都可被访问。
3. **连接所有三个结构（边表和两个邻接链表）**：
   - 通过使用指针，边表中的每一条边都会与顶点的邻接链表节点相连。这样，当我们查看一个顶点的邻接链表时，可以通过指针直接访问相关的边。

### 2. **时间复杂度分析**

- **O(1) 操作**：每个操作（添加到边表、添加到邻接链表、连接指针）都是常数时间操作，即 **O(1)**。因此，这些操作的时间复杂度是常数级的，意味着它们不随图的大小变化而增加。
- **图形表示（数组形式）**：
  - **左侧图示**：图中的顶点和边通过邻接链表和边表连接。每个顶点的邻接链表节点指向一个边（如 `*a`, `*b`, `*c`, `*d`），而这些边又通过指针回到边表中。
  - **右侧图示**：这里通过数组的方式展示了顶点和边的存储方式。数组中的索引对应每个顶点，顶点和边之间的关系通过指针实现。数组展示了顶点的度数和指向其他顶点的边的信息。

### 3. **复杂度的描述**

- **O(1) 最常见的时间复杂度**：
  - 对于添加边的操作，绝大多数情况都在常数时间内完成。
  - 这意味着，除了在某些极端情况下（例如，图的大小变化非常大，或者有一些特殊的边处理情况），大多数操作的时间复杂度是 **O(1)**。
- **O(n) 在极端情况下**：
  - 在某些情况下（如图非常大，或操作非常复杂），时间复杂度可能会达到 **O(n)**，其中 **n** 是顶点的数量。
  - 但是，这种情况是少数，因此通常我们认为 **O(1)** 是主流情况。

### 4. **总结**

- **插入边**：通过 `insertEdge` 方法，可以非常高效地在图中添加一条边，并且保持顶点和边之间的联系。
- **指针优化**：通过使用指针连接顶点和边，不仅节省了存储空间，也使得边的访问更加高效。
- **高效的时间复杂度**：整个操作的时间复杂度是 **O(1)**，使得图的更新和修改变得非常高效。

这种基于指针的结构优化了图的存储和操作，特别适合需要频繁插入和删除边的图结构。

![image-20250411150105284](./READEME7.assets/image-20250411150105284.png)

这张图展示了如何在**邻接表（Adjacency List）**中实现**删除边（removeEdge）**的操作，并详细说明了每个步骤的具体实现。

### 1. **`removeEdge(Vertex v1, Vertex v2, K key)` 操作**

这个方法用于删除连接顶点 **`v1`** 和 **`v2`** 的边，并且还涉及到删除边的权重或其他信息 **`K`**。

#### 步骤：

1. **查找度数较小的顶点**：
   - 首先，方法会根据两个顶点的度数（即每个顶点的度数）来选择一个度数较小的顶点进行遍历。这是为了优化查找效率，因为度数较小的顶点的邻接链表较短，遍历的次数会更少。
   - 查找操作的时间复杂度为 **O(deg(v))**，其中 **deg(v)** 表示顶点 **v** 的度数，即与该顶点相连的边的数量。
2. **查找三个位置**：
   - 通过选择度数较小的顶点，我们可以高效地找到 **`v1`** 和 **`v2`** 在图中的位置，并通过指针查找与 **`v1`** 和 **`v2`** 相关的边。由于边是双向的，删除边时要同时删除 **`v1`** 和 **`v2`** 的邻接链表中的边。
   - **双向边**：箭头表示边是双向的，即如果 **`v1`** 和 **`v2`** 之间有边，那么在 **`v1`** 的邻接链表和 **`v2`** 的邻接链表中都能找到对应的边。
3. **按顺序删除**：
   - 删除操作按以下顺序进行：
     1. **删除顶点 \**`v2`\** 的邻接链表中的边**：首先删除顶点 **`v2`** 的邻接链表中的指向 **`v1`** 的边。
     2. **删除边表中的边**：然后在边表中删除表示 **`v1`** 和 **`v2`** 之间的边。
     3. **删除顶点 \**`v1`\** 的邻接链表中的边**：最后，删除顶点 **`v1`** 的邻接链表中的指向 **`v2`** 的边。

- **删除操作的时间复杂度**：
  - 每个删除操作（查找和删除）都在常数时间内完成，时间复杂度为 **O(1)**。
  - 查找顶点位置的操作是 **O(deg(v))**，即与顶点的度数成正比。

### 2. **图示和箭头的说明**

- **箭头**表示了顶点与边之间的连接。红色箭头表示要删除的边。
- 在邻接链表中，每个顶点的邻接链表节点中保存了与其他顶点的连接信息，例如 **`\*a`**、**`\*b`**、**`\*c`**、**`\*d`** 等。

### 3. **总结**

- **删除边**：通过 `removeEdge` 方法，可以从邻接链表中删除一条边，并且同时更新边表，确保图的正确性。
- **双向边删除**：由于图是无向的，删除操作必须同时在两个顶点的邻接链表中删除边。
- **时间复杂度**：虽然操作的总体时间复杂度是 **O(deg(v))**，但每个具体的删除操作本身是常数时间的 **O(1)**。

这种结构通过优化删除操作，确保了图的高效更新。

![image-20250411150533333](./READEME7.assets/image-20250411150533333.png)

这张图展示了在**邻接表（Adjacency List）**中实现**删除边（removeEdge）**的操作，具体细节包括如何通过指针、遍历顶点的邻接链表来完成删除操作。

### 1. **`removeEdge(Vertex v1, Vertex v2, K key)` 操作**

这个方法用于删除连接顶点 **`v1`** 和 **`v2`** 的边，并且涉及删除边的权重或其他信息 **`K`**。

#### 步骤：

1. **查找度数较小的顶点**：
   - 首先，选择度数较小的顶点（即连接的边较少的顶点）来遍历。通过 **`deg(v)`**，我们可以找到度数较小的顶点，从而提高查找效率，因为度数较小的顶点的邻接链表较短。
   - 查找操作的时间复杂度是 **O(deg(v))**，其中 **deg(v)** 表示顶点 **`v`** 的度数。
2. **查找三个位置**：
   - 查找并定位三个位置：
     - **`v1`**：第一个顶点。
     - **`v2`**：第二个顶点。
     - **边**：连接 **`v1`** 和 **`v2`** 的边。
   - **双向边**：箭头的表示方式意味着边是双向的。如果 **`v1`** 和 **`v2`** 之间存在边，那么在 **`v1`** 和 **`v2`** 的邻接链表中都能找到该边。由于边是双向的，删除时需要在两个顶点的邻接链表中都删除。
3. **按顺序删除**：
   - 删除操作按以下顺序进行：
     1. **删除镜像边**：通过指针删除连接 **`v1`** 和 **`v2`** 的镜像边。
     2. **删除边表中的边**：然后在边表中删除表示 **`v1`** 和 **`v2`** 之间的边。
     3. **删除顶点 \**`v1`\** 和 \**`v2`\** 的邻接链表中的边**：最后，从 **`v1`** 和 **`v2`** 的邻接链表中删除该边。

### 2. **时间复杂度分析**

- **查找顶点**：找到度数较小的顶点后，查找操作的时间复杂度是 **O(1)**。
- **删除操作**：删除边和更新邻接链表的操作是 **O(1)**，每个删除操作的时间复杂度都是常数时间。

### 3. **图示和箭头的说明**

- **箭头**：表示顶点之间的边，红色箭头表示要删除的边。
- **双向指针**：通过指针将边和顶点连接。当删除一个边时，我们需要同时删除 **`v1`** 和 **`v2`** 的邻接链表中的指针，这确保了图的结构完整性。

### 4. **总结**

- **删除边**：通过 `removeEdge` 方法，我们可以高效地删除图中连接顶点 **`v1`** 和 **`v2`** 的边。
- **双向删除**：由于边是双向的，我们需要在 **`v1`** 和 **`v2`** 的邻接链表中同时删除该边。
- **时间复杂度**：由于删除操作是在常数时间内完成的，整体操作非常高效。

通过使用这种方法，我们能够确保图结构在删除边时保持高效和一致。

![image-20250411150914729](./READEME7.assets/image-20250411150914729.png)

这张图展示了如何在**邻接表（Adjacency List）**中实现**插入顶点（insertVertex）**操作。

### 1. **`insertVertex(K key)` 操作**

此方法用于在图中插入一个新的顶点，并初始化该顶点的邻接链表。

#### 步骤：

1. **将新顶点添加到哈希表**：
   - **哈希表**是用来存储图中所有顶点的快速查找结构。通过哈希表，我们可以 **O(1)** 时间复杂度快速查找、访问、插入新的顶点。
   - **哈希表的作用**：每个顶点都有一个唯一的哈希键，哈希表通过该键将顶点与它对应的邻接链表连接起来。图中的每个顶点都会有一个与之关联的邻接链表，用来存储与该顶点相连的边。
2. **添加一个新的空链表**：
   - 在哈希表中为新顶点分配一个空的邻接链表。这个链表初始时为空，表示该顶点尚未与其他顶点建立连接。我们将来会通过 `insertEdge` 操作来向该链表中添加边。
3. **时间复杂度**：
   - 由于 **哈希表的查找和插入操作都是 O(1)**，所以 **插入顶点**的时间复杂度为 **O(1)**。

### 2. **图示解释**

- **顶点和邻接链表**：
  - 每个顶点（如 **u, v, w, z**）都有一个对应的邻接链表。例如，顶点 **u** 的邻接链表为空，因为它尚未与其他顶点建立连接。
  - 新添加的顶点 **x** 会被插入到哈希表中，且它的邻接链表也为空。

### 3. **总结**

- **`insertVertex`** 操作的主要作用是向图中添加一个新顶点，并初始化其邻接链表。
- **哈希表**和**空链表**的使用使得操作非常高效。
- **时间复杂度**是 **O(1)**，因为我们直接在哈希表中查找并插入新顶点。

这种方法是构建动态图的基础，可以在图中不断添加新顶点。

![image-20250411151117482](./READEME7.assets/image-20250411151117482.png)

这张图展示了**插入顶点（insertVertex）**操作在**邻接表（Adjacency List）**中的实现过程。

### 1. **`insertVertex(K key)` 操作**

此操作的目的是在图中添加一个新的顶点，并为该顶点初始化一个空的邻接链表。

#### 步骤：

1. **添加新顶点**：
   - 首先，会向图的结构中添加一个新顶点。该顶点的标识符是通过 **K key** 来提供的。
2. **初始化一个空的邻接链表**：
   - 对于每个新添加的顶点，我们为其分配一个空的邻接链表。这意味着该顶点初始时没有与其他顶点相连。
   - 这个空链表将在以后通过添加边 (`insertEdge`) 来填充。

### 2. **图示解释**

- 图中显示了一个图的结构，其中有四个顶点（**u, v, w, z**）和它们之间的连接。
- 在执行 `insertVertex` 操作时，一个新的顶点会被添加到图中，并为该顶点创建一个空的邻接链表。
- 图中的邻接链表被表示为指向其他顶点的指针（例如，**u** 连接到 **v** 和 **w**，并且这些连接会被添加到 **u** 的邻接链表中）。

### 3. **总结**

- **`insertVertex`** 方法的作用是：
  - 向图中添加一个新的顶点，
  - 并为这个顶点初始化一个空的邻接链表。
- 由于 **哈希表** 和 **邻接链表** 的使用，这个操作的时间复杂度是 **O(1)**。

通过这种方法，图的结构能够灵活扩展，并且能够高效地添加新的顶点及其连接。

![image-20250411151200171](./READEME7.assets/image-20250411151200171.png)

这张图展示了如何在**邻接表**（Adjacency List）中执行**删除顶点（removeVertex）**操作的过程。

### **操作步骤**

1. **查找顶点 `v`（O(1)）**：
   - 首先，我们需要找到要删除的顶点 `v`。
   - 通过直接访问哈希表中的顶点 `v`，查找的时间复杂度是 **O(1)**。
2. **遍历并删除与 `v` 相关的所有边**：
   - 一旦找到了顶点 `v`，接下来我们需要删除与 `v` 相关的所有边（与 `v` 相连接的边）。
   - 这涉及到以下几个步骤：
     - **删除 `v` 在每个邻接链表中的指针**。
     - **删除每条边**。
     - **删除 `v` 对应的邻接链表中的指针**。
   - 由于每个顶点最多有 `deg(v)` 个邻居，因此删除操作的时间复杂度是 **O(deg(v))**。

### **解释**

1. **删除操作细节**：
   - 对于每个连接到 `v` 的邻接顶点（例如图中的 `u`, `w`, `z`），我们需要在邻接链表中删除指向 `v` 的边。通过指针的操作，可以很快完成这些删除。
   - 在图示中，箭头表示删除的方向，尤其是指向边和指针的删除。
2. **删除顶点的时间复杂度**：
   - 查找顶点 `v` 需要 **O(1)**。
   - 删除与 `v` 相关的边需要 **O(deg(v))**，其中 `deg(v)` 是顶点 `v` 的度，即与 `v` 连接的边的数量。
3. **图示解释**：
   - 顶点 `u`、`v`、`w`、`z` 的邻接链表通过箭头相连，每个箭头代表顶点之间的边。
   - 删除顶点 `v` 后，邻接链表中与 `v` 相关的连接被断开（删除）。

### **总结**

`removeVertex` 操作的时间复杂度为 **O(deg(v))**，因为删除一个顶点的过程包括遍历它的所有邻接顶点并删除相应的连接。由于图的度数 `deg(v)` 决定了需要删除的边的数量，操作的性能依赖于顶点的度数。

![image-20250411151440177](./READEME7.assets/image-20250411151440177.png)

这张图比较了三种图的实现方式——**Edge List（边表）**、**Adjacency Matrix（邻接矩阵）** 和 **Adjacency List（邻接表）**——的不同操作的时间复杂度和空间复杂度。

### 1. **空间复杂度（Space Complexity）**

- **Edge List（边表）**：空间复杂度是 **n + m**，其中 `n` 是顶点的数量，`m` 是边的数量。每个顶点与它相关的边存储在边表中，因此它需要存储顶点和边。
- **Adjacency Matrix（邻接矩阵）**：空间复杂度是 **n²**，因为邻接矩阵是一个 `n x n` 的二维矩阵，用来存储所有可能的边，即使某些边可能不存在，依然会分配空间。
- **Adjacency List（邻接表）**：空间复杂度是 **n + m**，因为每个顶点需要一个链表来存储它的邻接顶点，整体上空间利用比邻接矩阵高效。

### 2. **`insertVertex(v)` 操作**

- **Edge List（边表）**：插入一个新顶点的时间复杂度是 **O(1)**，只需要将顶点添加到顶点列表中即可。
- **Adjacency Matrix（邻接矩阵）**：由于是二维矩阵，插入新顶点时需要扩展矩阵，因此时间复杂度是 **O(n)**。
- **Adjacency List（邻接表）**：插入新顶点时只需要在哈希表中添加一个新的条目和一个空的链表，时间复杂度为 **O(1)**。

### 3. **`removeVertex(v)` 操作**

- **Edge List（边表）**：删除一个顶点需要遍历所有边，查找与该顶点相关的边，时间复杂度是 **O(n + m)**。
- **Adjacency Matrix（邻接矩阵）**：删除顶点需要将矩阵中对应的行和列删除，时间复杂度是 **O(n)**。
- **Adjacency List（邻接表）**：删除顶点时，我们需要删除与顶点相关的所有边，并修改其他相关链表中的指针，时间复杂度是 **O(deg(v))**，其中 `deg(v)` 是顶点的度数。

### 4. **`insertEdge(u, v)` 操作**

- **Edge List（边表）**：插入一条边时，只需要将新边添加到边表中，时间复杂度是 **O(1)**。
- **Adjacency Matrix（邻接矩阵）**：插入一条边需要在矩阵中更新相应的位置，时间复杂度是 **O(1)**。
- **Adjacency List（邻接表）**：插入一条边时需要将该边加入两个顶点的邻接链表，时间复杂度是 **O(1)**。

### 5. **`removeEdge(u, v)` 操作**

- **Edge List（边表）**：删除一条边需要遍历整个边表，查找并删除目标边，时间复杂度是 **O(m)**。
- **Adjacency Matrix（邻接矩阵）**：删除一条边需要在矩阵中查找并删除相关项，时间复杂度是 **O(1)**。
- **Adjacency List（邻接表）**：删除一条边时，通过指针直接删除链表中的元素，时间复杂度是 **O(min(deg(u), deg(v)))**，这里 `deg(u)` 和 `deg(v)` 是顶点 `u` 和 `v` 的度数。

### 6. **`incidentEdges(v)` 操作**

- **Edge List（边表）**：查找顶点 `v` 的所有边时，需要遍历所有边，时间复杂度是 **O(m)**。
- **Adjacency Matrix（邻接矩阵）**：查找顶点 `v` 的所有边需要遍历矩阵中的行，时间复杂度是 **O(n)**。
- **Adjacency List（邻接表）**：查找顶点 `v` 的所有边直接遍历 `v` 的邻接链表，时间复杂度是 **O(deg(v))**，即顶点 `v` 的度数。

### 7. **`areAdjacent(u, v)` 操作**

- **Edge List（边表）**：检查两个顶点是否相邻需要遍历所有边，时间复杂度是 **O(m)**。
- **Adjacency Matrix（邻接矩阵）**：通过查找矩阵中的特定位置判断两个顶点是否相邻，时间复杂度是 **O(1)**。
- **Adjacency List（邻接表）**：需要遍历一个顶点的邻接链表来检查是否有相邻的顶点，时间复杂度是 **O(min(deg(u), deg(v)))**。

### 总结

- **Edge List（边表）** 是空间最为节省的实现方式，适用于稀疏图，但进行插入、删除操作时的时间复杂度相对较高。
- **Adjacency Matrix（邻接矩阵）** 提供了高效的边查找操作，但需要大量的空间来存储完整的矩阵，适用于稠密图。
- **Adjacency List（邻接表）** 是空间和时间效率的折衷，特别适用于稀疏图，可以快速进行插入、删除操作。

![image-20250411151548186](./READEME7.assets/image-20250411151548186.png)

这张图片讲解了 **图遍历** 的问题。图遍历指的是在图中按一定顺序访问每一个节点。该图指出了图遍历中的一些挑战，并且解释了为什么在处理复杂图时传统的树遍历方法可能不适用。

### 主要观点：

1. **图的无序性**：
   - 图不像树一样具有明确的顺序或者层次结构。在树中，我们可以通过简单的深度优先遍历（DFS）或者广度优先遍历（BFS）来访问节点，但图有更多的连接，特别是当图是 **有环的** 或者 **非有根的** 时，这些遍历方法会变得复杂。
2. **树遍历与图遍历的区别**：
   - 树是 **有根的**（即有明确的起点），并且 **无环**（没有环路）。
   - 但在图中，我们没有固定的起点，且可能存在 **环路**，使得传统的树遍历方法（例如DFS、BFS）可能会在图中不断重复访问相同的节点。
3. **问题的核心**：
   - 如何在图中有效、系统性地遍历，并且用最少的步骤来访问所有节点。
   - 为了解决这个问题，树遍历方法将无法适用，因为图可能没有树的结构特性（如无环、根节点等）。

### 结论：

- 在图的遍历中，需要采用特殊的策略来处理 **循环** 和 **无根结构**，例如使用标记来避免循环或选择合适的遍历方法，如改进的DFS或BFS。

![image-20250411151654791](./READEME7.assets/image-20250411151654791.png)

这张图片展示了图遍历的挑战，并解释了为何传统的树遍历方法不适用于图。以下是详细的解释：

### 目标：

**遍历图中的每个顶点和每条边**，这是图遍历的主要目标。我们需要一种方法，系统性地访问图中的所有节点和边，并且尽量减少步骤。

### 问题：

如何在图中有效地遍历所有顶点和边，尤其是当图结构复杂时？传统的树遍历方法（如深度优先遍历DFS和广度优先遍历BFS）可能并不适用。

### 树与图的不同：

- **树遍历不能使用**：
  - **树的特点**：树是 **有根的**（有一个明确的起点），**无环**（没有环路），并且通常有一个明确的 **终点**。
  - **图的特点**：图通常是 **无根的**，可能包含 **环路**，并且没有一个明确的起点或终点，因此传统的树遍历方法在图中可能无法有效地执行。

### 比较：

- **树的特点**：
  - 有根（从根节点开始遍历）
  - 无环（没有环）
  - 有明确的终点（遍历可以从根到叶子）
- **图的特点**：
  - 没有固定的根节点（可以从任何一个节点开始遍历）
  - 可能包含环路（形成回路）
  - 没有明显的终点（可能会存在多个连接点，难以确定最终的遍历顺序）

### 结论：

图的遍历方法需要考虑图的无根、可能存在环路以及没有明显终点的特点，这就要求我们采用更灵活的遍历策略，而不是传统的树遍历方法。

![image-20250411151742071](./READEME7.assets/image-20250411151742071.png)

这张图片展示了 **广度优先搜索（BFS）** 算法的代码实现以及该算法在图中的应用。以下是详细解释：

### **BFS算法**（广度优先搜索）:

广度优先搜索（BFS）是一种图遍历算法，旨在从某一顶点开始，逐层探索图中的所有顶点。BFS会遍历图中每一层的节点，先访问离起始节点最近的节点，然后再访问更远的节点。算法通过使用队列来保证按照层次访问每个节点。

### **BFS代码解释**：

1. **初始化**：
   - **初始化队列** `q`，并将起始节点 `v` 放入队列。
   - 设置该节点的距离 `setDist(v, 0)` 为0，表示从起始节点到该节点的距离是0。
2. **遍历图**：
   - 循环遍历队列中的所有节点。每次从队列中取出一个节点 `v`。
3. **访问邻接节点**：
   - 对于每个与当前节点 `v` 相邻的节点 `w`，进行检查。
   - 如果 `w` 尚未访问过（即 `getDist(w) == -1`），则：
     - 设置其状态为“发现”(`setLabel((v, w), DISCOVERY)`)，表示 `w` 作为新发现的节点加入了图的遍历。
     - 将 `w` 加入队列。
     - 设置 `w` 的父节点为 `v`（`setPred(w, v)`），表示从 `v` 到 `w`。
     - 设置 `w` 的距离为 `v` 的距离加一（`setDist(w, v + 1)`）。
   - 如果 `w` 已经访问过（即 `getDist(w) != -1`），则说明该边是一个回边或横切边，标记为 "CROSS"（交叉边）。
4. **最终状态表**：
   - 表格显示了每个顶点的探索顺序、父节点、距离和相邻的边（邻接边）。

### **图示说明**：

- **A - B - C - A** 表示从节点 `A` 到 `B` 再到 `C`，然后又回到 `A`，形成一个环。
- **A - B - C - D - A** 描述了从 `A` 到 `B`、`C`，再到 `D`，最终回到 `A` 的路径。
- **边分类**：
  - **发现边**（Discovery Edge）：新发现的节点（如 `A` 到 `B`）。
  - **横切边**（Cross Edge）：已访问过的节点之间的边（如 `C` 到 `A`）。

### **图遍历输出**：

- 每个节点的编号和颜色表示该节点在遍历中的发现顺序。
- 交叉边（如 `A - C`）在表格中标记为 "CROSS"。