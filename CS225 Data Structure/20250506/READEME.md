![0eb75992e5ff9823f46b30156e6bf7c](./READEME.assets/0eb75992e5ff9823f46b30156e6bf7c.jpg)

这张图片是关于你这门课的 **期末考试说明（Final Exam）**。下面是详细解释：

------

### **考试安排**

- **考试时间：** 1小时50分钟
- **题型：** 包含编程题（coding）和理论题（theory），和之前考试类似
- **特别说明：** **期末考试中不会有自由回答题（free response question）**，意思是你不需要写长篇解释，只需要选择、计算或编程作答。

------

### **考试内容（Topics Covered）**

期末考试是**综合性的（comprehensive）**，包含：

1. **所有之前考试中的内容**
2. **加上以下新的内容：**

#### **概率数据结构（Probabilistic Data Structures）**

这些是**节省空间但有容错的近似算法和结构**，常用于大数据中快速判断。

- **Bloom Filters（布隆过滤器）**
  - 一种用位数组和多个哈希函数判断某元素是否“可能存在”于集合中的结构。
  - 特点：有**假阳性**（可能错误地认为存在），但**不会有假阴性**。
  - 常用于快速网页黑名单检测、数据库缓存等。
- **Cardinality Estimation（基数估计）**
  - 用于估算**一个集合中不同元素的数量**。
  - 例如 HyperLogLog 算法可在小内存中估算百万级唯一用户数量。
- **Minhash Sketching**
  - 用于快速估算两个集合的相似度（例如网页去重）。
  - 用哈希方式近似 Jaccard 相似度。

------

### **总结**

这门期末考试将：

- 覆盖整个学期的知识点（所有作业和考试）
- 重点加入“概率数据结构”这类新知识
- 不包含长答案题，只考代码和理论选择/计算题

------

你是否需要我帮你复习其中某一部分，例如布隆过滤器的原理或 Minhash 的具体算法？我可以给你例子、图示或习题。

![2b1efeeb442ca10300447095b50e7e1](./READEME.assets/2b1efeeb442ca10300447095b50e7e1.jpg)

这是一个关于 **Jaccard 相似度（Jaccard similarity）** 的考试题目。下面是详细解释和计算过程：

------

### **题目意思：**

你被给了两个集合：

- `S1 = {0, 4, 6, 7, 8, 9}`
- `S2 = {1, 2, 3, 4, 5}`

**问题：** 这两个集合的 **Jaccard 相似度** 是多少？

------

### **什么是 Jaccard 相似度？**

Jaccard 相似度是用于衡量两个集合相似程度的指标，定义为：

$\text{Jaccard}(A, B) = \frac{|A \cap B|}{|A \cup B|}$

即：**交集的大小除以并集的大小**

------

### **具体计算步骤：**

1. **交集**（两个集合都包含的元素）：

$S1 \cap S2 = \{4\} \Rightarrow |交集| = 1$

1. **并集**（两个集合的所有元素去重）：

$S1 \cup S2 = \{0,1,2,3,4,5,6,7,8,9\} \Rightarrow |并集| = 10$

1. **计算 Jaccard 相似度：**

$\text{Jaccard}(S1, S2) = \frac{1}{10} = 0.1$

------

### **答案填写：**

你应该在输入框里填入：

```
0.1
```

------

### **总结**

- Jaccard 相似度是交集除以并集
- 本题中，两个集合交集只有一个元素（4），并集共有10个不同的元素
- 所以相似度是 **0.1**

是否需要我给你准备一两个类似的练习题来巩固这个概念？

![6d7598211ae41f45e1a213c15a208dc](./READEME.assets/6d7598211ae41f45e1a213c15a208dc.jpg)

这是一个关于 **Bloom Filter 构建** 的选择题，要求你根据给定数据集和哈希函数，判断哪一个 Bloom Filter 是正确的。下面是**详细解释与解题步骤**：

------

## **题目结构说明**

- **数据集：** `[4, 5, 7, 8]`
- **哈希函数（两个）**：
  - `h1(x) = x % 7`
  - `h2(x) = (2 * x + 3) % 7`
- **布隆过滤器大小：7 位（二进制数组）**

------

## **Bloom Filter 工作原理**

对于每个元素，计算所有的哈希函数位置，并将对应位置设为 `1`。

例如：对于 `x = 4`，

- `h1(4) = 4 % 7 = 4`
- `h2(4) = (2*4 + 3) % 7 = 11 % 7 = 4`

Bloom filter 中索引 4 设为 `1`

------

## **对每个元素进行计算**

### 1. **x = 4**

- h1(4) = 4
- h2(4) = (8 + 3) % 7 = 11 % 7 = **4** → 设置 bit[4] = 1

### 2. **x = 5**

- h1(5) = 5
- h2(5) = (10 + 3) % 7 = 13 % 7 = **6** → 设置 bit[5] = 1，bit[6] = 1

### 3. **x = 7**

- h1(7) = 7 % 7 = 0
- h2(7) = (14 + 3) % 7 = 17 % 7 = **3** → 设置 bit[0] = 1，bit[3] = 1

### 4. **x = 8**

- h1(8) = 8 % 7 = 1
- h2(8) = (16 + 3) % 7 = 19 % 7 = **5** → 设置 bit[1] = 1，bit[5] = 1（已设）

------

## **构建最终 Bloom Filter**

我们设为 1 的位置是：

- bit[0] （来自 7）
- bit[1] （来自 8）
- bit[3] （来自 7）
- bit[4] （来自 4）
- bit[5] （来自 5, 8）
- bit[6] （来自 5）

因此结果是：

```
[1, 1, 0, 1, 1, 1, 1]
```

------

## **答案：**

正确选项是 **(c)**

------

## **总结**

- Bloom Filter 对每个值应用所有哈希函数；
- 每个哈希函数返回的位置设为1；
- 最终结果是 `[1, 1, 0, 1, 1, 1, 1]` → 选项 **(c)**

要不要我再帮你练一题类似的，或者解释布隆过滤器的应用原理？

![ee0d8e24e4e842598f21073d4ffad46](./READEME.assets/ee0d8e24e4e842598f21073d4ffad46.jpg)

这是一个关于 **Bloom Filter 查询（find）操作** 的题目。你需要判断哪些选项在布隆过滤器中会返回 **"true"（可能存在）**。

------

### **题目结构说明**

- **布隆过滤器大小：** 10 位

  ```
  [1, 1, 1, 0, 0, 1, 0, 1, 1, 0]
   0  1  2  3  4  5  6  7  8  9 ← 索引
  ```

- **哈希函数：**

  - `h1(x) = x % 10`
  - `h2(x) = (3 * x + 1) % 10`

- **选项（要检查的数字）：** `9`, `7`, `4`, `3`

------

### **Bloom Filter 查找原理**

要查一个数是否“可能存在”，你需要：

- 用所有哈希函数算出索引；
- 如果这些位置在布隆数组中全是1 → 返回 **True（可能存在）**；
- 如果有一个位置是0 → 返回 **False（确定不存在）**

------

### **逐项检查**

#### **(a) 9**

- h1(9) = 9 % 10 = **9** → Bloom[9] = 0
- h2(9) = (3×9 + 1) % 10 = 28 % 10 = **8** → Bloom[8] = 1 → **9 返回 False（不在）**

#### **(b) 7**

- h1(7) = 7 % 10 = **7** → Bloom[7] = 1
- h2(7) = (3×7 + 1) % 10 = 22 % 10 = **2** → Bloom[2] = 1
   → **7 返回 True（可能存在）**

#### **(c) 4**

- h1(4) = 4 → Bloom[4] = 0
- h2(4) = (3×4 + 1) = 13 % 10 = **3** → Bloom[3] = 0
   → 有两个位置都是0 → **False**

#### **(d) 3**

- h1(3) = 3 → Bloom[3] = 0
- h2(3) = (9 + 1) = 10 % 10 = **0** → Bloom[0] = 1
   → 其中一位为0 → **False**

------

### **答案是：**

→ 只有 **(b) 7** 会被 `find()` 判断为“可能存在”
 所以你应该只勾选：

```
(b)
```

------

### **总结：**

- 布隆过滤器返回 True 只有在所有哈希位都为 1 时
- 否则就是一定不在（False）
- 本题答案是 **(b) 7**

需要我帮你写一个简单 Python 程序来模拟这个过程练习吗？