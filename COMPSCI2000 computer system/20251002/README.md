![image-20251003104311333](README.assets/image-20251003104311333.png)

下面这张图讲的是**哈佛结构（Harvard Architecture）**——一种计算机/微控制器的硬件架构。

# 这张图在说什么

中间是**控制单元（Control Unit）**，上方是**算术逻辑单元 ALU**，下方是**输入/输出 I/O**。左右各有一块独立的存储器：

- **Instruction memory（指令存储器）**：只放“程序指令”（机器码）。
- **Data memory（数据存储器）**：只放“数据”。

黄色箭头表示它们与控制单元之间有**各自独立的总线/通道**。这就是哈佛结构的核心：**指令和数据分开存、分开走**。

# 和传统“冯·诺依曼结构”的区别

- **冯·诺依曼结构**：指令和数据**共用一套内存和总线**，同一时间只能传一种（要么取指令，要么取数据），容易出现“冯·诺依曼瓶颈”（总线成了堵点）。
- **哈佛结构**：指令通道、数据通道**分离**，可以**并行**地一边取下一条指令，一边访问数据，吞吐量更高、时序更稳定。

# 图中各模块的作用

- **Control Unit 控制单元**：按照“取指—译码—执行”的节奏协调一切。
- **ALU**：做加减乘除、与或非、比较等运算。
- **Instruction memory**：只读或主要只读（有时是闪存/ROM），存放固化的程序。
- **Data memory**：读写型（如 SRAM），存放变量、栈、缓冲区等。
- **I/O**：和外设打交道（串口、GPIO、传感器、网卡等）。

# 它是怎么工作的（简化的取指-执行循环）

1. **取指（从指令存储器）**：控制单元通过“指令总线”把下一条指令取来并译码。
2. **取数/写回（从数据存储器）**：若指令需要数据，控制单元同时通过“数据总线”去读/写数据。
3. **ALU 执行**：进行运算，结果再通过数据通道写回数据存储器或寄存器。
    → 因为两条通道互不抢占，可实现**流水化**与**单周期/多周期**指令的高效组合。

# 为什么要这么设计（优点）

- **吞吐量更高**：取指与取数可并行，缓解总线瓶颈。
- **实时性/确定性更好**：嵌入式系统常要严格的时序保证。
- **安全性更强**：数据内存里的内容默认不能当指令执行，降低某些代码注入风险。
- **适合固定程序的设备**：例如把固件烧在指令闪存中，数据放在独立 RAM 中。

# 可能的代价（缺点）

- **硬件更复杂**：两套总线/控制逻辑，面积与成本上升。
- **灵活性差一些**：数据不能直接当代码执行，“自修改代码”“JIT”会更麻烦。
- **地址空间割裂**：指令区与数据区分开，程序与常量共享不如统一内存方便（通常用专门指令把常量从指令区拷到数据区）。

# 常见在哪

- **微控制器/单片机**：如 AVR、PIC、部分 ARM Cortex-M 的内部设计、很多 DSP 都采用或借鉴哈佛结构思想。
- **数字信号处理器（DSP）**：追求高吞吐与确定性时序，更偏爱哈佛或**改良哈佛结构**。
- **现代通用 CPU**：主存通常统一，但**缓存层面**常用“改良哈佛结构”（指令缓存和数据缓存分离、主存统一），兼顾性能与灵活性。

# “改良哈佛结构”（Modified Harvard）

实际工程中常见折中：**L1 I-Cache 与 D-Cache 分离**，到更下层（L2/内存）再统一。这样既有哈佛的并行取指/取数优势，又保留统一内存带来的通用性。

# 一个生活类比（帮助直观理解）

- 冯·诺依曼：一条车道同时跑送餐车（数据）和送菜单的车（指令），只能排队轮流进出。
- 哈佛：两条独立车道，送菜单与送餐**同时进行**，出餐速度更稳定。

# 小结

这页讲的是：**哈佛结构把“程序指令”和“数据”在硬件层面彻底分离**，用各自的存储器与总线连接到控制单元/ALU，从而**并行取指与取数**、提高吞吐与实时性；代价是硬件更复杂、灵活性差一些。很多嵌入式与 DSP 直接采用它，而现代 CPU 多在缓存层面采用“改良哈佛”。

![image-20251003104455272](README.assets/image-20251003104455272.png)

下面这页讲的是课程里要动手搭建的**Hack 计算机**（来自 Nand2Tetris）。它是一台极简但完整的可运行机器。

# 总体特性

- **16 位平台**：数据宽度、指令宽度都是 16 bit。
- **（概念上）冯·诺依曼平台**：程序通过统一的指令集去**访问数据内存**来计算。
- **（物理上）指令存储与数据存储分离**：执行时从**指令 ROM（ROM32K）**取指；读写发生在**数据 RAM（RAM16K）**与外设映射区；两者走不同通道，取指与取数可以并行。（可把它理解为“改良哈佛”实现。）
- **屏幕**：**512 行 × 256 列，黑白**，1 像素=1 位，由内存映射控制。
- **键盘**：标准 ANSI 104 键，通过内存映射读键值。
- **指令集**：运行 **Hack 机器语言**（两类指令：A 指令、C 指令）。
- **可从课程前面搭的芯片集合直接拼起来**：ALU、寄存器、PC、内存、控制逻辑等。

# 组成部件（与图对应）

1. **Instruction memory（指令存储，ROM32K）**
   - 只读，存放程序的机器码。由 **PC**（程序计数器）给地址，CPU每拍从这里取下一条指令。
2. **Memory（数据存储，RAM）**
   - **Data memory（RAM16K）**：变量、栈、临时数据等。
   - **Screen（屏幕内存映射，8K 字）**：写入这里的比特直接变成屏幕像素。
   - **Keyboard（键盘内存映射，1 个寄存器）**：读取可得到当前按键的扫描码。
3. **CPU**
   - 核心含：**ALU**、**A 寄存器**、**D 寄存器**、**PC** 和控制单元。
   - **A 寄存器**既可当通用寄存器，也充当**数据/指令地址**（如 `@value` 把值装入 A）。
   - **D 寄存器**主要参与运算与暂存。
   - **PC**顺序+1或根据跳转条件改写，实现流程控制。
4. **“Computer/Glue Logic”**
   - 连接 CPU、ROM、RAM/外设映射与总线的外围逻辑，让整机协同工作。

# 内存映射（非常关键）

Hack 的 16 位地址空间被这样约定（单位：**字**，1 字 = 16 位）：

- **0 ~ 16383**：`RAM[0..16383]` → 数据区（16K 字）
- **16384 ~ 24575**：`SCREEN` → 屏幕映射区（**8K 字**；因为 512×256=131072 像素=131072 位=8192 字）
- **24576**：`KBD` → 键盘寄存器（读当前键值；无键为 0）
- **指令 ROM**：独立的 `ROM[0..32767]`（最多 32K 条指令），由 PC 寻址

> 例子：要把屏幕左上角点亮，只需把 `SCREEN` 基地址处的某一位写成 1；读取键盘是否按下，就读地址 `KBD`。

# 指令概览（你看到“Hack machine language”指的就是它）

- **A 指令**：`@value`
  - 把常数/地址装入 **A 寄存器**（例如 `@24576` 表示后续要访问键盘寄存器）。
- **C 指令**：`dest=comp;jump`
  - 用 ALU 计算（如 `D=A+D`、`M=D|M` 等），把结果写到 `dest`（`A/D/M` 的组合）；可选 `jump` 根据 ALU 标志位跳转（改 PC）。

# 为什么要这样设计

- **教学友好、硬件可实现**：分开 ROM/RAM 让电路简单、时序清晰。
- **效率与确定性**：取指、访存互不抢占；内存映射让外设像普通内存一样读写。
- **可完整跑程序**：虽然极简，但已具备标准计算机所需的取指—译码—执行—访存—跳转的全闭环。

# 一段“运行时”心智模型

1. PC 给出指令地址 → ROM 吐出 1 条 16 位指令；
2. 控制单元按指令译码：
   - 需要数据就用 **A** 里的地址去访问 RAM/映射区（读或写）；
   - 用 **D/ALU** 做计算；
3. 更新 **dest**、更新 **PC**（顺序或跳转）→ 进入下一拍。

这就是这页在讲的 Hack 计算机：一台**16 位、指令与数据物理分离**的小型机器，具备屏幕与键盘的**内存映射 I/O**，执行两类简单指令，却能组合出完整程序与图形/交互功能。

![image-20251003104844885](README.assets/image-20251003104844885.png)

这页在讲 **Hack 计算机的“指令存储器”（Instruction memory）**，也就是图里那块 **ROM32K**。

# 它是什么

- **ROM（Read-Only Memory）只读存储器**：用来放“程序”。运行时**CPU只读不写**。
- **32K × 16 位**：共 **32768 条**指令位置（地址从 0 到 32767），每个位置存放 **1 条 16 位机器指令**。

# 接口与行为（图上两根箭头）

- **address（15 位输入）**：告诉 ROM 要读第几个指令位置。
   15 位能表示 0..32767，所以是 32K 条。
- **out（16 位输出）**：把 `address` 指定位置的 **16 位内容**送出来。
   用一句话表示就是：
   **`out = ROM32K[address]`**
   这 16 位数就是**当前要执行的指令**。

> 这个 ROM 在逻辑上是**组合逻辑**：没有写入口、也没有时钟，地址一给，输出就等于对应存储的那条指令。

# 谁来给 address？

- 是 **PC（Program Counter，程序计数器）**。
- 运行流程（简化）：
  1. 复位后 PC=0，ROM 输出第 0 条指令；
  2. CPU 译码执行；
  3. **PC+1**（顺序执行）或根据跳转把 **PC 改成别的地址**；
  4. ROM 立刻按新地址输出下一条指令。
- 只要 PC 不越界，程序就一条接一条地从 ROM 里“被取出”。

# “预加载”的意思

- **ROM 事先被写入了 Hack 机器语言编译出的 16 位码**（课程里是把 `.hack` 文件“加载到 ROM32K”）。
- 真机里这通常对应 **闪存/EPROM**：上电前烧进去；要换程序，就重新烧录。

# 和数据内存（RAM）的区别

- **ROM**：只读、放指令、由 **PC** 寻址；CPU不写它。
- **RAM**：可读写、放变量/栈/屏幕映射/键盘寄存器等，由 **A 寄存器里的地址** + 控制信号读写。

# 限制与注意

- **程序长度最多 32K 条指令**；PC 指到 ROM 范围外是未定义行为（写程序时要避免）。
- 指令是 **16 位**：
  - `A` 指令以 **0** 开头（把常数/地址装入 A）
  - `C` 指令以 **111** 开头（运算、存储、可带跳转）

# 一个极简运行例子

假设 ROM 中：

```
0: @2      (A 指令)        → PC=0 时 out = 0000000000000010
1: D=A     (C 指令)        → PC=1 时 out = 1110...（C 指令编码）
2: @SCREEN (A 指令, 地址)  → PC=2 时 out = 0100...（常量为 SCREEN 基址）
3: M=D     (C 指令)        → 把 D 写到屏幕映射内存
```

PC 依次取 0→1→2→3，ROM 每次把对应的 16 位指令吐给 CPU，CPU 译码执行。

**总结**：这页的要点就是——**ROM32K 是指令仓库**：输入 15 位地址，立即输出对应的 **16 位机器指令**；地址来自 PC。ROM 在运行时不可写，程序需要事先“预加载”。

![image-20251003105312475](README.assets/image-20251003105312475.png)

这页在讲 **Hack 计算机的 RAM 及“内存映射 I/O（MMIO）”**——把屏幕和键盘**映射到内存里的固定地址**，像读写普通内存一样去驱动外设。

# 内存版图（单位：word，1 word=16 位）

- **0 ~ 16383**（**16K words**）→ 普通 **数据内存 RAM16K**：变量、数组、栈等。
- **16384 ~ 24575**（**8K words**）→ **屏幕映射区 Screen**：往这里写入比特就会点亮/熄灭像素。
  - 屏幕 512×256（黑白）。每个 **word 控制 16 个水平相邻像素**。
  - 像素 (x,y) 对应的地址：`SCREEN + y*32 + x/16`；在该 word 的第 `x%16` 位（1=亮，0=灭）。
  - `SCREEN` 的基址 = **16384**（十六进制 0x4000）。
- **24576**（**1 word**）→ **键盘寄存器 KBD**：读出当前按键的键码，无键为 0。通常**只读**。
  - `KBD` 的地址 = **24576**（0x6000）。
- 其余高地址保留/未用。**从程序视角**看，就是**一片 32K 可寻址的读写空间**，其中部分地址“连着外设”。

# 这叫“内存映射 I/O（MMIO）”

CPU 不需要专门的 I/O 指令：

- **写屏幕** = 往 `16384..24575` 写数据；
- **读键盘** = 读 `24576`；
- 其他数据照常放在 `0..16383`。

# 典型用法示例（Hack 汇编）

**1）清屏：**

```asm
@SCREEN      // A=16384
D=A
@addr
M=D          // addr = SCREEN
@8192        // 要写 8K 个 word
D=A
@count
M=D

(LOOP)
@addr
A=M
M=0          // 写 0 清 16 个像素
@addr
M=M+1
@count
MD=M-1
@LOOP
D;JGT        // 还没写完就继续
(END)
@END
0;JMP
```

**2）按键填充/松开清屏：**

```asm
(LOOP)
@KBD
D=M         // 读键盘
@FILL
D;JNE       // 有键 → 填满屏
@CLEAR
0;JMP
(FILL)      // 把 SCREEN..SCREEN+8191 全写成 -1 (全 1)
@SCREEN
D=A
@i
M=D
@8192
D=A
@n
M=D
(FILLLOOP)
@i
A=M
M=-1
@i
M=M+1
@n
MD=M-1
@FILLLOOP
D;JGT
@LOOP
0;JMP
(CLEAR)     // 同 FILLLOOP，只是把 M=0
```

# 要点回顾

- **word=16 位**；屏幕每个 word 映射 16 个像素。
- **SCREEN=16384，KBD=24576**。
- 程序像**访问内存**一样读写外设，这就是 **MMIO**。
- 普通数据放在 **0..16383**；屏幕/键盘各在自己的映射区。

![image-20251003122411518](README.assets/image-20251003122411518.png)

这页在讲 **Hack 计算机的数据内存 RAM16K 的硬件级读/写规则**（见右图的方块 RAM16K）。

# RAM16K 是什么

- 容量：**16K words**（16384 个字），**每字 16 位**。

- 端口（见图）

  - **in[16]**：写入数据的 16 位总线

  - **address[14]**：地址总线，选择第 *k* 个字（0..16383）

    > *注：16K=2¹⁴，所以地址应为 14 位；图里写 15 多半是泛化/笔误。*

  - **load**：写使能（1=本拍写入；0=忽略写）

  - **out[16]**：读出的 16 位数据

  - 底部的小三角表示**时钟**（同步写）

# 行为语义（低层硬件视角）

- **读 RAM[k]**：
   把 **address=k**，不需要时钟，**out 立刻等于 `RAM[k]`**（异步读）。

  > 公式：`out = RAM[address]`

- **写 RAM[k] = x**：

  1. 设 **address=k**；2) 把 **in=x**；3) **load=1**；4) 来一个时钟上沿（“run the clock”）
      在这个时钟沿，`RAM[k]` 被更新为 `x`。随后 `out` 在下一相位/下一拍反映新值（课程仿真里是 tick/tock 两相）。

# 用 Hack 指令看同一件事

- **读内存到寄存器**（例如 `D=M`）：
  - A 寄存器里放着地址 k → 接到 RAM.address
  - 控制信号让 RAM.load=0
  - `out` 经数据通路进 D → 完成 “`D = RAM[k]`”
- **把寄存器写回内存**（例如 `M=D`）：
  - A 里仍是地址 k → RAM.address=k
  - 把 D 接到 RAM.in，置 **load=1**，到时钟沿写入
  - 效果是 “`RAM[k] = D`”

**示例：把常数 123 写到地址 10**

```asm
@123   // A=123
D=A    // D=123
@10    // A=10 (选中地址 10)
M=D    // 在时钟沿把 D 写入 RAM[10]
```

# 和屏幕/键盘的关系

RAM 的**同一套读写规则**也适用于**内存映射 I/O**：

- 写 `address=16384..24575`（SCREEN 区）= 改像素；
- 读 `address=24576`（KBD）= 得到按键码。

# 小结

- **读**：给地址就能从 **out** 直接读到（异步）。
- **写**：地址 + 数据 + `load=1`，**等时钟沿**才真正写入（同步）。
- 单位是 **16 位 word**；RAM16K 需要 **14 位地址线**来寻址 16K 个字。

![image-20251003122802157](README.assets/image-20251003122802157.png)

这页讲 **Hack 计算机的“屏幕芯片（Screen）”**，也就是**内存映射的显示器**。它本质上是一块**8K×16 位的 RAM**，只是这块 RAM 的位内容会被拿去“点亮像素”——所以它既像内存，又“顺带驱动”屏幕。

# 1）接口与读写规则（和 RAM 一样）

右图的方块就是 **Screen** 芯片，端口含义：

- **address**：选择要访问的那个 16 位字（word）的地址；
- **in[16]**：要写入的 16 位数据；
- **load**：写使能（=1 在时钟沿把 in 写进选中的地址；=0 不写）；
- **out[16]**：把 `Screen[address]` 里的 16 位内容读出来（组合/异步读）。

用两行话概括它的行为：

- **读**：`out = Screen[address]`
- **写**：`if load then Screen[address] = in`（在时钟沿生效）

> 注：作为独立设备，这块屏幕内存只有 **8K words**，寻址需要 **13 位**；PPT 上写 15 位是泛化画法。连到系统总线时，用高位地址做片选，低 13 位送到屏幕内部。

# 2）“副作用”：自动刷新屏幕窗口

芯片内部的每一位都被当作一个像素：**1=亮（黑），0=灭（白）**。
 硬件模拟器里自带的 `Screen.hdl` 会**每秒刷新多次**一个 512×256 的黑白窗口，把这 8K×16 位的内容显示出来（右侧橙色框里说的就是这个）。

# 3）像素如何映射到内存

- 屏幕分辨率：**宽 512 × 高 256**（黑白，1 像素=1 位）。
- 一行 512 像素 = **512 位 = 32 个 16 位 word**。
- 总共 256 行 × 32 word/行 = **8192 word（8K）**。
- 在整个地址空间中，这块区域的**基地址**是 `SCREEN = 16384`（十六进制 0x4000）。
- 像素 (x,y) 的映射（x:0..511, y:0..255）：
  - **word 地址**：`addr = SCREEN + y*32 + (x / 16)`
  - **word 内 bit 位置**：`bit = x % 16`
     把这个 bit 置 1 就点亮该像素，置 0 就熄灭。

# 4）程序员该怎么用（内存映射 I/O）

- **写屏幕**：向 `SCREEN .. SCREEN+8191` 写数据；
- **读屏幕**：从这段地址读出当前显示的位图（一般较少用）；
- **其他内存**：`0..16383` 是普通数据 RAM，不影响屏幕。

### 小例子（概念性的）

- **整屏填黑**：把 `SCREEN..SCREEN+8191` 全部写成 `-1`（二进制全 1）；
- **清屏**：把同一范围写成 `0`；
- **画水平线**：选中第 `y` 行，从 `SCREEN + y*32` 连续写 32 个 word（每个 word 的每一位都置 1）。

# 5）把它和普通 RAM 的差别记住一句话

> **它就是一块 RAM，只是“内容会被显示出来”这一件事被当作了“副作用”。**
>  读写规则与 RAM 完全一致，唯一不同是：写入后的比特会在屏幕窗口里可见。

![image-20251003123138053](README.assets/image-20251003123138053.png)

这页讲的是 **Hack 屏幕的“内存映射（screen memory map）”**——屏幕上每个像素，都对应内存里的某一位(bit)。把那一位写成 1/0，就会把对应像素点亮/熄灭。

# 核心结论

- 屏幕是**8K×16 位**的 RAM（共 **8192 个 word**，每个 word=16 位）。
- 分辨率：**512 列 × 256 行**（黑白）。
- **1 位=1 像素**：`0→白（灭）`，`1→黑（亮）`。
- 在整机地址空间中，这块显存的**起始地址**是：`SCREEN = 16384`。
- 屏幕按“行优先（row-major）”存：**每一行 512 像素 = 32 个 word**，共 256 行。

# 坐标 ⇄ 内存 的对应关系

设像素坐标为 **(row, col)**（`row∈[0,255]`, `col∈[0,511]`）：

**1）从像素算内存地址与位：**

- **word 地址：**
   `addr = SCREEN + row * 32 + (col / 16)`        （`/` 是整数除法）
- **word 内 bit 位置：**
   `bit = col % 16`                                （`%` 是取余）
- 把 `addr` 这个 word 的第 `bit` 位写成 `1` 就点亮该像素，写成 `0` 就熄灭。

**2）从内存地址反推覆盖的像素：**
 给定 `k`（`SCREEN ≤ k < SCREEN+8192`）：

- `row = (k - SCREEN) / 32`
- 这一 word 覆盖的列范围：`col ∈ [ (k - SCREEN)%32 * 16 , … , +15 ]`
- 其中具体哪个列就是 `bit`（0..15）对应的那一列。

> 直观理解：屏幕每行被切成 32 段；每段是一个 16 位的 word；word 里的第 0..15 位对应这 16 个像素从左到右。

# 读写规则（和普通 RAM 一样）

- **读**：`out = Screen[address]`（给地址就能读到 16 位内容）
- **写**：如果 `load=1`，在时钟沿把 `in` 写到 `Screen[address]`
- 模拟器会**每秒刷新多次**，把这 8K×16 位显示到 512×256 的窗口里。

# 例子

**例 1：像素 (row=100, col=300) 点黑**

- `row*32 = 3200`
- `col/16 = 18` → `addr = 16384 + 3200 + 18 = 19602`
- `bit = 300 % 16 = 12` → 需要把 `addr` 处的第 12 位设为 1
- 等价于：`RAM[19602] = RAM[19602] | (1 << 12)`

**例 2：清屏**
 把 `addr = SCREEN .. SCREEN+8191` 的所有 word 写成 `0`。

# Hack 汇编思路（概念性）

Hack 指令没有直接的位操作/移位指令，但可以用“**乘 2** 等价于**左移一位**”来生成掩码：

1. `mask = 1`，循环 `bit` 次做 `mask = mask + mask`（左移）
2. 写像素：`M = M | mask`；清像素：`M = M & (~mask)`
    （`|`、`&` 在 Hack 的 C 指令 `comp` 里分别用 `D|M`、`D&M` 等形式实现）

> 你只需记住两件事：
>  ① **地址公式** `addr = SCREEN + row*32 + col/16`；
>  ② **位索引** `bit = col%16`（1=黑，0=白）。
>  其余操作就和普通内存读写完全一样。

![image-20251003123342349](README.assets/image-20251003123342349.png)

这页讲的是 **Hack 计算机的“键盘芯片”**，它把用户输入的按键映射到一个 16 位的代码，作为输出。这个芯片本质上是一个16位寄存器，通过按键输入，返回相应的扫描码。

# 关键点

1. **键盘芯片**：
   - 它是一个 **16 位的寄存器**，负责存储当前按下的键的**扫描码**（类似 ASCII 码）。
   - 输入：来自物理键盘的按键。
   - 输出：**16 位的扫描码**，表示当前按下的键。
2. **特定按键输出映射**：
    页面上有一张表，列出了几种特殊按键与它们对应的输出值（扫描码）：

| Key pressed | Keyboard output |
| ----------- | --------------- |
| newline     | 128             |
| backspace   | 129             |
| left arrow  | 130             |
| up arrow    | 131             |
| right arrow | 132             |
| down arrow  | 133             |
| home        | 134             |
| end         | 135             |
| page up     | 136             |
| page down   | 137             |
| insert      | 138             |
| delete      | 139             |
| f1-f12      | 140-152         |

这些键的输出是**固定的**，例如：

- 按下回车（newline）键会输出 `128`，
- 按下退格（backspace）键会输出 `129`，
- 按下左箭头（left arrow）键会输出 `130`，等等。

1. **键盘的硬件工作原理**：
   - 要**读取键盘**，需要**查询该寄存器**（即读取 `Keyboard` 芯片的值）。
   - 如果没有按键被按下，寄存器的值通常是 `0`，否则它会返回一个按键的扫描码。
2. **读取键盘的方式**：
   - **低级硬件操作**：直接查询 `Keyboard` 寄存器中的内容。
   - **高级操作**：可以使用操作系统的函数 `keyPressed()` 来简化操作，效果与直接查询寄存器相同。
3. **模拟键盘**：
   - 在 **硬件模拟器**中，**键盘芯片**连接到物理键盘，模拟按键的扫描码并将其传送到键盘内存映射区。
   - 这就意味着，当用户按下键盘上的按键时，模拟器中的键盘也会捕捉到相应的按键扫描码。

# 示例：

- 如果用户按下 "up arrow" 键，模拟器的 `Keyboard` 寄存器会输出 `131`，表示“向上箭头”。
- 通过读取这个寄存器的值，程序可以知道用户按下了哪一个键，然后根据这个扫描码执行相应的操作。

# 总结：

**Hack 键盘芯片**将每个按键映射到一个16位的扫描码，按键的输入通过读取这个寄存器获取。这使得程序能够感知用户输入的内容，并做出响应。

![image-20251003123509887](README.assets/image-20251003123509887.png)

这页讲的是 **Hack CPU 的两条指令**：**A 指令** 和 **C 指令**。

# 1. **A 指令**

- **A 指令**用于把一个 **15 位的值**加载到 **A 寄存器**（A register）中。
- **A 寄存器**用于存放地址或常量，通常用来**指向 RAM 地址**，并作为 C 指令的一部分来访问内存。

### 结构与解读

- **A 指令的格式**：
  - 最左边的 **1 位（MSB，最高位）** 或 **i15** = `0`。
  - 剩余的 **15 位（i14 到 i0）** 是一个 **15 位无符号二进制数**，表示要存储到 A 寄存器中的值。

例如，A 指令 `0000000000000101` 对应 **二进制 5**，这个值将被加载到 A 寄存器。

### A 指令的作用

- **唯一方式**：A 指令是将常量加载到 A 寄存器的唯一方式。
- **内存寻址**：加载后，A 寄存器的值可以作为后续 C 指令访问 RAM 的地址。
  - 在 Hack 汇编中，`RAM[A]` 被表示为 `M`（即 **M = RAM[A]**）。

### 举例

假设有 A 指令 `0000000000000101`（表示 5），执行后，A 寄存器会保存值 5。接下来，你可以用这个值来访问内存，例如：

```asm
@5     // 将 A 寄存器加载为 5
D=M    // 将 RAM[5] 中的值加载到 D 寄存器
```

------

# 2. **C 指令**

- **C 指令**协调了 3 个操作：
  1. **计算操作（comp）**：决定要计算什么。
  2. **存储操作（dest）**：决定计算结果存储到哪个位置。
  3. **跳转操作（jump）**：决定下一步应该跳转到哪里。
- **C 指令的格式**：
  - 最左边的 **1 位（MSB，i15）** = `1` 表示这是一个 C 指令。
  - **C 指令的具体操作**会在后面的内容中详细解释。C 指令通过不同的操作码和条件选择要执行的操作，如计算、存储、跳转等。

------

# 3. 总结：

- **A 指令**：用于将常量（15 位无符号数）加载到 **A 寄存器**，并且它是唯一的方式来加载常量。
- **C 指令**：用于指定要执行的计算操作、存储位置和跳转条件，控制程序的执行流程。

接下来的幻灯片会更详细地讲解 C 指令的组成与各部分的含义。

![image-20251003123708171](README.assets/image-20251003123708171.png)

这页是在**把 C 指令掰开讲**：它把一条机器指令分成三块——**要算什么（comp）**、**把结果存哪儿（dest）**、**是否跳转（jump）**。同时也回答了红字问题：*既然 C 指令里已经有 dest，为什么还需要 A 指令？*

------

# C 指令的格式与执行语义

**汇编形态：** `dest = comp ; jump`
 **二进制：** `111 a c1 c2 c3 c4 c5 c6 d1 d2 d3 j1 j2 j3`

执行顺序（同一条指令内部）：

1. **用 ALU 计算**：由 `a c1..c6` 共同决定 `comp` 的运算，产生 `out`。

   - `a=0`：把 **A 寄存器**当作第二操作数；
   - `a=1`：把 **M = RAM[A]** 当作第二操作数（即访问 A 指向的内存）。

2. **写回（dest）**：
    `d1 d2 d3` 三位决定把 `out` 写到哪里：

   - `d1`→`A`，`d2`→`D`，`d3`→`M`（`M` 等价于 `RAM[A]`）。
      例如：`AD`=110、`M`=001、`null`=000（不存）。

3. **跳转（jump）**：
    按 `j1 j2 j3` 对 `out` 做条件跳转（条件基于 `out<0`、`out=0`、`out>0`）：

   ```
   000 null 不跳
   001 JGT out>0
   010 JEQ out=0
   011 JGE out≥0
   100 JLT out<0
   101 JNE out≠0
   110 JLE out≤0
   111 JMP 无条件跳
   ```

   若条件成立：**PC ← A**；否则 **PC ← PC+1**。

> 小结：一条 C 指令=“算 → 选地方存 → 可能跳”。是否使用内存由 **a 位**决定（A vs M）。

------

# comp（运算）能做什么

由 `a c1..c6` 选定 ALU 功能，覆盖：

- 常量：`0, 1, -1`
- 直接量：`D, A/M`
- 取反/取负：`!D, !A/!M, -D, -A/-M`
- 加减与位运算：`D+1, A+1/M+1, D-1, A-1/M-1, D+A/M, D-A/M, A/M-D, D&A/M, D|A/M`

（表格在幻灯下半部分：左边是 `a=0` 用 **A**，右边是 `a=1` 用 **M**。）

------

# 例子（读起来更直观）

- `D=A`：把 A 的值送进 D（`a=0`，`dest=010`）。
- `M=D+1`：把 `D+1` 写到 `RAM[A]`（`a=1` 因为目标是 M）。
- `0;JMP`：无条件跳转到 **A 指向**的地址。
- `D;JGT`：若 `D>0`，则跳到 **A**，否则顺序执行下一条。

------

# 关键问题：既然 `dest` 可以写 `A`，**为什么还需要 A 指令？**

因为 **C 指令不能携带任意常数或地址**，而**A 指令是把 15 位立即数装入 A 的唯一办法**。更具体地说：

1. **装立即数**
   - 想把 123 放进 A 或 D？必须先 `@123`（A 指令），然后 `D=A`。
   - C 指令能造的常量只有少数（0、1、-1、±1 等），远远不够。
2. **寻址内存（M = RAM[A]）**
   - 想访问 `RAM[k]`，先用 `@k` 把 **A=k**，之后 C 指令里的 `M` 才指向对的位置。
   - 这也是 “先设地址、再读/写内存” 的基本节奏。
3. **跳转目标**
   - C 指令的跳转 **PC ← A**，跳到哪里由 **A** 决定；必须先用 A 指令把目标地址（或标签对应地址）装到 A。
4. **鸡生蛋问题**
   - 虽然 `dest` 能把计算结果写回到 A，但很多时候**你要先有 A**（比如访问 M 或跳转）才能执行那条 C 指令。

> 一句话：**A 指令负责“给出数/地址”，C 指令负责“如何算、存哪儿、跳不跳”**。两者分工明确、互补。

------

如果你愿意，我可以把“任意像素点亮”“按键填充屏幕”等小程序写成 Hack 汇编，逐行标注对应的 C/A 编码与执行效果。

![image-20251003124434506](README.assets/image-20251003124434506.png)

这页是在说明 **Hack CPU 的实现电路**：一条 C/A 指令是怎样被**译码**成控制信号，数据又怎样沿着**数据通路**在寄存器、ALU、内存和 PC 之间流动的。

------

# 1) CPU 的输入/输出（和外部怎么连）

- **输入**
  - `instruction[16]`：来自 **指令 ROM** 的当前指令。
  - `inM[16]`：来自 **数据内存 RAM[A]** 的数据（A 指向的内存字，名字叫 `M`）。
  - `reset`：复位信号（=1 时 PC 清零）。
- **输出**
  - `outM[16]`：要写回到数据内存的值（其实就是 ALU 的输出）。
  - `writeM`：是否写数据内存（对应 C 指令 `dest` 里的 `M` 位）。
  - `addressM[15]`：数据内存地址（直接等于 **A 寄存器**的内容）。
  - `pc[15]`：下一条指令的地址，送给 **指令 ROM**。

------

# 2) 主要部件与连线（看图中间的方块）

- **ARegister（A 寄存器）**：既可当数据，也用来给 **RAM 地址**和**跳转目标**。其输入通过一个 **Mux16** 选择：
  - 选择 **指令里的 15 位常数**（当当前是 **A 指令**时，`instA=1`）；
  - 或选择 **ALU 输出**（当 C 指令且 `dest` 包含 A 时）。
  - 由 `loadA` 控制是否本拍写入。
- **DRegister（D 寄存器）**：通过 `loadD` 决定是否把 **ALU 输出**写入 D。
- **ALU**：输入 `x=D`，`y` 由一个 **Mux16** 选择 **A** 或 **M**（`AtoALU` 由指令里的 `a` 位决定：`a=0` 用 A；`a=1` 用 M=RAM[A]）。
  - 六个控位（图上 `compALU` 的 6 位）决定具体运算：清零、取反、加减、与/或等。
  - 输出 **outALU**，并产生标志 **zr**（零）与 **ng**（负）。
- **PC（程序计数器）**：有 `inc`（加 1）、`load`（装载）、`reset` 三个控制。
  - **正常**：`inc=1`，PC→PC+1。
  - **跳转**：若满足 `jump` 条件，`load=1`，**PC ← A**。
  - **复位**：`reset=1`，PC←0。
- **Decoder（解码器）**：并不是一个独立芯片，而是“把指令位译成控制信号”的总称。它负责产生：
  - `instA`（判断是不是 A 指令：`i15=0`）
  - `loadA / loadD / writeM`
  - `AtoALU`、`compALU[6]`
  - `jump` 相关位（j1..j3）并据 **zr/ng** 形成“是否应跳转”。

------

# 3) 一条指令在一个时钟里的事（取指与执行）

1. **Decode（译码）**
    解码 `instruction`：
   - 若是 **A 指令**：把指令的 15 位立即数装进 **A**（`instA=1`→`loadA=1`）；
   - 若是 **C 指令**：
     - 用 `a,c1..c6` 控制 ALU 计算 **outALU**（D 和 A/M 参与）；
     - 按 `dest(d1 d2 d3)` 决定是否写 **A、D、M**（`writeM=d3`，`outM=outALU`，`addressM=A`）；
     - 用 `j1..j3` 与 **zr/ng** 判定是否跳转到 **A**。
2. **PC 更新（Fetch 下一条）**
   - **应跳转**：`PC ← A`；
   - **否则**：`PC ← PC + 1`。
      同时，新的 `pc` 已经送给 ROM，下一条指令会在下个周期准备好。

> 因为指令存储器与数据存储器物理分离，**取指与访存可并行**：执行当前指令的同时已经在为下一条取指。

------

# 4) 关键信号怎么来的（和 C 指令字段的关系）

- `a,c1..c6` → **compALU**（决定算什么）。
- `d1,d2,d3` → `loadA, loadD, writeM`（决定结果存到 A、D、M 哪些地方）。
- `j1..j3` + `zr/ng` → **是否应跳转**（若真，则让 PC 从 **A** 装载）。
- 特例：**A 指令**（`i15=0`）不走 ALU 计算，只做“把常数装入 A”。

------

# 5) 一个具体例子（配合图理解数据流）

**指令**：`M=D+1; JLE`

- 解码：`a=1`（要用 `M`），`comp`= `D+1`，`dest`= `M`，`jump`= `JLE`。
- 数据通路：ALU 取 `x=D`、`y=M(inM)` 算 `D+1` → `outALU`；
  - `writeM=1`，`outM=outALU`，`addressM=A` → 把结果写回 **RAM[A]**；
  - 同时根据 **outALU** 的 `zr/ng` 判定 `outALU≤0` 是否为真；若真，则 **PC ← A**，否则 PC+1。

------

# ![image-20251003125750012](README.assets/image-20251003125750012.png)

这页在说：**一条 C 指令其实就是一串“控制位”**，这些位直接连到 CPU 里各个模块的控制线，分别决定：

1. **ALU 做什么运算（comp）**
2. **运算结果写到哪里（dest）**
3. **是否跳转 & 跳到哪里（jump）**

------

## C 指令的位域回顾

二进制格式：`111 a c1 c2 c3 c4 c5 c6 d1 d2 d3 j1 j2 j3`

- `a c1..c6` → **comp**：控制 ALU 的输入来源与功能
  - `a=0`：ALU 的第二个操作数用 **A**；
  - `a=1`：用 **M=RAM[A]**（经数据内存读出的值）。
  - `c1..c6` 是 ALU 的功能选择线（等价于 nand2tetris 里 `zx,nx,zy,ny,f,no`），组合后能产生 `0,1,-1,D,A/M, !D, -D, D+1, D+A/M, D|A/M …` 等结果。
- `d1 d2 d3` → **dest**：写回目的地
  - `d1` 写 **A 寄存器**，`d2` 写 **D 寄存器**，`d3` 写 **M(=RAM[A])**。
  - 例如 `010` 表示写 D；`001` 表示写 M；`110` 表示写 A 和 D；`000` 不写回。
- `j1 j2 j3` → **jump**：按 ALU 结果的符号/零标志决定是否跳转
  - ALU 会给出状态位：`zr`（结果==0）、`ng`（结果<0）。
  - 组合关系：
    - `JGT`(001)：`out>0` ⇔ `~zr & ~ng`
    - `JEQ`(010)：`out==0` ⇔ `zr`
    - `JGE`(011)：`out≥0` ⇔ `~ng`
    - `JLT`(100)：`out<0` ⇔ `ng`
    - `JNE`(101)：`out≠0` ⇔ `~zr`
    - `JLE`(110)：`out≤0` ⇔ `zr | ng`
    - `JMP`(111)：无条件
  - 逻辑可写成：`loadPC = (j1 & (~zr & ~ng)) | (j2 & zr) | (j3 & ng)`；若满足就 **PC←A**，否则 **PC←PC+1**。

------

## 对应这页的四条“观察”（Observations）

- **“We can use individual bits from the C-instruction to control the ALU”**
   `a,c1..c6` 这些位就是 ALU 的控制线，决定输入是 A 还是 M，以及具体做加法、与、或、取反、加/减 1 等。
- **“The Choice of Source (A, D, M)”**
   ALU 的两个来源固定为 **D** 和 **A/M**：
   `a=0` 选 **A**；`a=1` 选 **M=RAM[A]**。这就是“源操作数”的选择。
- **“The Choice of Destination (A, D, M)”**
   `d1 d2 d3` 三位分别门控对 **A、D、M** 的写使能（`loadA, loadD, writeM`）。结果写到哪完全由这三位决定。
- **“Some input signals to the PC … whether it should be updated with A”**
   `j1 j2 j3` 通过与 ALU 的 `zr/ng` 状态组合生成 **loadPC**。若为真，**PC 取 A**；否则 **PC 自增**。所以跳转也只由 C 指令的位 + ALU 状态决定。

------

## 把一条 C 指令用伪代码表达

```
// 输入：指令位 {a,c1..c6,d1,d2,d3,j1..j3}，寄存器 A,D，内存 RAM
y = (a == 0) ? A : RAM[A]        // 选择第二操作数
out, zr, ng = ALU(D, y, c1..c6)  // 由 c1..c6 指定功能，产生结果和状态

if (d1) A      = out             // 目的地写回
if (d2) D      = out
if (d3) RAM[A] = out

jump = (j1 & (~zr & ~ng)) | (j2 & zr) | (j3 & ng)
PC   = jump ? A : PC + 1
```

> 这正是这页想强调的：**C 指令的各个位就是 CPU 的微控制信号**——控制 ALU、选择源、选择目的地，并通过 ALU 的状态位决定是否让 **PC 载入 A**（跳转）。

![image-20251003125935931](README.assets/image-20251003125935931.png)