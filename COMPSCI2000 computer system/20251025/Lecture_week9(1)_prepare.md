

---

## 第 1 页

![第 1 页](Lecture_week9(1)_assets/page-001.png)

这张图片的文字内容是一段**对原住民土地的致敬与尊重声明（Acknowledgement of Country）**。下面是详细解释：

---

### 🪶 文字逐句解释

1. **“We acknowledge and pay our respects to the Kaurna people, the traditional custodians whose ancestral lands we gather on.”**
我们致敬并表达我们的敬意，向**Kaurna族人**致意——他们是我们聚集所在这片土地的**传统守护者**。这句话的意思是承认这片土地自古以来属于Kaurna族，是他们的祖先之地。

2. **“We acknowledge the deep feelings of attachment and relationship of the Kaurna people to country and we respect and value their past, present and ongoing connection to the land and cultural beliefs.”**
我们承认Kaurna族人对这片土地有着**深厚的情感与紧密的关系**，并且我们**尊重和珍视他们过去、现在以及持续存在的与土地和文化信仰的连接**。
这里“country”并不是指国家，而是澳大利亚原住民语境中的“土地、精神和文化的整体概念”。

---

### 🌏 背景意义

这是澳大利亚常见的致敬用语，通常在会议、活动、网站开场或演讲前使用，用以：

* **承认**土地属于原住民及其祖先；
* **表达尊重**他们的历史与文化；
* **强化社会意识**，提醒人们这片土地的历史和原住民的持续存在。

Kaurna族（读作“高纳”）是南澳大利亚阿德莱德地区的传统原住民群体，这段话正是为他们所写。

---

### ✍️ 总结

这段话的核心意思是：

> 我们尊重并感谢Kaurna族人，他们是我们现在所处这片土地的传统守护者；我们承认他们与这片土地的深厚情感与文化联系，并尊重他们过去、现在与未来的存在。

---

\[口语化表达]
这段话的意思就是在说：“我们现在活动的地方原本是Kaurna族人的土地，我们向他们致敬，也承认他们和这片土地的关系很深，不论是过去、现在还是未来，我们都要尊重他们的文化和传统。”


---

## 第 2 页

![第 2 页](Lecture_week9(1)_assets/page-002.png)

这张图片是澳大利亚阿德莱德大学（The University of Adelaide）的一张课程讲义封面。以下是详细解释：

---

### 🏫 图片内容说明

左侧深蓝色背景上有：

* **阿德莱德大学的校徽和校名**：
“THE UNIVERSITY of ADELAIDE” 是阿德莱德大学的正式英文名称。上方的徽章包含一本打开的书（象征知识与学习），并有校训 “Sub Cruce Lumen”，意为“在十字架下有光”，体现学校的宗教与启蒙传统。

* **标题 “Computer Systems”**：
这是课程名称，中文意思是\*\*《计算机系统》\*\*。这门课通常讲授计算机的基础架构、操作原理、语言处理、编译、操作系统与硬件交互等内容。

* **副标题 “Lecture 09/10: Language Parsing and Code Generation”**：
表示这是第9到第10讲的内容，主题是\*\*“语言解析与代码生成”\*\*。

* *Language Parsing*（语言解析）指编译器或解释器分析源代码语法结构的过程。
* *Code Generation*（代码生成）指把解析后的结构转换成机器代码或中间代码的阶段。
这部分内容通常出现在编译原理或系统课程的后半部分，讲的是从人类可读语言（如C、Python）到计算机可执行语言之间的转换机制。

---

### 👩‍🏫 右侧图像说明

右边的图显示两名学生（或研究人员）站在白板前讨论问题。白板上有一些用红色写的公式或语法树状结构，旁边的桌上放着：

* 一台**笔记本电脑**（可能用于编程或运行实验）；
* 一个**带有轮子的机器人装置**（用于嵌入式系统或编译后程序测试的物理模型）。

整体氛围展现了**动手实践与理论结合**的学习方式，体现阿德莱德大学工程与计算机科学领域注重实际应用的教学特色。

---

### 📘 综合总结

整张幻灯片是阿德莱德大学《计算机系统》课程的一节课封面，讲的是**编程语言的解析与代码生成**。它既体现了课程的学术主题，也通过图像展示了学生动手实践与研究的学习场景。

---

\[口语化表达]
这张图是阿德莱德大学《计算机系统》课的一页封面，主要讲“语言解析和代码生成”——也就是编译器怎么理解程序、再把它变成电脑能跑的代码。画面上两个学生在白板前讨论，桌上有电脑和机器人，说明这门课不仅讲理论，还动手做实验。


---

## 第 3 页

![第 3 页](Lecture_week9(1)_assets/page-003.png)

这张幻灯片是对“整个计算机系统（The whole system）”的回顾（Review），展示了**从最底层硬件到最高层编程语言**的完整层次结构。它出自阿德莱德大学的《计算机系统》课程，帮助学生理解软件与硬件如何层层衔接。下面是详细说明：

---

### 🧠 整体结构概览

图中从下往上展示了计算机系统的六个主要层次，每一层都建立在下层之上。每一层右侧写有课程对应章节（Chapters），左侧标明该层的技术领域（如 Compiler、Assembler 等）。结构如下：

| 层级                           | 名称     | 中文解释                                                                                  | 功能说明 |
| ---------------------------- | ------ | ------------------------------------------------------------------------------------- | ---- |
| **1. Chips and Logic Gates** | 芯片与逻辑门 | 最底层的电子电路，由晶体管组成逻辑门（如与门、或门、非门）。它们是所有计算机计算的最基本单元。                                       |      |
| **2. Hardware Platform**     | 硬件平台   | 由处理器（CPU）、内存、寄存器等组成的物理硬件结构，执行机器指令。                                                    |      |
| **3. Machine Language**      | 机器语言   | 硬件直接理解的二进制代码（0和1），每个指令都精确控制硬件操作。                                                      |      |
| **4. Assembly Language**     | 汇编语言   | 机器语言的可读版本，用助记符（如 MOV、ADD、JMP）代替二进制。程序员可通过“汇编器（Assembler）”将其转为机器码。                     |      |
| **5. Virtual Machine**       | 虚拟机    | 一个抽象层，模拟真实硬件运行环境，使得不同程序能在不同系统上运行。例如 Java 的 JVM。                                       |      |
| **6. Programming Language**  | 编程语言   | 最高层，如 C、Python、Java 等。程序员使用人类可读语法编写代码，再通过“编译器（Compiler）”或“解释器（Translator）”转为机器能执行的语言。 |      |

---

### ⚙️ 左侧的标注解释

左侧的蓝色箭头代表负责每一层之间转换的工具或概念：

* **Electronics（电子学）**：支撑逻辑门与电路层。
* **Gate Logic（逻辑门电路）**：逻辑与运算的实现。
* **System Architecture（系统架构）**：构建硬件平台与机器语言的接口。
* **Assembler（汇编器）**：把汇编语言转成机器语言。
* **Translator（翻译器）**：把虚拟机指令翻译成汇编或机器代码。
* **Compiler（编译器）**：把高级编程语言编译成虚拟机代码或更底层语言。

---

### 🧩 概念关系总结

这张图展示了计算机系统从硬件到软件的“分层模型”：

1. **底层（物理层）**：由电子元件构成逻辑门和芯片。
2. **中层（体系结构层）**：定义机器指令和硬件平台如何工作。
3. **上层（软件层）**：编译器和虚拟机使高级语言能够在底层硬件上运行。

整个系统像一座“语言与硬件的桥”，从“人类语言”一步步翻译为“电信号”。

---

\[口语化表达]
这张图讲的是整个计算机从底到顶是怎么一层层组成的。最底下是电子电路和芯片，再往上是硬件、机器语言、汇编、虚拟机，最上面才是我们写的编程语言。每一层都靠下面那层运行，编译器、汇编器这些工具就是帮我们把人写的代码一步步变成电脑能懂的0和1。


---

## 第 4 页

![第 4 页](Lecture_week9(1)_assets/page-004.png)

这张幻灯片标题为：**“Review: The Jack Language & Compiler Fundamentals”**，意思是“回顾：Jack语言与编译器基础”。这是阿德莱德大学《计算机系统》课程中关于编译器部分的复习内容。下面是详细解释：

---

### 💡 标题含义

**1. “The Jack Language”**
Jack 是一种**教学用的高级编程语言**，通常出现在计算机系统结构或编译原理课程中。它来自著名的《From Nand to Tetris》教学体系。
Jack语言的设计目的不是用于商业编程，而是帮助学生**理解编程语言是如何被编译、翻译并在硬件上运行的**。
Jack的语法和结构类似 Java，比如有类（class）、方法（function）、循环（while/if）等，是一个简化的面向对象语言。

**2. “Compiler Fundamentals”（编译器基础）**
这一部分讲的是编译器的基本原理，也就是：

* 编译器如何把像 Jack 这样的**高级语言**转成计算机可以理解的**机器语言**。
* 涉及的关键步骤包括：

* **词法分析（Lexical Analysis）**：把代码分解成一个个“词”（token）；
* **语法分析（Parsing）**：检查代码结构是否符合语法规则；
* **语义分析（Semantic Analysis）**：确定变量、类型等是否正确；
* **代码生成（Code Generation）**：把分析好的结构转成虚拟机或机器指令。

---

### 🧱 课程背景说明

这张幻灯片的“Review”意味着这节课是在**复习前面讲过的内容**。
它回顾了：

* Jack语言的基本语法和功能；
* 编译器从源代码到机器代码的翻译流程；
* 各个模块之间如何协同工作，形成一个完整的“语言处理系统”。

这节课属于课程的**后半段（通常第9\~10讲）**，紧接在前一部分关于虚拟机和汇编语言的内容之后。

---

### 🧩 主要学习目标

通过复习这一章，学生要理解：

* 如何用 Jack 语言写出能在虚拟机上运行的程序；
* 编译器的每个组成部分的作用；
* 编译器如何充当“桥梁”，让人写的高级代码变成计算机能执行的低级指令。

---

\[口语化表达]
这页讲的是在复习“Jack语言”和“编译器基础”。Jack是一种教学用的小语言，用来帮学生理解编译器怎么把代码变成电脑能懂的机器语言。这节课主要回顾编译器是怎么一步步分析、翻译代码的，比如先拆成单词、再检查语法、最后生成机器指令。简单来说，就是复习“人写的程序怎么变成电脑能跑的程序”这一整套过程。


---

## 第 5 页

![第 5 页](Lecture_week9(1)_assets/page-005.png)

这张幻灯片标题为 **“Review: Noteworthy features of the Jack language”**，意思是“回顾：Jack语言的显著特性”。
它总结了 Jack 编程语言的一些特别设计特点，并说明这些设计都是为了**让编译器的构建更简单**。以下是详细解释👇

---

### 🧩 Jack 语言的主要特性逐条解析

1. **使用冗长的 `let` 关键字（如 `let x = 0;`）**
Jack 使用关键字 `let` 来进行赋值操作，这类似于一些早期语言（如 Pascal）的风格。虽然在实际编程中显得有点啰嗦（cumbersome），但这种形式**让编译器更容易识别赋值语句**。

2. **使用 `do` 关键字（如 `do reduce();`）**
调用函数或方法时必须加上 `do`，表示这是一个执行动作（而非赋值）。这种语法虽然不常见，但**帮助编译器区分“语句”和“表达式”**。

3. **没有运算符优先级（No operator priority）**
Jack 中所有运算从左到右依次执行。
例如：

```
1 + 2 * 3
```

结果是 `9`，因为它按顺序执行 `(1 + 2) * 3`。
如果想得到常见的数学结果 `7`，必须显式加括号：

```
1 + (2 * 3)
```

这种简化避免了复杂的优先级规则，让**解析（parsing）更容易**。

4. **只有三种基本数据类型（primitive data types）**

* `int`（整数）
* `boolean`（布尔值）
* `char`（字符）
每种类型都被当作 16 位（2 字节）数据处理。
这让数据管理统一，也减少了编译器需要处理的复杂类型判断。

5. **没有类型转换（No casting）**
任意类型的值都可以赋给任意类型的变量。
这种“宽松”的规则简化了类型系统，使编译器不必处理复杂的类型检查逻辑。

6. **数组声明与创建方式简化**
声明数组用：

```
Array x;
```

创建数组实例用：

```
x = Array.new();
```

类似面向对象语言中的构造方式，统一了对象与数组的创建机制。

7. **静态方法叫做 `function`**
Jack 把类中不依赖对象实例的方法称为 `function`（函数），与对象方法区分开。

8. **构造函数叫做 `constructor`**
类似 Java 或 C++，但语法更简洁。

9. **调用构造函数的语法**
使用：

```
ClassName.new(argsList)
```

这与实际面向对象语言（如 Java 的 `new ClassName()`）类似，但形式更统一。

---

### 🧠 最后一行总结的核心思想

> “All of these design decisions have been taken to make building a compiler easier.”
> 意思是：
> 这些看似“笨拙”或“不灵活”的设计，其实是**有意为之**，目的是让学生在实现 Jack 编译器时更容易理解和实现。

Jack 是教学用语言，因此它追求**结构简单、规则统一、便于分析**，而不是编程效率或功能多样性。

---

\[口语化表达]
这页是在讲 Jack 语言的一些特别之处。比如它用 `let` 来赋值、`do` 来调用函数、没有运算符优先级、类型很少也不用强制转换，连数组和对象的写法都被统一了。这些设计看起来笨笨的，其实是故意简化的，就是为了让学生写编译器的时候更容易，不用处理太多复杂的语法规则。


---

## 第 6 页

![第 6 页](Lecture_week9(1)_assets/page-006.png)

这页题为\*\*“Review: Jack program structure（回顾：Jack 程序结构）”**，展示了 Jack 语言中**一个类的标准骨架**以及**程序/文件组织规则\*\*。

---

### 1) 类的骨架（左侧代码框）

```jack
class ClassName {
field variable declarations;   // 实例字段：属于对象
static variable declarations;  // 静态字段：属于类

constructor type name(parameterList) {
local variable declarations; // 局部变量
statements;                  // 可执行语句
}

method type name(parameterList) {
local variable declarations;
statements;
}

function type name(parameterList) {
local variable declarations;
statements;
}
}
```

* **field**：定义对象的实例变量（每个对象一份）。
* **static**：定义类变量（整个类共享一份）。
* **constructor**：构造器，负责创建并初始化对象，返回该类类型的引用。
* **method**：对象方法，需要通过对象调用，隐含一个当前对象（this）。
* **function**：静态方法，不依赖对象实例，通过类名调用。
* 三种子程序（constructor/method/function）内部都遵循：先**局部变量声明**，再写**语句**（赋值、条件、循环、调用等）。

---

### 2) 语法规格说明（右上 “About this spec”）

* **各部分可出现 0 次或多次**：比如可以没有字段，也可以有多个方法/函数/构造器。
* **field 与 static 的声明顺序任意**：先写哪个都可以。
* **各子程序声明的顺序任意**：constructor、method、function 可以任意排列。
* **type 的取值**：只能是 `int`、`boolean`、`char` 或者**某个类名**（引用类型）。

---

### 3) Jack 程序的组织（右下 “A Jack program”）

* **每个类单独一个文件**（即一个编译单元）。
* **一个 Jack 程序 = 1 个或多个类**；其中**必须有一个类名为 `Main`**。
* **`Main` 类必须至少包含一个方法 `main()`**，它是程序的入口点（从这里开始运行）。

---

### 4) 一眼看懂的要点

* 先**类**，类里先**字段**（field/static），再**若干子程序**（constructor/method/function）。
* 子程序体内先**局部声明**、再写**语句**。
* **类型很少**（基础三种 + 类名），**顺序宽松**（声明顺序不强制）。
* **文件结构清晰**：一类一文件，必须有 `Main.main()` 作为入口。

---

\[口语化表达]
这页在说：Jack 里一个程序就是好多类拼起来，每个类单独放一个文件。类里面先写字段（实例的 `field`、全局的 `static`），再写各种子程序：建对象用 `constructor`，对象方法用 `method`，不需要对象的用 `function`。每个子程序都是“先声明局部变量，再写具体语句”。字段的顺序、各个子程序的先后都随意；能用的类型就 `int/boolean/char` 或者某个类名。最后必须有一个叫 `Main` 的类，而且里面要有 `main()`，程序就从这里开始跑。


---

## 第 7 页

![第 7 页](Lecture_week9(1)_assets/page-007.png)

这张幻灯片标题是 **“Compiler architecture (front end)”（编译器结构——前端部分）**，讲的是 Jack 编译器在“前端”阶段如何把源代码转换成中间代码或目标代码。下面是详细解释 👇

---

### 🧱 一、总体结构（中间大图）

中间方框展示的是 **Jack 编译器（Jack Compiler）** 的工作流程，从源代码到虚拟机代码（VM code）的过程：

```
Jack Program (source)
↓
┌────────────────────────┐
│      Jack Compiler     │
│ ┌────────────────────┐ │
│ │   Syntax Analyzer  │ │
│ │  ┌──────────────┐  │ │
│ │  │   Tokenizer  │  │ │
│ │  └──────────────┘  │ │
│ │        ↓           │ │
│ │      Parser        │ │
│ └────────────────────┘ │
│         ↓              │
│    Code Generation     │
└────────────────────────┘
↓
VM code (target)
```

* **Jack Program（源代码）**：输入的程序文件，使用 Jack 语言编写。
* **Syntax Analyzer（语法分析器）**：负责编译器前端的语言理解部分。

* **Tokenizer（词法分析器）**：把源代码拆分成一个个“记号”（token），例如关键字、变量名、符号等。
* **Parser（语法分析器）**：根据语言语法规则检查这些 token 是否形成合法的结构。
* **Code Generation（代码生成）**：把语法树（语法结构）转换为中间语言（这里是虚拟机 VM 代码）。
* **XML code**：在教学中用于展示语法分析器工作是否正确的输出格式（不是真正执行的目标代码）。
* **VM code**：编译器输出的最终结果，之后会被虚拟机（VM）解释执行或进一步转为机器语言。

---

### ⚙️ 二、右上角小图（更大的体系）

右侧的流程图展示了 Jack 编译器在整个系统中的位置：

1. 不同的高级语言（如 “Some language”、“Some Other language”）经过自己的编译器转换成 **中间代码（Intermediate code）**。
2. Jack 语言通过 **Jack Compiler** 也生成相同格式的中间代码（VM code）。
3. 这些中间代码可以在不同虚拟机实现上运行（例如 RISC、CISC、Hack 平台等）。
4. 最终，虚拟机把代码转成**机器语言（Machine Language）**，运行在真实硬件上。

这说明 Jack 编译器的目标并不是直接生成机器码，而是生成一个跨平台的虚拟机代码。

---

### 🧩 三、概念解释（底部文字部分）

#### ✅ Syntax analysis（语法分析）

理解源代码所表达的逻辑和语义。包括：

* **Tokenizing（词法分析）**：
把源代码分割成词法单元（tokens），例如：

```
let x = 5 + 3;
```

会变成：`let`、`x`、`=`、`5`、`+`、`3`、`;`
* **Parsing（语法解析）**：
根据语言文法（grammar）检查这些 token 的结构是否正确，并建立语法树。
输出 XML 文件只是**演示语法分析是否正确**的一种方式。

#### ✅ Code generation（代码生成）

把语法树重新“翻译”为另一种语言（目标语言）的语法结构。
即从 Jack 的语法生成 VM 指令，从而重建程序逻辑。

---

### 🧠 四、知识核心总结

Jack 编译器的“前端”主要分两步：

1. **语法分析（Syntax Analysis）**：理解源代码。
2. **代码生成（Code Generation）**：把理解后的结构转成 VM 指令。

整个过程的目标是：

> 把人类可读的 Jack 程序转化为计算机能理解、可执行的中间语言。

---

\[口语化表达]
这页在讲 Jack 编译器是怎么工作的，尤其是“前端”那一部分。简单说，它先把你写的 Jack 程序拆成一个个词（Tokenizing），再检查这些词是不是符合语言规则（Parsing），最后再把分析好的结构转成虚拟机能跑的代码（Code Generation）。这些步骤让编译器能“读懂”你的程序，再“翻译”成电脑能执行的形式。右边那张图是告诉你 Jack 编译器其实只是整个系统的一环，它把 Jack 语言转成虚拟机代码，后面虚拟机再帮你变成真正的机器语言。


---

## 第 8 页

![第 8 页](Lecture_week9(1)_assets/page-008.png)

这张幻灯片的标题是 **“Tokenizing / Lexical analysis”（词法分析 / 标记化）**，讲的是**编译器的第一步：把源代码拆解成最基本的语言单元（tokens）**。这是编译器理解程序的起点。

---

### 🧩 一、什么是 Tokenizing（标记化）

**Tokenizing** 是从源代码中提取有意义的“词汇单元”的过程。
每一个单元叫做一个 **token**（标记），例如：关键字、变量名、数字、运算符、符号等。

在这页的例子中，源代码是：

```jack
while ( count < 100 ) /** demonstration code */
{
let count = count + 1 ;
}
```

经过 **tokenizer（词法分析器）** 处理后，会被拆解为：

```
while
(
count
<
100
)
{
let
count
=
count
+
1
;
}
```

也就是说，**空格、注释和排版**都被忽略，只保留语言有意义的部分。

---

### ⚙️ 二、词法分析的基本步骤

1. **Remove white space（去除空格）**
空格和换行在大多数语言中不是语义内容，所以需要移除。

2. **Construct a token list（构造标记列表）**
把剩下的字符分组形成一个个 token，例如：

* `while` → 关键字（keyword）
* `count` → 标识符（identifier）
* `<` → 符号（symbol）
* `100` → 整数常量（integerConstant）
* `let`、`=`、`+`、`;` 等都是 token。

---

### 🧠 三、需要注意的问题（Things to worry about）

1. **语言特定规则（Language specific rules）**
不同语言对符号的组合处理方式不同，比如 `++` 在 C 或 Java 中代表“自增”，而 Jack 语言里可能要拆分成两个 `+`。

2. **语言特定分类（Language-specific classifications）**
每个 token 要被正确分类为：

* `keyword`（关键字）
* `symbol`（符号）
* `identifier`（标识符）
* `integerConstant`（整型常量）
* `stringConstant`（字符串常量）
等。

3. **记录词法分类（lexical classification）**
除了记录 token 本身，tokenizer 还要记录**这个 token 属于哪种类型**（例如“这是一个关键字”、“这是一个变量名”）。
这样后续语法分析（parsing）才能正确理解程序结构。

---

### 🧩 四、总结核心思想

词法分析是编译器前端最底层的一步，它的任务是：

> “从原始源代码中，提取出一串有意义的词汇单元（tokens），并去掉所有无用的字符。”

这一步让计算机能更容易地进行下一阶段的语法分析（Syntax Analysis）。

---

\[口语化表达]
这页讲的是编译器处理代码的第一步——“词法分析”。它会把你写的源代码拆成一个个最小的有意义单元，比如关键字、变量名、数字、符号等。空格和注释会被删掉，剩下的都变成一列“词”（tokens）。编译器不仅要知道这些词，还要知道它们是什么类型（比如这是变量、这是数字）。这一步就像让电脑先学会“看懂单词”，下一步它才能理解句子结构。


---

## 第 9 页

![第 9 页](Lecture_week9(1)_assets/page-009.png)

这张幻灯片的标题是 **“Jack Tokenizer”**，意思是“Jack 语言的词法分析器”。
它展示了编译器在**词法分析（Lexical Analysis）阶段**如何把 Jack 源代码分解成一系列“标记（tokens）”，并输出成 XML 格式的结果。

---

### 🧩 一、源代码（Source code）

幻灯片左上方的源代码是：

```jack
if (x < 153) {let city = "Paris";}
```

这是一段简单的 Jack 语句，逻辑上是：

> 如果 `x` 小于 153，就执行 `{let city = "Paris";}`，也就是给变量 `city` 赋值字符串 `"Paris"`。

---

### ⚙️ 二、Tokenizer 的作用

**Tokenizer（词法分析器）** 是编译器前端的第一步。
它会：

1. 去掉注释与空格；
2. 把源代码拆成**最小的语言单位（tokens）**；
3. 识别每个 token 的类型，比如它是关键字、符号、变量名、整数或字符串。

---

### 📦 三、Tokenizer 的输出（Tokenizer’s output）

右侧的框显示了分析器输出的 XML 格式结果：

```xml
<tokens>
<keyword> if </keyword>
<symbol> ( </symbol>
<identifier> x </identifier>
<symbol> &lt; </symbol>
<integerConstant> 153 </integerConstant>
<symbol> ) </symbol>
<symbol> { </symbol>
<keyword> let </keyword>
<identifier> city </identifier>
<symbol> = </symbol>
<stringConstant> Paris </stringConstant>
<symbol> ; </symbol>
<symbol> } </symbol>
</tokens>
```

这表示：

* `if` → **关键字（keyword）**
* `(`、`)`、`{`、`}`、`<`、`=`、`;` → **符号（symbol）**
* `x`、`city` → **标识符（identifier）**（变量名）
* `153` → **整数常量（integerConstant）**
* `"Paris"` → **字符串常量（stringConstant）**

---

### 🧠 四、关于 XML 实体（Char XML Entity）

右上角的表格说明了一些符号在 XML 中不能直接使用，必须用“转义符号（entity）”来代替：

| 符号  | XML写法    |
| --- | -------- |
| `<` | `&lt;`   |
| `>` | `&gt;`   |
| `'` | `&apos;` |
| `"` | `&quot;` |
| `&` | `&amp;`  |

在输出中，`<` 被写成 `&lt;`，这是为了保证 XML 文件格式正确。

---

### 🧩 五、核心总结

这页展示了 Jack 语言编译器中的 **Tokenizer 输出示例**。
它把原始代码转成机器可理解的、带标签的结构化形式，让后续的语法分析器（Parser）能轻松理解程序的语义。

---

\[口语化表达]
这页讲的是编译器怎么把 Jack 代码拆成一个个词。比如代码 `if (x < 153) {let city = "Paris";}`，会被分成关键字、符号、变量、数字和字符串这些小块。然后编译器会给每个部分打标签（像 `<keyword>if</keyword>` 这样），还要把像 `<` 这样的符号写成 `&lt;`，因为 XML 文件不能直接用这些符号。这样处理后，编译器下一步就能更容易地理解代码结构。


---

## 第 10 页

![第 10 页](Lecture_week9(1)_assets/page-010.png)

这张幻灯片的标题是 **“Syntax Analysis: Parsing”**，意思是“语法分析：解析”。
它是编译器的第二个核心阶段的标题页，用来引出接下来的内容——讲解**编译器如何理解程序结构（语法树）**。

---

### 🧩 一、概念解释

**Syntax Analysis（语法分析）** 是编译过程中的第二步，发生在 **词法分析（Lexical Analysis / Tokenizing）** 之后。
在词法分析阶段，程序代码已经被拆解成一个个 **token（标记）**，例如：

```
if (x < 10) { let y = y + 1; }
```

→
`if`、`(`、`x`、`<`、`10`、`)`、`{`、`let`、`y`、`=`、`y`、`+`、`1`、`;`、`}`

现在编译器要做的，就是**分析这些 token 是否按照语言的语法规则组成了一个合法的结构**。

---

### ⚙️ 二、什么是 Parsing（解析）

**Parsing** 是语法分析的具体过程，它会：

1. 按照语言的文法规则（grammar）读取 token；
2. 检查语法是否正确；
3. 生成一个\*\*语法树（Syntax Tree）\*\*或等价结构，用于后续的语义分析和代码生成。

例如，对于上面的例子：

```
if (x < 10) { let y = y + 1; }
```

解析器（parser）会识别：

* 整体是一个 `if` 语句；
* `x < 10` 是条件表达式；
* `{ let y = y + 1; }` 是语句块（代码体）。

最终，它会把这些结构组织成一个**嵌套的树形结构**，类似：

```
ifStatement
├── condition: (x < 10)
└── body:
└── letStatement (y = y + 1)
```

---

### 🧠 三、Parsing 的意义

语法分析的目的是让编译器真正“理解”源代码的结构。
它不只是读单词，而是能分清“主语”“谓语”“从句”等语法关系，就像人类理解句子一样。
比如编译器要知道：

* 哪些 token 组成一个表达式；
* 哪个语句嵌套在另一个语句中；
* 哪些结构不符合语法，需要报错。

没有解析阶段，编译器就无法理解程序逻辑，也无法生成正确的代码。

---

### 💡 四、总结

> “Parsing” 是把一串 token 按照语言语法规则组合成结构化表示（语法树）的过程。
> 它是编译器从“识别单词”过渡到“理解句子”的关键步骤。

---

\[口语化表达]
这页只是引出“语法分析”这一部分。简单来说，Parsing 就是编译器学会“看懂句子”的过程。前面一步它只是把代码拆成一个个词（token），而这一步要检查这些词是不是排成了正确的句子结构，比如 if、循环、赋值等。它会把这些结构整理成一棵语法树，让后面能继续生成机器能懂的代码。


---

## 第 11 页

![第 11 页](Lecture_week9(1)_assets/page-011.png)

这张幻灯片的标题是 **“Parsing（语法解析）”**，它解释了什么是解析（Parsing）、解析器（Parser）做什么，以及解析的整个过程。它是编译器工作原理中**语法分析阶段的理论基础**部分。

---

### 🧩 一、Parsing 与 Parser 的基本概念

* **Tokenizer（分词器）**：之前讲的 tokenizer 只是把源代码拆成“词”（token），例如关键字、符号、数字等。
* **Parser（解析器）**：解析器是一个**更大的程序组件**，它在 tokenizer 的基础上，进一步分析这些词之间的结构关系。

换句话说，**tokenizer 负责“分词”**，而 **parser 负责“理解句子结构”**。

---

### ⚙️ 二、语言与文法（Grammar）

每一种语言（无论是自然语言还是编程语言）都有自己的**语法规则（grammar）**。
例如：

* 在英语中，句子结构是 *主语 + 动词 + 宾语*；
* 在编程语言中，赋值语句可能是 *变量 = 表达式*；
* 在 Jack 语言中，语法规则会定义如何写函数、条件、循环等。

**解析器的任务**就是根据这些语法规则，判断输入的 token 序列是否符合语言规定的结构。

---

### 🧠 三、Parsing 的工作流程

幻灯片中总结的过程如下：

1. **输入文本（A text is given and tokenized）**
首先代码会被分词（tokenize），拆成基本语言单位。

2. **检查语法合法性（The parser determines whether or not the text can be generated from the grammar）**
解析器会根据语言的语法规则，判断这些 tokens 是否能组成一个合法的结构。
如果不能，就会报语法错误（Syntax Error）。

3. **分析文本结构（Performs a complete structural analysis）**
在这个过程中，解析器会构建一个语法树（Syntax Tree）或等价的结构，用来表示代码的层次关系。

---

### 💬 四、解析对象（The text can be an expression in a…）

解析器不仅仅可以分析编程语言，也可以分析自然语言文本。

* **自然语言（Natural language）**：如英语句子 “The dog runs.”
* **编程语言（Programming language）**：如 Jack、Java、Python 等。

解析器的本质任务——**识别语法结构并建立层级关系**——在这两种语言中都是一样的，只是规则不同。

---

### 🧩 五、总结重点

> **Parsing（语法解析）** 是根据语法规则（Grammar）分析一段文字或代码结构的过程。
> 解析器（Parser）用来识别结构是否正确、建立层次关系，并为后续步骤（如语义分析和代码生成）提供基础。

---

\[口语化表达]
这页在讲“解析”（Parsing）是干什么的。编译器的 tokenizer 只负责把代码拆成词，而 parser 要根据语法规则去“理解”这些词能不能组成一句正确的话。它会检查语法是不是合法的，还会分析出结构关系，比如哪个是条件、哪个是语句块。其实无论是英语句子还是 Jack 语言代码，解析器的工作原理都一样——都是根据语法规则判断这句话合不合法，并画出它的结构图。


---

## 第 12 页

![第 12 页](Lecture_week9(1)_assets/page-012.png)

这张幻灯片标题是 **“Parsing examples（解析示例）”**，通过对比 **Jack 编程语言的表达式** 和 **英语句子** 的解析过程，说明了“语法分析（Parsing）”是如何让计算机理解结构的。

---

### 🧩 一、左侧：Jack 语言的解析示例

表达式：

```
((5 + 3) * 2) - sqrt(9 * 4)
```

这个表达式中有括号、运算符和函数调用，解析器会根据语法规则构建一棵**语法树（syntax tree）**，从最底层的运算开始往上组合。

语法树结构如下：

```
-
/   \
*     sqrt
/   \      \
+     2      *
/ \          / \
5   3        9   4
```

解释：

* 最底层是基本的数字（5、3、9、4）；
* `5 + 3` 先计算；
* 结果乘以 `2`；
* 同时右边的 `sqrt(9 * 4)` 计算平方根；
* 最后左边结果减去右边结果。

这说明解析器能**正确识别优先级和嵌套结构**，通过语法树表示出计算顺序。

---

### 🧠 二、右侧：英语句子的解析示例

句子：

```
She ate radishes with her friend
```

这句话在语法上**有两种可能的理解（解析）**：

#### Parse 1（解析方式 1）：

```
She [ate radishes] [with her friend]
```

意思是：“她和她的朋友一起吃萝卜。”
→ “with her friend” 修饰动词 *ate*（表示“和谁一起吃”）。

#### Parse 2（解析方式 2）：

```
She ate [radishes with her friend]
```

意思是：“她吃了和她朋友在一起的萝卜。”
→ “with her friend” 修饰名词 *radishes*（表示“那种带着朋友的萝卜”，语义上不太通，但语法上是合法的）。

➡️ 这说明：**同一句话可能有多种语法结构（歧义）**，解析器会根据语法规则和上下文选择一种最合适的语法树。

---

### ⚙️ 三、核心思想

无论是编程语言还是自然语言，\*\*Parsing（语法解析）\*\*的作用都是：

1. 把“词”的序列转化成“结构”的树；
2. 明确不同部分之间的层级与关系；
3. 让系统或人能够理解句子或表达式的“逻辑含义”。

---

### 📘 四、总结

> 编译器中的解析过程就像语言学中分析句子结构一样。
> 它不是简单地看单词顺序，而是构建一个有层次的结构（语法树），帮助理解“谁和谁结合”“谁修饰谁”“哪个先执行”。

---

\[口语化表达]
这页在举例说明“解析”到底干什么。左边是 Jack 代码 `((5+3)*2) - sqrt(9*4)`，编译器会根据运算规则把它分成一棵树，先算加法，再乘，再减去平方根那边的结果。右边的英语例子 “She ate radishes with her friend” 说明一句话也可能有不同理解：是“她和朋友一起吃萝卜”，还是“她吃了带着朋友的萝卜”。编译器做的事其实跟语法老师差不多——它要分析语句结构，看清楚每个部分是怎么组合起来的。


---

## 第 13 页

![第 13 页](Lecture_week9(1)_assets/page-013.png)

这张幻灯片标题是 **“More examples of challenging parsing”**，意思是“更多具有挑战性的语法解析例子”。
它展示了**自然语言（英语）中由于歧义而造成解析困难的例子**，说明解析器（parser）在面对自然语言时可能遇到多种理解方式。

---

### 🧠 一、核心概念

\*\*Parsing（语法分析）\*\*的任务是根据语法规则理解句子结构。
但自然语言不像编程语言那样规则严谨，**同一句话可能存在多种语义或语法解释（即歧义）**，这使得“解析”变得很困难。

---

### 🧩 二、左上角例子：“Time flies like an arrow / Fruit flies like a banana”

这两句看似相似，但含义完全不同。

1. **Time flies like an arrow**

* 通常理解为：“时间飞逝如箭。”
* 语法结构是：`Time (subject)` + `flies (verb)` + `like an arrow (adverbial phrase)`。
* 但从解析角度，这句话还有别的可能解释，比如：

* “测量时间的苍蝇喜欢箭（的味道）”，如果把 “Time flies” 理解为“给苍蝇计时”。

2. **Fruit flies like a banana**

* 实际意思是：“果蝇喜欢香蕉。”
* 语法结构是：`Fruit flies (subject)` + `like (verb)` + `a banana (object)`。
* 但如果沿用前一句的结构（“某物飞得像…”），也可以被误解析为“水果飞得像香蕉”。

➡️ **说明：** 同样的句型结构在不同语境下可能对应完全不同的语义，这就是自然语言解析的难点。

---

### 🧩 三、右上角例子：“We gave the monkeys the bananas because they were hungry / over-ripe”

这两句展示了解析中\*\*指代歧义（referential ambiguity）\*\*的问题：

* “they” 到底指谁？

1. **because they were hungry（因为他们饿了）**

* “they” 指猴子（the monkeys） → 我们给猴子香蕉，因为猴子饿了。

2. **because they were over-ripe（因为它们太熟了）**

* “they” 指香蕉（the bananas） → 我们给猴子香蕉，因为香蕉太熟了。

➡️ 语法结构相同，但**代词指代对象不同**导致意思完全变化。

---

### 🧩 四、下方例子：“I never said she stole my money”

这句经典的英语歧义句展示了**语义重音不同**引发的多义性。
同样的单词顺序，但因为重音（stress）落在不同的词上，意思完全不同：

| 强调的词                                | 含义           | 中文理解          |
| ----------------------------------- | ------------ | ------------- |
| **I** never said she stole my money | 别人说的，不是我     | “不是我说她偷钱的。”   |
| I **never** said she stole my money | 我根本没说过       | “我从没说过那话。”    |
| I never **said** she stole my money | 我没明说，只是暗示    | “我没直接说。”      |
| I never said **she** stole my money | 偷的人不是她       | “不是她偷的。”      |
| I never said she **stole** my money | 她可能借走了       | “她是借的，不是偷的。”  |
| I never said she stole **my** money | 她偷了别人的，不是我的  | “偷的是别人的钱。”    |
| I never said she stole my **money** | 她拿走了别的东西，不是钱 | “她拿的是别的，不是钱。” |

➡️ 每个强调点都改变了句子的语义焦点，这种“歧义”对解析器来说极具挑战。

---

### ⚙️ 五、总结

这些例子展示了自然语言解析的两个难点：

1. **结构歧义（Structural ambiguity）**：同样的语法形式可以有多种语义解释。
2. **语义歧义（Semantic ambiguity）**：语境、重音或代词指代不同，都会导致意义变化。

这说明自然语言解析与编程语言解析最大的区别是：

> 编程语言语法规则严格，只有一种合法结构；
> 自然语言语法灵活、多义，需要语义与上下文辅助才能理解。

---

\[口语化表达]
这页在举例说明“自然语言的解析有多难”。比如“Time flies like an arrow”听起来是“时间像箭一样飞逝”，但也可能被误解成“给苍蝇计时”；“Fruit flies like a banana”乍看像“水果飞得像香蕉”，其实是“果蝇喜欢香蕉”。再比如“we gave the monkeys the bananas because they were hungry”，这里的 “they” 可能指猴子，也可能指香蕉。最经典的是“I never said she stole my money”这句，重音放在哪儿意思都变了。它们都说明，解析自然语言比解析编程语言难多了——人能靠语感理解，但计算机要靠非常复杂的规则和上下文才能弄清楚。


---

## 第 14 页

![第 14 页](Lecture_week9(1)_assets/page-014.png)

这张幻灯片标题是 **“A typical grammar of a typical C-like language”**，意思是“一个典型的类C语言语法示例”。
它展示了**C风格编程语言（如C、Java、Jack等）常见的语法规则结构**，并说明了语法（grammar）如何描述语言中所有合法的句式。

---

### 🧩 一、左侧（Grammar）：语法规则说明

左侧蓝框中的文字展示的是一种**形式化语法定义（formal grammar）**，它用来定义编程语言中哪些写法是“语法合法的”。
这是编译器在语法分析（Parsing）阶段识别代码结构所依据的规则。

---

#### 🔹 语法定义部分：

```
program: statement
```

一个程序由一个语句（statement）开始。

```
statement:
whileStatement
| ifStatement
| 'statement' ';'
| '{' sequence '}'
```

一个语句可以是以下几种类型之一：

* **whileStatement**：循环语句
* **ifStatement**：条件语句
* **普通语句**（例如表达式语句，结尾带分号）
* **代码块语句**（花括号 `{}` 包含一系列语句）

---

#### 🔹 while 语句定义：

```
whileStatement: 'while' '(' 'expression' ')' statement
```

说明一个合法的 while 语句必须符合以下格式：

```
while (表达式) 语句
```

例如：

```c
while (x < 5) { statement; }
```

---

#### 🔹 if 语句定义：

```
ifStatement: 'if' '(' 'expression' ')' statement ('else' statement)?
```

说明 if 语句的结构是：

```
if (表达式) 语句
```

可选地（通过 `?` 表示可有可无），后面可以带：

```
else 语句
```

例如：

```c
if (x > 0) statement;
else statement;
```

---

#### 🔹 sequence（语句序列）定义：

```
sequence: '' | statement sequence
```

表示代码块 `{}` 中可以包含多个语句，也可以为空。
比如：

```c
{
statement;
statement;
}
```

或：

```c
{}
```

都是合法的。

---

### 🧠 二、右侧（Code sample）：对应的代码示例

右边的黄色部分展示了符合该语法的一个示例程序：

```c
while (expression)
{
if (expression)
statement;
while (expression)
{
statement;
if (expression)
statement;
}
while (expression)
{
statement;
statement;
}
if (expression)
{
statement;
while (expression)
{
statement;
statement;
}
if (expression)
if (expression)
statement;
}
}
```

这段嵌套结构说明了两点：

1. 语法具有**递归性（recursive）**：语句内部还可以嵌套语句（如 if 中嵌 while，再嵌 if）。
2. 语言结构由规则严格定义，但能表达无限多层次的组合。

---

### ⚙️ 三、底部文字解释

幻灯片底部对“grammar（语法）”进行了概括性说明：

* **A grammar is a set of rules**
语法是一组规则，描述语言中所有合法的结构。

* **It has simple (terminal) forms**
包含“终结符”（terminal）——也就是不会再分解的基本单元，如 `if`、`while`、`;` 等。

* **It has complex (non-terminal) forms**
包含“非终结符”（non-terminal）——由语法规则定义的结构，如 statement、expression 等。

* **It is highly recursive**
语法是**高度递归的**，因为一个语句中还可以包含另一个语句，从而形成嵌套。

---

### 💡 四、总结核心思想

> 这页展示了类C语言语法的递归定义方式。
> 每个合法的程序结构（如 if、while、代码块）都由语法规则严格规定，编译器利用这些规则识别并验证程序结构。

---

\[口语化表达]
这页讲的是“类C语言”的语法长什么样。左边那一堆规则定义了代码该怎么写，比如一个 `if` 语句必须是 `if (表达式) 语句`，可以选带一个 `else`；一个 `while` 语句要是 `while (表达式) 语句`。语法还能嵌套，比如 `if` 里再放 `while`，`while` 里再放 `if`，这就是“递归”的意思。右边那段长代码就是这些规则的组合示例。最后总结说，语言的语法其实就是一组规则，规定什么是合法代码，什么不是。


---

## 第 15 页

![第 15 页](Lecture_week9(1)_assets/page-015.png)

这页标题是 **“Parse tree（语法树）”**，用一个 `while` 示例说明**解析器如何根据语法规则把分词后的代码组织成一棵树状结构**，从而“看懂”程序。

---

### 这张图在讲什么？

1. **Input Text（输入代码）**
`while (count < 100) { /** demonstration */ let count = ... ; ... }`
这里的注释会在分词阶段被去掉。

2. **Tokenized（分词结果）**
代码被拆成 token 序列：
`while ( count < 100 ) { let count = ... ; ... }`
空白与注释被丢弃，只保留有语义的记号（关键字、符号、标识符、常量等）。

3. **Grammar（语法）片段（右上蓝框）**
用形式化规则定义“什么写法是合法的”：

* `program : statement`
* `statement : whileStatement | ifStatement | 'statement' ';' | '{' sequence '}'`
* `whileStatement : 'while' '(' 'expression' ')' statement`
* `sequence : '' | statement sequence`
这些规则告诉解析器：`while ( 表达式 ) 语句` 是一个合法结构；花括号里是**语句序列**，可以为空或递归地包含更多语句。

4. **Parse tree（中间黑箭头的树）**

* 顶层节点是 **statement**，选择了产生式 **whileStatement**。
* `whileStatement` 展开成：`'while' '(' expression ')' statement`：

* 左边的**expression** 子树对应 `count < 100`；
* 右边的 **statement** 则匹配花括号 `{ ... }`，再根据规则转成 **'{' sequence '}'**。
* **statementSequence** 继续递归展开：一个或多个 **statement**（比如 `let count = ... ;` 以及后续语句）。
图中灰色三角形表示“这里还有更完整的子树”，只是为了简洁没有全部画出。

---

### 这个过程体现了什么？

* **从 token 到结构**：解析器根据**文法（grammar）**把线性的 token 序列组合成**层次化结构**（语法树）。
* **终结符 vs. 非终结符**：像 `while`、`(`、`)`、`{`、`}`、`;` 属于**终结符**；`statement`、`expression`、`sequence` 属于**非终结符**，需要继续用规则展开。
* **递归性**：`sequence : '' | statement sequence` 让代码块能包含任意多条语句（包括再次嵌套 `if`/`while` 等）。

---

### 一句话小结

> 解析器用语法规则把“分好词的代码”拼成一棵语法树：根是 `statement`，展开成 `while (expression) statement`，条件是 `count < 100`，大括号里的内容是一个可递归的语句序列。

---

\[口语化表达]
这页就是告诉你：编译器怎么把 `while (count < 100) { let count = ...; ... }` 这种代码“看成一棵树”。先把代码切成一个个词（`while`、`(`、`count`、`<`、`100`、`)`、`{`…），再按语法规则拼起来：最外层是个 `statement`，其实是个 `while` 语句；`(` 和 `)` 里面是一棵表达式子树 `count < 100`；`{}` 里是一串语句，按“语句序列”规则递归展开。总之，解析器就是把线性的代码变成分层的结构，这样后面才好生成目标代码。


---

## 第 16 页

![第 16 页](Lecture_week9(1)_assets/page-016.png)

这页题为 **“Recursive descent parsing（递归下降解析）”**，说明如何用一种简单直观的方法“按语法规则写一组递归函数”来完成语法分析（Parsing）。

---

### 1) 左侧：语法（grammar）片段

```
program      : statement
statement    : whileStatement
| ifStatement
| 'statement' ';'
| '{' statements '}'
whileStatement : 'while' '(' 'expression' ')' statement
ifStatement    : 'if' '(' 'expression' ')' statement ('else' statement)?
statements     : statement*
```

含义：

* 程序由一个**语句**构成；语句可以是 `while`、`if`、普通表达式语句（以分号结束），或花括号里的**语句序列**。
* `statements : statement*` 表示**0 个或多个语句**（星号是闭包）。

### 2) 右侧：代码示例（code sample）

展示了合法的 C/Jack 风格嵌套结构，如：

```
while (expression) {
statement;
statement;
while (expression) {
while (expression)
statement;
statement;
}
}
```

体现语法的**递归性**：语句里可以继续包含语句。

---

### 3) 递归下降解析的核心思想

* **做法**：为每条语法规则写一个**同名的解析函数**，函数之间按规则**相互调用**、**递归下降**地消费输入 token。
* **函数一览（右下）**：

* `parseStatement()`
* `parseWhileStatement()`
* `parseIfStatement()`
* `parseStatements()`
例如：`parseStatement()` 读取下一个 token：
* 若看到 `while` → 调 `parseWhileStatement()`；
* 若看到 `if` → 调 `parseIfStatement()`；
* 若看到 `{` → 调 `parseStatements()` 直到遇到 `}`；
* 否则按“普通语句 + ;”处理。

---

### 4) LL(1) 与向前看（lookahead）

* **LL(1) 语法**：只需看**1 个**未来 token 就能决定应用哪条产生式（规则）。

> “the first token determines the rule（第一个 token 决定规则）”
* **非 LL(1)**：可能需要看更多 token 才能判定分支（向前看更多）。
* **Jack 的特点**：**几乎是 LL(1)**，因此非常适合用递归下降来实现解析器。

---

### 5) 为什么好用？

* **直观**：代码结构与语法规则一一对应，易读易调试。
* **轻量**：不需要复杂的自动生成器；手写即可。
* **可控**：在相应函数中方便地插入错误报告、构建语法树、生成中间表示等。

---

\[口语化表达]
这页的意思是：把语法规则按条目各写一个函数，然后函数互相调用、一路“往下走”把 token 吃掉，这就叫递归下降解析。比如读到 `while` 就进 `parseWhileStatement()`，读到 `if` 就进 `parseIfStatement()`，遇到 `{` 就循环解析里面的一串语句。因为 Jack 基本是 LL(1)，看下一个词就能判断走哪条规则，所以这种写法既直观又好实现。


---

## 第 17 页

![第 17 页](Lecture_week9(1)_assets/page-017.png)

这张幻灯片标题是 **“The Jack grammar”**，意思是 **“Jack 语言的语法规则”**。
它系统地展示了 Jack 语言的**基本语法组成（lexical elements）**和**程序结构（program structure）**，并说明了符号写法在语法定义中的含义。

---

### 🧩 一、Lexical elements（词法元素）

Jack 语言和其他编程语言一样，由若干“最小语法单元”（token）组成。
这些词法元素包括：

| 类型                        | 含义与示例                                                                                                                                                                        |                      |
| ------------------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | -------------------- |
| **keyword（关键字）**          | 固定保留字，如 `class`、`constructor`、`function`、`method`、`field`、`static`、`var`、`int`、`char`、`boolean`、`void`、`true`、`false`、`null`、`this`、`let`、`do`、`if`、`else`、`while`、`return`。 |                      |
| **symbol（符号）**            | 语法符号，如 `{`、`}`、`(`、`)`、`[`、`]`、`.`、`,`、`;`、`+`、`-`、`*`、`/`、`&`、\`                                                                                                            | `、`<`、`>`、`=`、`\~\`。 |
| **integerConstant（整数常量）** | 0–32767 之间的十进制整数。                                                                                                                                                            |                      |
| **stringConstant（字符串常量）** | 由双引号 `"` 包围的 Unicode 字符序列。                                                                                                                                                   |                      |
| **identifier（标识符）**       | 由字母、数字和下划线 `_` 组成，但不能以数字开头（用于变量名、函数名、类名等）。                                                                                                                                   |                      |

---

### 🧱 二、Program structure（程序结构）

Jack 程序由一个或多个\*\*类（class）\*\*组成，每个类单独存放在一个文件中。
其基本结构如下：

#### 🔹 1. 类定义（class）

```
'class' className '{' classVarDec* subroutineDec* '}'
```

说明：

* 每个程序都以 `class` 开头；
* 花括号中包含若干：

* **classVarDec**（类级变量声明）
* **subroutineDec**（子程序声明，如方法或函数）

#### 🔹 2. 类变量定义（classVarDec）

```
('static' | 'field') type varName (',' varName)* ';'
```

* 类变量要么是 **静态的（static）**，要么是 **实例字段（field）**；
* 变量可以是基本类型（`int`、`char`、`boolean`）或类类型；
* 允许一次声明多个变量，用逗号分隔。

#### 🔹 3. 子程序声明（subroutineDec）

```
('constructor' | 'function' | 'method') ('void' | type) subroutineName
'(' parameterList ')' subroutineBody
```

即构造函数、函数或方法定义，包含：

* 参数列表（`parameterList`）
* 子程序体（`subroutineBody`）

#### 🔹 4. 参数列表（parameterList）

```
((type varName) (',' type varName)*)?
```

* 可以为空，也可以有多个参数，用逗号分隔。

#### 🔹 5. 子程序体（subroutineBody）

```
'{' varDec* statements '}'
```

包含：

* 变量声明（`varDec`）
* 语句序列（`statements`）

#### 🔹 6. 变量声明（varDec）

```
'var' type varName (',' varName)* ';'
```

声明局部变量，用 `var` 开头。

---

### 🔣 三、语法符号说明（右下角小框）

解释语法定义中常用的符号表示方法：

| 符号       | 含义                |
| -------- | ----------------- |
| `'x'`    | 字面出现的符号（verbatim） |
| *x*      | 语法构成要素（非终结符）      |
| *x?*     | x 出现 0 或 1 次（可选）  |
| *x*\*\*  | x 出现 0 次或多次（可重复）  |
| *x \| y* | x 或 y 其一          |
| *x y*    | x 后面跟着 y          |

例如：

```
varDec : 'var' type varName (',' varName)* ';'
```

就表示：

* 必须以 `'var'` 开头；
* 后接一个 `type`；
* 至少一个变量名 `varName`；
* 可以再有任意多个 `, varName`；
* 最后必须以分号 `;` 结束。

---

### 🧠 四、总结

这页定义了 Jack 语言的**完整语法骨架**。
从最底层的词法元素（关键字、符号、标识符等），到上层的程序结构（类、方法、变量、语句），都以**形式化文法**的方式描述，让编译器能“读懂” Jack 程序。

---

\[口语化表达]
这页就是在告诉我们 Jack 语言的语法长什么样。上半部分是“词汇表”，列出了所有关键字、符号、常量和标识符的规则；下半部分是“结构说明”，定义了一个程序怎么写，比如类要以 `class` 开头，里面可以有变量和方法；变量声明用 `var` 开头，方法要写成 `function` 或 `method`；参数、语句、花括号这些都有固定格式。右下角那块是解释语法符号怎么读，比如 `*` 表示可以重复，`?` 表示可选。简单说，这页就是 Jack 语言的“语法说明书”。


---

## 第 18 页

![第 18 页](Lecture_week9(1)_assets/page-018.png)

这页题为 **“The Jack grammar (cont.)”**，意思是\*\*“Jack 语言语法（续）”\*\*。它给出了 **语句（Statements）** 与 **表达式（Expressions）** 的形式化文法规则，供解析器（parser）据此判断代码是否合法并构建语法树。

---

## 一、Statements（语句部分）

* **statements : statement**\*
花括号 `{}` 中的语句序列，可包含 **0 个或多个** `statement`。

* **statement :**
`letStatement | ifStatement | whileStatement | doStatement | returnStatement`
一条语句可以是五种之一：`let`、`if`、`while`、`do`、`return`。

* **letStatement ：**
`'let' varName ('[' expression ']')? '=' expression ';'`
赋值语句；可选的 `[...]` 表示**数组下标**。例如：
`let x = 5;` 或 `let a[i] = x + 1;`

* **ifStatement ：**
`'if' '(' expression ')' '{' statements '}' ('else' '{' statements '}')?`
`if` 必带条件与主体块，`else` 子句可选，且也是一个块。

* **whileStatement ：**
`'while' '(' expression ')' '{' statements '}'`
条件循环，结构与 `if` 类似。

* **doStatement ：**
`'do' subroutineCall ';'`
调用子程序（方法/函数）且**忽略返回值**。例如 `do Output.printInt(x);`

* **returnStatement ：**
`'return' expression? ';'`
`return;`（无返回值）或 `return expr;`（有返回值）。

---

## 二、Expressions（表达式部分）

* **expression ：** `term (op term)*`
一个或多个 `term` 由二元运算符 `op` 连接。没有**优先级**时靠括号/语法约定；Jack 教学中常用括号明确顺序。

* **term ：**
`integerConstant | stringConstant | keywordConstant | varName |`
`varName '[' expression ']' | subroutineCall | '(' expression ')' | unaryOp term`
即：整数、字符串、关键字常量、变量、数组元素、函数/方法调用、括号表达式，或**一元运算**作用于一个 `term`。

* **subroutineCall ：**
`subroutineName '(' expressionList ')' |`
`(className | varName) '.' subroutineName '(' expressionList ')'`
既支持**当前类/对象**调用，也支持 `类名.函数` 或 `对象.方法` 调用。

* **expressionList ：**
`(expression (',' expression)*)?`
参数列表：可空，或一个表达式后跟若干 `, 表达式`。

* **op（二元运算符）：**
`'+' | '-' | '*' | '/' | '&' | '|' | '<' | '>' | '='`
加减乘除、与、或、小于/大于/等于。

* **unaryOp（一元运算符）：**
`'-' | '~'`
负号、按位非/逻辑非（在 Jack VM 约定下）。

* **keywordConstant（关键字常量）：**
`'true' | 'false' | 'null' | 'this'`

---

## 三、语法记号读法（右下角提示）

* **'x'**：字面字符/关键字 **原样出现**
* **x**：语法构件（非终结符）
* **x?**：x **出现 0 或 1 次**（可选）
* **x\***：x **出现 0 次或多次**（可重复）
* **x | y**：**二选一**
* **x y**：x **后面紧跟** y

---

## 四、把规则映射到真实代码（小例）

```jack
let i = 0;                              // letStatement
while (i < 3) {                         // whileStatement
do Output.printInt(i);                // doStatement -> subroutineCall
let arr[i] = i + 1;                   // term: varName '[' expression ']'
let i = i + 1;                        // expression: term op term
}
return;                                 // returnStatement (无表达式)
```

---

\[口语化表达]
这页把 Jack 的“语句”和“表达式”规则一次性说清了：一条语句要么是 `let/if/while/do/return` 其中之一；`let` 能给变量或数组元素赋值，`if/while` 带括号条件和大括号代码块，`do` 是调用函数但不管返回值，`return` 可带也可不带表达式。表达式由一个个 `term` 用运算符连起来，`term` 可以是数字、字符串、`true/false/null/this`、变量、数组元素、函数调用、括号表达式，或者先来个一元运算 `-`/`~`。右下角的符号读法也很简单：`?` 是可选，`*` 是可重复，`|` 是二选一，单引号是字面量。照这张“语法说明书”写出来的 Jack 代码，解析器就能毫不费劲地看懂。


---

## 第 19 页

![第 19 页](Lecture_week9(1)_assets/page-019.png)

这页标题是 **“Jack syntax analyser in action（Jack 语法分析器实战）”**。它演示了：把一段 Jack 源代码输入**语法分析器（parser）**后，如何按文法规则生成**结构化的解析结果（这里用 XML 展示）**，并给出语法分析器的基本输出策略。

---

## 1) 左上：示例源代码

```jack
class Bar {
method Fraction foo(int y) {
var int temp;           // 变量声明
let temp = (xxx + 12) * -63;
...
}
}
```

* 有一个类 `Bar`，里面的方法 `foo`。
* 在方法体内：先**局部变量声明** `var int temp;`，再有一个 **let 赋值语句**，表达式包含括号、加法、常量、一元负号等。

---

## 2) 右侧：语法分析器的输出（XML 树）

语法分析器按照 Jack 文法把源代码分解并**标注类别**，输出类似：

```xml
<vardec>
<keyword> var </keyword>
<keyword> int </keyword>
<identifier> temp </identifier>
<symbol> ; </symbol>
</vardec>

<statements>
<statement>
<letstatement>
<keyword> let </keyword>
<identifier> temp </identifier>
<symbol> = </symbol>
<expression>
<term>
<symbol> ( </symbol>
<expression>
<term>
<varName><identifier> xxx </identifier></varName>
</term>
<symbol> + </symbol>
<term><integerConstant> 12 </integerConstant></term>
</expression>
...
```

要点：

* 每个节点都带**语法角色标签**（如 `<vardec>`、`<letstatement>`、`<expression>`）。
* 终结符（`var`、`;`、`+`、`12` 等）被包成 `<keyword>` / `<symbol>` / `<integerConstant>` / `<identifier>`。
* 非终结符（如 `expression`、`term`、`varName`）形成**层级嵌套**，体现语法树结构。

---

## 3) 左下：什么是“语法分析器”（要点）

* 程序员**依据语言文法**实现语法分析器（parser）。
* 语法分析器**读取源文件**，尝试将其**匹配到语言文法**上。
* 匹配成功就能生成一个**解析树**，可用 XML 等结构化格式表示，便于检查/调试/后续代码生成。

---

## 4) 这页给出的“输出算法”思路

* **如果 `xxx` 是非终结符（non-terminal）**：
输出一对标签 `<xxx>...</xxx>`，并**递归**地处理它的内部组成（按该规则的产生式展开）。
* **如果 `xxx` 是终结符（terminal：关键字/符号/常量/标识符）**：
输出 `<xxx> 值 </xxx>`，不再递归。

这正是**递归下降解析**的典型打印策略：非终结符递归、终结符直接落地。

---

## 5) 为什么要输出 XML？

* XML 是**结构清晰**、**易检视**的中间表示，能直观看到语法分析是否正确；
* 也方便后续步骤（如语义检查、代码生成）消费该结构。

---

\[口语化表达]
这页就是在演示“语法分析器怎么把 Jack 代码看成结构化的树”。把 `var int temp;`、`let temp = (xxx + 12) * -63;` 交给分析器后，它会按文法给每一部分贴上标签：变量声明、let 语句、表达式、项、符号、常量、标识符……最后吐出一份层层嵌套的 XML。规则很简单：**遇到非终结符就递归展开成 `<xxx>…</xxx>`，遇到终结符就直接写出值**。这样我们能一眼检查语法是否匹配，也为后面生成代码打好基础。


---

## 第 20 页

![第 20 页](Lecture_week9(1)_assets/page-020.png)

这页标题是 **“Jack Tokeniser（Jack 语言的词法分析器）”**，主要讲的是：如何通过一个简单接口来实现 Jack 语言的\*\*分词（tokenizing）\*\*过程——也就是把源代码拆分成一个个有意义的“词法单元（token）”，供后续语法分析器使用。

---

## 一、核心概念：Tokeniser（词法分析器）

词法分析器（tokeniser）是编译器的第一步，用来**逐字扫描代码**，识别出“关键词、符号、数字、标识符”等 token。
例如：

```jack
let x = 5;
```

会被分成：

```
<keyword> let </keyword>
<identifier> x </identifier>
<symbol> = </symbol>
<integerConstant> 5 </integerConstant>
<symbol> ; </symbol>
```

Jack 的 tokeniser 就是用来完成这种拆分和分类的。

---

## 二、主要接口函数（Main interface）

| 函数                    | 功能说明                                                                         |
| --------------------- | ---------------------------------------------------------------------------- |
| **next\_token()**     | 移动到下一个 token（推进一个词）。                                                         |
| **token\_spelling()** | 返回当前 token 的**原始拼写（文本内容）**。例如 `"while"`、`"x"`、`"("`。                         |
| **token\_kind()**     | 返回当前 token 的**类型（种类）**，例如 `keyword`、`identifier`、`symbol`、`integerConstant`。 |
| **token\_ivalue()**   | 如果当前 token 是整数常量，返回它的**整数值**。例如 token `123` → 值为 `123`。                      |

---

## 三、辅助判断函数

| 函数                    | 功能                                                                                               |
| --------------------- | ------------------------------------------------------------------------------------------------ |
| **have(TokenKind)**   | 判断当前 token 是否属于给定类型（返回布尔值）。                                                                      |
| **mustbe(TokenKind)** | 当前 token **必须是指定类型**；若匹配则调用 `next_token()` 继续，否则触发错误（`fatal_error()`）。<br>➡️ 常用于语法分析阶段的“语法强制检查”。 |

---

## 四、特殊 token

* **tk\_eoi**：表示 **end of input（输入结束）**，即代码扫描完毕。
* **分组型 token（grouping tokens）**：如

* `tk_infix_op`（中缀运算符，如 `+`、`-`、`*`）
* `tk_term`（表达式中的基本单元，如变量、常量、括号表达式）

这些“特殊 token”有助于在语法分析时快速识别结构层次。

---

## 五、工作流程总结

1. **tokeniser 从源文件读取字符**
2. 按语言规则识别下一个合法的 token（关键字/符号/常量等）
3. 通过上述接口函数获取 token 内容或种类
4. 在语法分析器中，调用 `have()`/`mustbe()` 来验证语法合法性

---

\[口语化表达]
这页讲的是 Jack 的“词法分析器”该怎么设计。它的任务就是把源码拆成一个个小词，比如 `let`、`x`、`=`、`5`、`;`。主要的函数有几个：`next_token()` 让分析器往前读一个词；`token_spelling()` 拿到这个词的具体内容；`token_kind()` 看它是什么类型；如果是数字还可以用 `token_ivalue()` 得到数值。语法分析时可以用 `have()` 来判断当前词是不是你想要的类型，用 `mustbe()` 来强制匹配（不对就报错）。最后还定义了一些特殊 token，比如表示文件结束的 `tk_eoi`，或者运算符组、表达式单元之类的辅助标记。简单说，这页就是在教你怎么用一组接口去驱动 Jack 代码的“分词器”。


---

## 第 21 页

![第 21 页](Lecture_week9(1)_assets/page-021.png)

这页标题是 **“CompilationEngine: a recursive top-down parser for Jack”**，意思是 **“编译引擎：用于 Jack 语言的递归自顶向下解析器”**。
这页解释了 **Jack 编译器中负责“语法分析与输出生成”的核心模块——CompilationEngine** 的工作原理和设计原则。

---

## 🧩 一、CompilationEngine 的作用

**CompilationEngine** 是编译器的第二个主要组件（继 Tokenizer 之后）。
它负责：

* 从 **Jack Tokenizer** 接收词法分析后的输入（即一系列 token）；
* 按照 Jack 的语法规则（grammar）逐步解析这些 token；
* 输出结构化的结果（通常是 **XML 格式的语法树打印**，或用于后续的代码生成阶段）。

换句话说，它是编译器中执行“语法分析（parsing）”的部分。

---

## 🧱 二、主要机制：parse\_xxx() 解析函数系列

输出由一组以 **`parse_xxx()`** 命名的函数组成，每个函数对应一种语法结构（syntax construct）：

* `parse_class()`
* `parse_expression()`
* `parse_whileStatement()`
* `parse_ifStatement()`
* `parse_term()` 等等。

这些函数**递归地调用彼此**，构建出完整的语法层次结构，因此被称为\*\*“递归下降解析器（recursive top-down parser）”\*\*。

---

## 🔄 三、函数之间的“契约”（Contract）

每个 `parse_xxx()` 函数的职责：

1. 从输入读取符合 `xxx` 语法规则的部分；
2. 精确读取完这一结构的所有 token；
3. 读到 `xxx` 之后的第一个 token；
4. 产生对应的输出（例如 XML 标签或内部节点）。

> 例如：`parse_ifStatement()` 负责识别并解析整个 if 块（从 `if` 到匹配的 `}`），然后交还控制权给上层。

⚠️ **约定：**
`parse_xxx()` 只能在“当前的下一个语法元素确实是 xxx”时调用，否则逻辑错误。
比如：如果当前 token 是 `while`，此时调用 `parse_ifStatement()` 就会失败。

---

## 🧾 四、输出形式：XML 格式

在 Jack 编译器的**第一个版本**中，CompilationEngine 的任务是输出语法结构的“漂亮打印”：

* 结果用 XML 标签包裹，例如：

```xml
<ifStatement>
<keyword> if </keyword>
...
</ifStatement>
```
* 这既方便验证语法是否正确，也能作为下一阶段（如 VM 代码生成）的输入。

---

## 🧠 五、算法逻辑（简化说明）

编译引擎的工作步骤：

1. 从 Tokenizer 读取一个 token；
2. 判断该 token 属于哪种语法结构（例如 class、if、let、expression 等）；
3. 调用相应的 `parse_xxx()`；
4. 函数递归展开语法树；
5. 最终输出 XML 或构建语法树对象。

---

## 🧩 六、延伸：解析树生成

后期版本中，这些 `parse_xxx()` 函数不再直接输出 XML，而是**生成解析树（parse tree）对象**。
然后再通过库函数把这棵树转成 XML 文件或用于代码生成。

---

\[口语化表达]
这页讲的是编译器里那个真正“干活”的核心模块——CompilationEngine。它接收 Tokenizer 拆好的小词（token），然后一个函数一个函数地去解析，比如 `parseClass()` 负责整个类、`parseIfStatement()` 负责 if 语句、`parseExpression()` 负责表达式。每个函数读完自己那部分代码，再递归调用别的解析函数，就像树状结构一样一路往下拆。第一版编译器的目标只是把结果按结构输出成 XML 文件，好检查语法有没有问题。简单来说，这个模块就是让编译器“看懂” Jack 程序结构的引擎，每个 parse\_xxx() 就像一个小专家，专门负责某一种语法块。


---

## 第 22 页

![第 22 页](Lecture_week9(1)_assets/page-022.png)

这页标题是 **“CompilationEngine: a recursive top-down parser for Jack”**，意思是 **“编译引擎：用于 Jack 语言的递归自顶向下解析器”**。
这页解释了 **Jack 编译器中负责“语法分析与输出生成”的核心模块——CompilationEngine** 的工作原理和设计原则。

---

## 🧩 一、CompilationEngine 的作用

**CompilationEngine** 是编译器的第二个主要组件（继 Tokenizer 之后）。
它负责：

* 从 **Jack Tokenizer** 接收词法分析后的输入（即一系列 token）；
* 按照 Jack 的语法规则（grammar）逐步解析这些 token；
* 输出结构化的结果（通常是 **XML 格式的语法树打印**，或用于后续的代码生成阶段）。

换句话说，它是编译器中执行“语法分析（parsing）”的部分。

---

## 🧱 二、主要机制：parse\_xxx() 解析函数系列

输出由一组以 **`parse_xxx()`** 命名的函数组成，每个函数对应一种语法结构（syntax construct）：

* `parse_class()`
* `parse_expression()`
* `parse_whileStatement()`
* `parse_ifStatement()`
* `parse_term()` 等等。

这些函数**递归地调用彼此**，构建出完整的语法层次结构，因此被称为\*\*“递归下降解析器（recursive top-down parser）”\*\*。

---

## 🔄 三、函数之间的“契约”（Contract）

每个 `parse_xxx()` 函数的职责：

1. 从输入读取符合 `xxx` 语法规则的部分；
2. 精确读取完这一结构的所有 token；
3. 读到 `xxx` 之后的第一个 token；
4. 产生对应的输出（例如 XML 标签或内部节点）。

> 例如：`parse_ifStatement()` 负责识别并解析整个 if 块（从 `if` 到匹配的 `}`），然后交还控制权给上层。

⚠️ **约定：**
`parse_xxx()` 只能在“当前的下一个语法元素确实是 xxx”时调用，否则逻辑错误。
比如：如果当前 token 是 `while`，此时调用 `parse_ifStatement()` 就会失败。

---

## 🧾 四、输出形式：XML 格式

在 Jack 编译器的**第一个版本**中，CompilationEngine 的任务是输出语法结构的“漂亮打印”：

* 结果用 XML 标签包裹，例如：

```xml
<ifStatement>
<keyword> if </keyword>
...
</ifStatement>
```
* 这既方便验证语法是否正确，也能作为下一阶段（如 VM 代码生成）的输入。

---

## 🧠 五、算法逻辑（简化说明）

编译引擎的工作步骤：

1. 从 Tokenizer 读取一个 token；
2. 判断该 token 属于哪种语法结构（例如 class、if、let、expression 等）；
3. 调用相应的 `parse_xxx()`；
4. 函数递归展开语法树；
5. 最终输出 XML 或构建语法树对象。

---

## 🧩 六、延伸：解析树生成

后期版本中，这些 `parse_xxx()` 函数不再直接输出 XML，而是**生成解析树（parse tree）对象**。
然后再通过库函数把这棵树转成 XML 文件或用于代码生成。

---

\[口语化表达]
这页讲的是编译器里那个真正“干活”的核心模块——CompilationEngine。它接收 Tokenizer 拆好的小词（token），然后一个函数一个函数地去解析，比如 `parseClass()` 负责整个类、`parseIfStatement()` 负责 if 语句、`parseExpression()` 负责表达式。每个函数读完自己那部分代码，再递归调用别的解析函数，就像树状结构一样一路往下拆。第一版编译器的目标只是把结果按结构输出成 XML 文件，好检查语法有没有问题。简单来说，这个模块就是让编译器“看懂” Jack 程序结构的引擎，每个 parse\_xxx() 就像一个小专家，专门负责某一种语法块。


---

## 第 23 页

![第 23 页](Lecture_week9(1)_assets/page-023.png)

这页标题是 **“CompilationEngine: a recursive top-down parser for Jack”**，意思是 **“编译引擎：用于 Jack 语言的递归自顶向下解析器”**。
这页解释了 **Jack 编译器中负责“语法分析与输出生成”的核心模块——CompilationEngine** 的工作原理和设计原则。

---

## 🧩 一、CompilationEngine 的作用

**CompilationEngine** 是编译器的第二个主要组件（继 Tokenizer 之后）。
它负责：

* 从 **Jack Tokenizer** 接收词法分析后的输入（即一系列 token）；
* 按照 Jack 的语法规则（grammar）逐步解析这些 token；
* 输出结构化的结果（通常是 **XML 格式的语法树打印**，或用于后续的代码生成阶段）。

换句话说，它是编译器中执行“语法分析（parsing）”的部分。

---

## 🧱 二、主要机制：parse\_xxx() 解析函数系列

输出由一组以 **`parse_xxx()`** 命名的函数组成，每个函数对应一种语法结构（syntax construct）：

* `parse_class()`
* `parse_expression()`
* `parse_whileStatement()`
* `parse_ifStatement()`
* `parse_term()` 等等。

这些函数**递归地调用彼此**，构建出完整的语法层次结构，因此被称为\*\*“递归下降解析器（recursive top-down parser）”\*\*。

---

## 🔄 三、函数之间的“契约”（Contract）

每个 `parse_xxx()` 函数的职责：

1. 从输入读取符合 `xxx` 语法规则的部分；
2. 精确读取完这一结构的所有 token；
3. 读到 `xxx` 之后的第一个 token；
4. 产生对应的输出（例如 XML 标签或内部节点）。

> 例如：`parse_ifStatement()` 负责识别并解析整个 if 块（从 `if` 到匹配的 `}`），然后交还控制权给上层。

⚠️ **约定：**
`parse_xxx()` 只能在“当前的下一个语法元素确实是 xxx”时调用，否则逻辑错误。
比如：如果当前 token 是 `while`，此时调用 `parse_ifStatement()` 就会失败。

---

## 🧾 四、输出形式：XML 格式

在 Jack 编译器的**第一个版本**中，CompilationEngine 的任务是输出语法结构的“漂亮打印”：

* 结果用 XML 标签包裹，例如：

```xml
<ifStatement>
<keyword> if </keyword>
...
</ifStatement>
```
* 这既方便验证语法是否正确，也能作为下一阶段（如 VM 代码生成）的输入。

---

## 🧠 五、算法逻辑（简化说明）

编译引擎的工作步骤：

1. 从 Tokenizer 读取一个 token；
2. 判断该 token 属于哪种语法结构（例如 class、if、let、expression 等）；
3. 调用相应的 `parse_xxx()`；
4. 函数递归展开语法树；
5. 最终输出 XML 或构建语法树对象。

---

## 🧩 六、延伸：解析树生成

后期版本中，这些 `parse_xxx()` 函数不再直接输出 XML，而是**生成解析树（parse tree）对象**。
然后再通过库函数把这棵树转成 XML 文件或用于代码生成。

---

\[口语化表达]
这页讲的是编译器里那个真正“干活”的核心模块——CompilationEngine。它接收 Tokenizer 拆好的小词（token），然后一个函数一个函数地去解析，比如 `parseClass()` 负责整个类、`parseIfStatement()` 负责 if 语句、`parseExpression()` 负责表达式。每个函数读完自己那部分代码，再递归调用别的解析函数，就像树状结构一样一路往下拆。第一版编译器的目标只是把结果按结构输出成 XML 文件，好检查语法有没有问题。简单来说，这个模块就是让编译器“看懂” Jack 程序结构的引擎，每个 parse\_xxx() 就像一个小专家，专门负责某一种语法块。


---

## 第 24 页

![第 24 页](Lecture_week9(1)_assets/page-024.png)

这三页展示了 **Jack 编译器的语法分析阶段（Syntax Analysis / Parsing）** 的核心内容：
从“函数结构的总体设计”到“实际实现一个 if 语句的解析函数”全过程。
下面我会逐页解释，并在最后总结成一个口语化归纳。

---

## 🧩 第一页：Jack Parser（Jack 语法分析器）

这页列出了 Jack 编译器的**所有解析函数（parse functions）**。

这些函数都返回一个 **AST（Abstract Syntax Tree，抽象语法树）节点**，用来表示程序的语法结构。
每个 `parse_xxx()` 函数对应 Jack 语言的一种语法成分。

### 🔹 左侧（声明、类定义相关）

* `parse_class()`：解析一个类的整体结构。
* `parse_class_var_decs()`：解析类变量声明（class-level variables）。
* `parse_static_var_dec()`、`parse_field_var_dec()`：区分静态变量与实例字段声明。
* `parse_type()`、`parse_vtype()`：解析变量类型（int、char、boolean、自定义类等）。
* `parse_subr_decs()`：解析子程序声明（constructor、function、method）。
* `parse_constructor()`、`parse_function()`、`parse_method()`：分别解析三种子程序类型。
* `parse_param_list()`：解析参数列表。
* `parse_subr_body()`：解析子程序体（包含变量声明和语句）。
* `parse_var_decs()`、`parse_var_dec()`：解析局部变量声明。

### 🔹 右侧（语句与表达式）

* `parse_statements()`、`parse_statement()`：解析一组语句或单个语句。
* `parse_let()`、`parse_if()`、`parse_while()`、`parse_do()`、`parse_return()`：分别对应五种语句类型。
* `parse_expr()`、`parse_term()`：解析表达式和表达式中的项。
* `parse_array_index()`：解析数组下标访问。
* `parse_subr_call()`：解析函数/方法调用。
* `parse_expr_list()`：解析函数调用参数列表。
* `parse_infix_op()`、`parse_unary_op()`：解析运算符（中缀或单目运算）。
* `parse_keyword_constant()`：解析关键字常量（如 `true`、`false`、`this`、`null`）。

👉 总体上，每个 `parse_xxx()` 都对应文法规则中的一个非终结符号（non-terminal）。

---

## 🧠 第二页：If Statement Example（if 语句示例）

这页展示了如何实现 `parse_if()` 函数，也就是一个语法分析器如何识别并构造 if 语法树。

### 🔹 文法规则

```
if ::= 'if' '(' expr ')' '{' statements '}' ( 'else' '{' statements '}' )?
```

解释：

* 一个 if 语句以 `if` 开头；
* 括号内是条件表达式 `expr`；
* 后面的大括号 `{ ... }` 内是 if 成立时执行的语句；
* 可选部分 `( ... )?` 是 else 块。

### 🔹 对应的解析函数实现

```c
ast parse_if() {
mustbe(tk_if);
mustbe(tk_lrb);
ast _expr = parse_expr();  // 解析条件表达式
mustbe(tk_rrb);

mustbe(tk_lcb);
ast _then = parse_statements();  // 解析 if 主体语句
mustbe(tk_rcb);

// 检查是否有 else 块
if (have(tk_else)) {
mustbe(tk_else);
mustbe(tk_lcb);
ast _else = parse_statements();  // 解析 else 语句块
mustbe(tk_rcb);
return create_if_else(_expr, _then, _else);
}

return create_if(_expr, _then);
}
```

### 🔹 功能说明：

* `mustbe(tk_if)`：确保当前 token 是 “if”，否则报错。
* `parse_expr()`：调用表达式解析函数，递归构造条件节点。
* `parse_statements()`：递归调用语句解析。
* 若检测到 `else`，则再递归解析 else 块。
* 最终返回一个 AST 节点，记录 if 条件和对应的代码块。

---

## ⚙️ 第三页：Syntax Analysis: Parsing

这一页是章节封面，标题为：

> **Syntax Analysis: Parsing（语法分析：解析）**

它标志着这一部分的核心主题：
语法分析（Parsing）是编译器中承接词法分析之后、生成结构化语法树（AST）的关键阶段。
所有后续的语义分析、代码生成都以这里构建的 AST 为基础。

---

## 🧩 综合理解

这三页连在一起说明了 Jack 编译器的语法分析体系：

1. **词法分析器（Tokenizer）** 先把代码拆成 token；
2. **语法分析器（Parser）** 用 `parse_xxx()` 函数递归解析这些 token；
3. 每个函数只负责自己那一类语法（类、函数、表达式、语句等）；
4. 最后构建出一棵完整的 **抽象语法树（AST）**，描述整个 Jack 程序的结构。

---

\[口语化表达]
这三页讲的就是 Jack 编译器“怎么读懂程序结构”。
首先有一堆 `parse_xxx()` 函数，每个都负责解析一种语法，比如类、函数、if 语句、表达式之类。所有这些函数递归地互相调用，一层层拆出代码结构。接着第二页举了个例子，展示 `parse_if()` 怎么实现：先匹配 `if`，再读括号里的条件表达式，然后解析花括号内的语句，如果发现有 `else` 再多解析一段。最后组合成一个 if 语法树节点。第三页只是提醒我们，这整个过程属于“语法分析”阶段。
一句话总结就是——**这些函数让编译器从一行行 Jack 代码里“看懂结构”，自动拼出程序的语法树。**


---

## 第 25 页

![第 25 页](Lecture_week9(1)_assets/page-025.png)

这页标题是 **“Summary and next step（总结与下一步）”**，是对前面讲的 **Jack 编译器语法分析部分（Syntax Analysis）** 的总结，以及介绍接下来的阶段——**代码生成（Code Generation）**。
它对应《Nand2Tetris》课程中 Jack 编译器的 **第10章与第11章** 内容衔接。

---

## 🧩 一、总体结构回顾：编译器的两大阶段

图中展示了 **Jack 编译器（Jack Compiler）** 的前端结构：

```
Jack Program → Tokenizer → Parser → Code Generation → VM Code
```

* **Jack Program（源程序）**：程序员写的 Jack 源代码。
* **Tokenizer（词法分析器）**：把源码拆成 token（关键字、符号、变量名等）。
* **Parser（语法分析器）**：根据语法规则组合这些 token，生成结构化的语法树（AST）。
* **Code Generation（代码生成器）**：把语法树转化为 VM 代码（虚拟机指令）。

📘 **Chapter 10（第10章）** 只到 Parser 阶段，输出 XML 文件用于验证语法结构是否正确；
📙 **Chapter 11（第11章）** 才进入 Code Generation 阶段，把语法结构真正翻译成能执行的虚拟机代码（VM code）。

---

## 🧠 二、Syntax Analysis（语法分析）

* **作用**：理解语法结构（syntax）。
它告诉编译器“这段代码在逻辑上是什么结构”，比如是 if 语句？while 循环？还是表达式？
* **输出**：一种**结构化语法表示**（XML 或内部语法树）。

---

## ⚙️ 三、Code Generation（代码生成）

* **作用**：将语法结构“翻译”为语义可执行的虚拟机代码（VM code）。
* **重点**：不再只是“理解代码”，而是**构造代码**。
例如：

```jack
let x = y + 2;
```

语法分析阶段：知道它是一个“赋值语句”。
代码生成阶段：生成可执行的 VM 指令，比如：

```
push y
push constant 2
add
pop x
```

---

## 🔧 四、Code Generation 的两个主要挑战

> The code generation challenge:
> Extend the syntax analyzer into a full compiler that generates executable VM code.

要把“语法分析器”变成真正的“编译器”，需要解决两个核心问题：

1. **Handling data（处理数据）**

* 包括变量作用域（local / static / field）、常量、数组、对象的访问方式。
* 比如如何把 `let arr[i] = x;` 转成对应的内存操作指令。

2. **Handling commands（处理命令）**

* 包括函数调用、控制流（if / while / return）等执行逻辑。
* 编译器需要生成正确的 VM 命令来实现控制流的跳转和调用。

---

## 🔁 五、总结与下一步目标

* 目前的编译器（Chapter 10）输出 XML，仅验证语法正确。
* 下一步（Chapter 11）要扩展成能**输出可运行的 VM 代码**的完整编译器。
* 所以接下来的任务是：

* 把语法树节点和 VM 指令一一对应；
* 实现能处理变量、表达式、命令的代码生成模块。

---

\[口语化表达]
这一页其实是在总结前面的内容，并告诉你接下来要干嘛。前面我们已经让编译器“看懂”Jack 程序的语法结构，也就是语法分析这一步；现在要进入下一阶段——让它“能写出可执行的指令”，也就是代码生成阶段。之前的版本只是输出 XML 文件，用来检查语法树对不对；接下来的目标是输出 VM 代码，也就是能真的跑的指令。
要做到这一点有两个难点：一个是处理数据（像变量、数组、对象），另一个是处理命令（像函数调用、if、while）。简单说，这页告诉你：编译器到现在为止能“看懂”程序了，下一步它得学会“写代码”。


---

## 第 26 页

![第 26 页](Lecture_week9(1)_assets/page-026.png)

这页标题是 **“Syntax analysis (review)”（语法分析回顾）**，主要内容是复习前面语法分析阶段的成果，并引出接下来的**代码生成（code generation）**。
它展示了编译器如何从理解程序结构（语法层面）过渡到真正“生成可执行代码”的阶段。

---

## 🧩 一、左侧：语法分析示例

左上角的 Jack 源代码：

```jack
class Bar {
method Fraction foo(int y) {
var int temp;     // a variable
let temp = (xxx + 12) * -63;
...
}
}
```

这是一个 Jack 程序片段。编译器的语法分析器（Syntax Analyzer）会读取它，通过词法分析（Tokenizer）与语法分析（Parser），生成结构化的语法表示。

---

## 🧱 二、右侧：语法分析输出（XML 格式）

右边展示了语法分析器的输出结果（XML），它是源代码的结构化版本。
例如：

```xml
<vardecl>
<keyword> var </keyword>
<type><keyword> int </keyword></type>
<varName><identifier> temp </identifier></varName>
<symbol> ; </symbol>
</vardecl>
```

代表声明变量 `var int temp;`

再比如：

```xml
<letStatement>
<keyword> let </keyword>
<varName><identifier> temp </identifier></varName>
<symbol> = </symbol>
<expression>
<term><symbol> ( </symbol>
<expression>
<term><varName><identifier> xxx </identifier></varName></term>
<op><symbol> + </symbol></op>
<term><integerConstant> 12 </integerConstant></term>
</expression>
<symbol> ) </symbol></term>
<op><symbol> * </symbol></op>
<expression>
<term><unaryOp><symbol> - </symbol></unaryOp>
<integerConstant> 63 </integerConstant></term>
</expression>
</expression>
<symbol> ; </symbol>
</letStatement>
```

代表 `let temp = (xxx + 12) * -63;`
👉 编译器通过语法分析阶段，**已经完全理解了语句的结构与层次关系**（比如表达式中的括号、加号、乘号的嵌套顺序）。

---

## 🧠 三、代码生成挑战（The code generation challenge）

接下来要解决的问题是：
“编译器不仅要**看懂语法**，还要能**翻译成目标语言的操作**（VM 指令）。”

### 关键要点：

1. **程序的本质**：
程序 = 一连串操作（operations）去**操作数据（data）**。

2. **编译器的任务**：
把语法分析阶段理解到的每一个操作（如赋值、加法、调用函数等）
➜ 转换成目标语言（虚拟机语言 VM）的具体指令。

3. **需要生成代码的两类操作**：

* **Handling data**：变量、常量、数组、对象等的访问与存储。
* **Handling operations**：表达式计算、逻辑判断、函数调用、控制流（if/while）等。

4. **下一步目标**：
将当前的 **Syntax Analyzer（语法分析器）** 改造成真正的 **Compiler（编译器）**：

* 不再只是生成 XML（用于语法验证）
* 而是生成 **可执行的 VM Code（虚拟机代码）**

---

## 🔧 四、总结：从“理解”到“执行”

到目前为止：

* 编译器已经能理解 Jack 程序的结构（通过语法分析）；
* 下一步要让编译器能根据这种理解，**生成真正可运行的代码**；
* 这意味着它要学会如何把程序里的“逻辑结构”转成“计算机能执行的命令”。

---

\[口语化表达]
这页其实在总结语法分析阶段，顺便为下一步——代码生成——铺垫。
我们看到左边是一段 Jack 代码，右边是语法分析器生成的 XML 结构，也就是编译器已经能“看懂”每个变量、表达式、括号、操作符的层次关系。
但目前它只是“看懂”了，还不会“动手”。所以接下来的目标就是让编译器学会把这些结构转成 VM 指令，比如让它能把 `let temp = (xxx + 12) * -63;` 变成一串真正能执行的虚拟机代码。
一句话总结就是：**编译器到这里已经会读懂代码了，接下来要学会写出机器能执行的命令。**


---

## 第 27 页

![第 27 页](Lecture_week9(1)_assets/page-027.png)

这页幻灯片标题是 **“Code Generation”（代码生成）**，它是整个编译器开发流程中的下一个关键阶段。
这一页本身是章节封面，没有具体内容，但它的作用是提示我们即将进入**编译器后端**——也就是让编译器真正“产出可执行结果”的部分。
下面我会详细解释“代码生成”的概念与意义。

---

## 🧩 一、代码生成（Code Generation）是什么

代码生成是**编译器后端的主要任务**。
在这个阶段，编译器已经完成了前面的分析工作，包括：

1. **词法分析（Lexical Analysis）**：把源代码拆成 token；
2. **语法分析（Syntax Analysis）**：识别代码的结构，形成语法树（AST）；
3. **语义理解（Semantic Understanding）**：弄清楚变量、作用域、表达式的含义。

这些步骤让编译器“理解”了代码。
但理解还不够 —— 接下来要做的是：

👉 **把“理解”的结果翻译成目标语言（Target Language）**。

在 Jack 编译器里，目标语言是 **VM（Virtual Machine）代码**。
这些 VM 指令将被后续的虚拟机执行，最终在 Hack 硬件平台上运行。

---

## ⚙️ 二、代码生成阶段的核心任务

在代码生成阶段，编译器要完成几件事：

1. **把语法树中的操作转化为指令**
例如，Jack 中的：

```jack
let x = y + 2;
```

会被转译为 VM 指令：

```
push y
push constant 2
add
pop x
```

2. **管理内存与变量位置**
编译器需要知道每个变量属于哪种作用域（local / argument / static / field），并映射到正确的内存段。

3. **生成控制流结构**
像 if、while、return 这样的语句，都会对应不同的跳转和标签逻辑：

* if → 生成条件判断与跳转指令
* while → 生成循环标签与跳转
* return → 生成返回值与堆栈恢复

4. **函数与方法调用**
编译器要正确生成函数调用（包括参数传递和返回处理）对应的 VM 指令。

---

## 🧠 三、和语法分析的区别

| 阶段                        | 目标      | 输出                |
| ------------------------- | ------- | ----------------- |
| **语法分析（Syntax Analysis）** | 理解程序结构  | XML / 抽象语法树 (AST) |
| **代码生成（Code Generation）** | 构造可执行逻辑 | 可运行的 VM 代码        |

简单来说，

* 语法分析阶段是“编译器读懂代码”；
* 代码生成阶段是“编译器写出机器能懂的代码”。

---

## 🚀 四、在 Jack 编译器中的意义

在《Nand2Tetris》课程的上下文中，这一阶段（Chapter 11）就是让我们把前面写好的语法分析器升级为真正的编译器：

* 不再输出 XML（纯结构化文本）；
* 而是输出可以被 VM 运行的代码文件（.vm）。

例如：

```jack
class Main {
function void main() {
do Output.printString("Hello, World!");
return;
}
}
```

经过代码生成阶段后，编译器会输出一系列 VM 指令，实现打印功能。

---

\[口语化表达]
这一页其实是一个分界线，意思是我们要进入编译器的第二阶段——让它真正“写代码”。
前面我们已经教会编译器去理解 Jack 语言的语法结构，现在它要学会“输出”能执行的代码，也就是 VM 指令。这个阶段叫“代码生成”。
在这个阶段，编译器会把每个表达式、if、while、函数调用都翻译成虚拟机能跑的指令。
简单说：之前编译器只是能“看懂程序”，现在它要“自己写出程序”，让计算机能真的执行。


---

## 第 28 页

![第 28 页](Lecture_week9(1)_assets/page-028.png)

这页标题是 **“Memory segments (review)”（内存段回顾）**，主要是在复习 VM（虚拟机）语言中的**内存模型**。
理解这部分非常重要，因为代码生成（Code Generation）阶段会频繁操作这些“内存段”（memory segments），用于存储和访问变量、参数、对象属性、常量等数据。

---

## 🧠 一、什么是 Memory Segment（内存段）

在虚拟机（VM）语言中，内存被分成不同的区域（segment），每个区域负责保存不同类型的数据。
VM 程序通过两条基本命令与这些内存段交互：

```vm
push segment i   // 从 segment[i] 读取值，放入栈顶
pop segment i    // 从栈顶弹出值，存入 segment[i]
```

其中：

* `segment` 表示要访问的内存段；
* `i` 是一个非负整数，表示该段内的第几个位置（index）。

---

## 💾 二、八种主要内存段及其作用

| Segment 名称   | 用途说明                                      |
| ------------ | ----------------------------------------- |
| **static**   | 存储全局变量（同一个类的所有函数共享）。相当于类级别变量。             |
| **argument** | 存储当前函数的参数（即函数调用时传入的参数值）。                  |
| **local**    | 存储当前函数内部定义的局部变量。                          |
| **this**     | 存储当前对象的属性（相当于面向对象编程中的 `this`）。            |
| **that**     | 存储指向数组元素或其他引用的地址（用于访问对象中的特定数据）。           |
| **constant** | 存储常量值（0 到 32767 范围内的整数），不是实际内存段，而是一个“伪段”。 |
| **pointer**  | 保存 `this` 与 `that` 的基地址，让程序能动态改变对象或数组的指向。 |
| **temp**     | 一个固定大小（8个单元）的临时段，用来存储中间计算结果，供所有 VM 函数通用。  |

---

## ⚙️ 三、举个例子：push 与 pop 的操作逻辑

例如：

```vm
push local 2
```

表示：
从当前函数的局部变量段（local segment）的第 2 个位置取出值，放入栈顶。

再比如：

```vm
pop argument 0
```

表示：
从栈顶取出值，存入当前函数参数段（argument segment）第 0 个位置（即第一个参数）。

---

## 🔩 四、这些内存段与 Jack 语言变量的关系

在 Jack 语言中，不同类型的变量会被编译到不同的 segment：

| Jack 变量类型        | 对应 VM 段            |
| ---------------- | ------------------ |
| `static`         | → static segment   |
| `field`（对象属性）    | → this segment     |
| `var`（函数内局部变量）   | → local segment    |
| `argument`（参数变量） | → argument segment |

所以在生成 VM 代码时，编译器需要根据变量种类，决定使用哪个内存段。

---

## 🧩 五、constant、pointer、temp 的特殊用途

* **constant**：直接把一个常量值放入栈顶。例如：

```
push constant 10
```

就是在栈中压入数字 10。

* **pointer**：有两个索引值——`0` 代表 `this`，`1` 代表 `that`。
比如：

```
push pointer 0   // 压入 this 的地址
push pointer 1   // 压入 that 的地址
```

* **temp**：可用于存储临时计算结果。例如：

```
pop temp 0
push temp 0
```

相当于把一个中间结果暂时保存，然后再取回使用。

---

\[口语化表达]
这页讲的是 VM 虚拟机里的“内存分区”，也就是程序运行时数据都放哪儿。编译器生成的代码会频繁用到这些内存段。
简单来说，`push` 是把数据放到栈顶，`pop` 是从栈顶拿数据存回内存。不同类型的变量（比如参数、局部变量、对象属性、全局变量）各自属于不同的内存段：像 `local` 放函数里的局部变量，`argument` 放函数参数，`this` 对应对象属性，`static` 对应类的全局变量，还有 `temp`、`pointer` 这样的特殊段。
一句话总结就是：**这些内存段就像程序的不同“抽屉”，每种数据都放在它自己的格子里，而 VM 的 push/pop 命令就是在这些抽屉之间搬运数据。**


---

## 第 29 页

![第 29 页](Lecture_week9(1)_assets/page-029.png)

这页标题是 **“Code generation example”（代码生成示例）**，它通过一个非常清晰的例子展示了编译器从\*\*源代码（Jack 语言）→ 语法分析结果（XML）→ VM 代码（可执行指令）\*\*的完整过程。
这是编译器“理解代码并生成可运行程序”的一个核心示范。

---

## 🧩 一、左边：Jack 源代码

左上角是 Jack 程序中一个简单的方法：

```jack
method int foo() {
var int x;
let x = x + 1;
...
}
```

这个函数 `foo()` 定义了一个局部变量 `x`，然后让 `x` 的值加 1 并重新赋给自己。

---

## 🧠 二、中间：语法分析（Syntax Analysis）

经过 **语法分析器（Syntax Analyzer）** 的处理后，编译器把这段代码分解成结构化的 XML 表示，显示程序的语法组成层次：

```xml
<letstatement>
<keyword> let </keyword>
<varName><identifier> x </identifier></varName>
<symbol> = </symbol>
<expression>
<term>
<varName><identifier> x </identifier></varName>
</term>
<op><symbol> + </symbol></op>
<term>
<integerConstant> 1 </integerConstant>
</term>
</expression>
</letstatement>
```

这一部分表示：

* `let` 是一个赋值语句；
* 目标变量是 `x`；
* 等号右边是表达式 `x + 1`；
* 这个表达式由两个 term（术语单元）组成：
一个是变量 `x`，另一个是整数常量 `1`；
* 它们之间的操作符是 `+`。

这一步说明编译器**已经理解了代码的语法结构**（但还没生成可运行的机器逻辑）。

---

## ⚙️ 三、右下角：代码生成（Code Generation）

编译器接下来根据 XML 的语法结构生成对应的 VM 代码。
输出的结果是：

```vm
push local 0
push constant 1
add
pop local 0
```

解释如下：

| 指令                | 含义                                    |
| ----------------- | ------------------------------------- |
| `push local 0`    | 将局部变量 `x`（位于 local 段第 0 个位置）的当前值压入栈顶。 |
| `push constant 1` | 将常数 `1` 压入栈顶。                         |
| `add`             | 弹出两个数（栈顶的两个值），执行相加操作，把结果重新压入栈顶。       |
| `pop local 0`     | 把栈顶结果弹出，并存回局部变量 `x` 的内存位置。            |

这就是执行 `x = x + 1` 在 VM 级别的真正逻辑。

---

## 🧮 四、为什么这样生成？

在虚拟机语言中，所有运算都通过 **栈（stack）** 完成：

* 所有操作数（变量或常量）都先被压入栈；
* 执行算术操作（如加法、乘法）时，会从栈顶弹出数据；
* 结果再压入栈；
* 最后再将结果存回目标变量所在的内存段。

所以 “`let x = x + 1`” 就被分解为：

1. 把 `x` 的当前值压栈；
2. 把 `1` 压栈；
3. 相加；
4. 把结果再存回 `x`。

---

## 🔩 五、底部注释说明

底部的说明指出：

> “note that x is the first local variable declared in the method”
> 意思是：“注意，`x` 是此方法中声明的第一个局部变量”，
> 所以它在 VM 中的编号是 `local 0`。
> （编译器会为每个局部变量分配一个索引号，从 0 开始。）

---

## 🧠 六、总结：完整的编译流程演示

这一页展示了编译器三个阶段的连贯关系：

| 阶段                    | 输入        | 输出          |
| --------------------- | --------- | ----------- |
| 语法分析（Syntax Analysis） | 源代码（Jack） | XML 结构（语法树） |
| 代码生成（Code Generation） | 语法树       | VM 指令（可执行）  |

---

\[口语化表达]
这页其实是在告诉我们，编译器是怎么把一句简单的 Jack 代码，比如 `let x = x + 1;`，一步步变成真正能执行的 VM 代码的。
首先，语法分析器会读懂这句话的结构——知道这是个赋值语句，左边是变量 `x`，右边是一个加法表达式 `x + 1`。
接着，代码生成阶段就会把它翻译成栈式指令：先把 `x` 的值压到栈上，再压入常量 `1`，然后执行 `add`，最后把结果存回 `x`。
所以最终的四行 VM 代码就等价于 Jack 语言的那一句话。
一句话总结：**编译器就是把“理解代码的逻辑结构”变成“执行这些逻辑的机器步骤”。**


---

## 第 30 页

![第 30 页](Lecture_week9(1)_assets/page-030.png)

这页的标题是 **“Handling variables”（处理变量）**，讲的是编译器在“看到一个变量”时，需要弄清楚它的两个关键属性，才能正确地分配内存和生成代码。
也就是说，编译器在翻译源代码（比如 Jack 语言）时，必须先**理解变量是什么**、**它属于哪一类**，这样才能知道该变量该放到哪块内存、怎么访问它。

---

## 🧩 一、编译器在处理变量时要回答两个问题

当编译器遇到一个变量，比如 `x`，它要回答两个核心问题：

---

### ✅ 1️⃣ 变量的数据类型（Data Type）是什么？

> “What is x’s data type?”

* 数据类型可以是**基本类型（primitive type）**，如 `int`、`char`、`boolean`；
也可以是**自定义类型（ADT，抽象数据类型）**，比如 `Fraction` 或其他类名。

例如：

```jack
var int count;
var Fraction f;
```

这里：

* `count` 的数据类型是 `int`（基本类型）；
* `f` 的数据类型是 `Fraction`（类类型）。

---

编译器为什么要知道数据类型？
➡️ 因为不同类型的变量在内存中占用空间不同，表示方式也不同。
编译器需要这些信息才能：

* 正确地在 RAM（内存）中分配存储空间；
* 生成与类型匹配的机器或 VM 指令；
* 进行类型检查（例如防止把布尔值赋给整型变量）。

---

### ✅ 2️⃣ 变量的“种类”（Kind）是什么？

> “What kind of variable is x?”

* `local`：函数或方法内部声明的局部变量；
* `argument`：函数的参数；
* `field`：对象的成员变量；
* `static`：类的静态变量（全局共享）。

例如：

```jack
class Example {
static int counter;      // static
field int value;         // field
method void setValue(int x) {
var int temp;        // local
let value = x;       // argument x
}
}
```

在这个例子里，`counter`、`value`、`x`、`temp` 就分别属于不同的“变量种类”。

---

编译器为什么要知道变量的 kind？
➡️ 因为每种变量要放在不同的 **memory segment（内存段）**：

| 变量种类       | 对应的 VM 内存段       | 生命周期     |
| ---------- | ---------------- | -------- |
| `static`   | static segment   | 程序整个运行期间 |
| `field`    | this segment     | 对象存在期间   |
| `argument` | argument segment | 函数调用期间   |
| `local`    | local segment    | 函数调用期间   |

编译器利用这些信息来：

* 把变量映射到正确的内存区域；
* 生成正确的 push/pop 指令；
* 管理变量的生命周期（比如什么时候创建、什么时候销毁）。

---

## 💡 三、总结逻辑

当编译器读到一个变量名 `x` 时，它必须先查一下“符号表”（symbol table）来知道：

1. `x` 的 **类型（type）** 是什么；
2. `x` 的 **种类（kind）** 是什么；
3. `x` 的 **索引号（index）** 是多少（在它的段内的位置）。

只有这样，编译器才能正确地输出 VM 代码，比如：

```vm
push local 0
pop this 2
```

这些都依赖于前面的“变量识别”步骤。

---

\[口语化表达]
这页讲的是：当编译器看到一个变量，比如 `x`，它不能光知道有个名字叫 `x`，还得搞清楚两件事。
第一，`x` 是什么类型的？比如它是 `int` 还是 `Fraction` 这样的类。因为不同类型在内存里占的空间不一样。
第二，`x` 是哪种变量？是函数里的局部变量、参数，还是对象的属性、类的静态变量？这决定了它该放在哪个内存段，比如放到 local、argument、this 或 static。
编译器只有知道这两点，才能分配内存、生成正确的指令，也能知道这个变量该活多久、在哪儿能访问。
一句话总结：**编译器在处理变量时，得先弄清楚“它是什么”和“它属于哪儿”，才能正确地存、取和用它。**


---

## 第 31 页

![第 31 页](Lecture_week9(1)_assets/page-031.png)

这页标题是 **“Handling variables: mapping them on memory segments”（处理变量：把它们映射到内存段）**，是上一页内容的延伸。它讲的是——**当编译器在处理类（class）时，必须把每个变量分配到合适的内存区域（memory segment）里，并给它一个编号（index）**，以便在后续生成 VM 代码时正确访问。
这页用一个完整的例子解释了这种“变量到内存映射（variable-to-memory mapping）”的过程。

---

## 🧩 一、示例程序：BankAccount 类

```jack
class BankAccount {
// Class variables（类变量）
static int nAccounts;
static int bankCommission;

// Object fields（对象字段）
field int id;
field String owner;
field int balance;

method void transfer(int sum, BankAccount from, Date when) {
var int i, j;       // local variables（局部变量）
var Date due;       // local variable (自定义类型)
let balance = (balance + sum) - commission(sum * 5);
// More code...
}
}
```

这段 Jack 程序中有几种不同种类的变量：

* `static` → 类变量（所有对象共享）
* `field` → 对象的成员变量（每个对象独立）
* `argument` → 方法参数
* `var` → 局部变量（仅在方法内部可见）

---

## 💾 二、目标语言的内存模型（Target Memory Segments）

右上角的说明写着：

> * 目标语言使用 **8 个内存段（memory segments）**。
> * 每个内存段都可以看作是一个**带索引的 16 位值序列**，比如 `static 0`, `static 1`, `static 2` 等。

这些内存段包括：

```
static, argument, local, this, that, constant, pointer, temp
```

---

## ⚙️ 三、编译时映射（Mapping）

当编译器编译这个类时，它必须创建一张“映射表”，把每个变量放到正确的内存段中。

表格如下：

| 变量类型                   | 示例变量                          | 映射到的内存段                                    |
| ---------------------- | ----------------------------- | ------------------------------------------ |
| **Class variables**    | `nAccounts`, `bankCommission` | → `static 0`, `static 1`                   |
| **Object fields**      | `id`, `owner`, `balance`      | → `this 0`, `this 1`, `this 2`             |
| **Argument variables** | `sum`, `bankAccount`, `when`  | → `argument 1`, `argument 2`, `argument 3` |
| **Local variables**    | `i`, `j`, `due`               | → `local 0`, `local 1`, `local 2`          |

> 📌 注意：
>
> * `argument` 从编号 1 开始，因为编号 0 通常是 `this`（当前对象本身）。
> * 编译器在符号表（symbol table）里维护这些映射，后面生成 VM 指令时就能直接使用。

---

## 🧠 四、为什么要映射？

在 VM 语言中，访问变量时并不会直接使用它的名字，而是通过它在内存段中的“位置”：

* `push local 0` → 访问第一个局部变量；
* `push this 2` → 访问对象的第三个字段；
* `pop static 1` → 更新类的第二个静态变量。

所以，**变量名在编译之后不再存在**，取而代之的是“内存段 + 索引号”的组合。

这个映射步骤是编译器把源代码“具体化”到内存结构的关键。

---

## 🔩 五、总结

编译器会根据变量的“种类（kind）”把它们分配到不同的内存段中：

* `static` → 类级共享区
* `field` → 当前对象的属性区 (`this`)
* `argument` → 函数参数区
* `local` → 方法内部的临时存储区

每个段里的变量都有编号（index），方便后续访问。

---

\[口语化表达]
这页其实就是在讲：编译器在编译类的时候，要给每个变量找个“家”。
像类的静态变量就放在 `static` 段，对象的属性放在 `this` 段，函数的参数放在 `argument` 段，函数内部的临时变量放在 `local` 段。
编译器还会给它们编上号，比如第一个是 `local 0`，第二个是 `local 1`。这样在生成 VM 指令的时候，就不用记名字，只要说“去 local 1 拿值”就行了。
一句话总结：**编译器就像给每个变量分配座位表——它决定每个变量坐在哪个内存段的第几号位置。**


---

## 第 32 页

![第 32 页](Lecture_week9(1)_assets/page-032.png)

这页标题是 **“Handling variables: symbol tables”（处理变量：符号表）**，主要讲的是编译器在处理变量时，如何使用 **符号表（Symbol Table）** 来记录并管理每个变量的类型、类别和位置，从而在生成代码时正确访问这些变量。
这是编译器内部非常核心的机制，属于语义分析（semantic analysis）和代码生成之间的桥梁。

---

## 🧩 一、背景：编译器如何“记住”变量

当我们写一个类或方法时，比如这个 `BankAccount` 类：

```jack
class BankAccount {
static int nAccounts;
static int bankCommission;

field int id;
field String owner;
field int balance;

method void transfer(int sum, BankAccount from, Date when) {
var int i, j;
var Date due;
let balance = (balance + sum) - commission(sum * 5);
// ...
}
}
```

编译器需要“知道”：

* 每个变量叫什么名字；
* 它是什么类型（type）；
* 它属于哪种类别（kind）；
* 它在该类别中的编号（index）。

比如：

* `nAccounts` 是 `static` 变量；
* `id` 是 `field`；
* `sum` 是 `argument`；
* `i` 是 `local`。

为了存这些信息，编译器使用一种数据结构——**符号表（symbol table）**。

---

## 📘 二、符号表的概念

符号表是编译器用来**存储程序中变量信息**的数据表。
每一个作用域（scope）都会有自己的符号表，比如：

* 类级作用域（class-scope）
* 方法级作用域（method-scope）

不同层级的符号表会形成一个“链表结构”，嵌套在一起。

---

## 🧠 三、示例中的两个符号表

### 🏷️ 1️⃣ 类作用域符号表（Class-scope symbol table）

这个表记录类级别的变量，也就是 `static` 和 `field` 类型：

| Name           | Type   | Kind   | # |
| -------------- | ------ | ------ | - |
| nAccounts      | int    | static | 0 |
| bankCommission | int    | static | 1 |
| id             | int    | field  | 0 |
| owner          | String | field  | 1 |
| balance        | int    | field  | 2 |

解释：

* `nAccounts` 和 `bankCommission` 被分配到 `static 0`、`static 1`；
* `id`、`owner`、`balance` 被分配到 `this 0`、`this 1`、`this 2`；
* 它们属于类的长期内存。

---

### 🧾 2️⃣ 方法作用域符号表（Method-scope symbol table）

这个表记录方法内部的变量，包括参数（arguments）和局部变量（vars）：

| Name | Type        | Kind     | # |
| ---- | ----------- | -------- | - |
| this | BankAccount | argument | 0 |
| sum  | int         | argument | 1 |
| from | BankAccount | argument | 2 |
| when | Date        | argument | 3 |
| i    | int         | var      | 0 |
| j    | int         | var      | 1 |
| due  | Date        | var      | 2 |

说明：

* 参数部分是 `argument` 段，从编号 0 开始；
* 注意 `this` 也在参数列表中（自动传入当前对象）；
* 方法内部定义的变量（`i`, `j`, `due`）放在 `local` 段，对应 `var`；
* 每个变量都有唯一编号，方便编译器生成类似：

```
push argument 1   // sum
push local 0      // i
```

---

## ⚙️ 四、编译器如何使用符号表

底部文字解释了编译器的做法：

* 编译器维护一个**符号表链表（linked list of symbol tables）**。
每进入一个新的作用域（例如函数内部），就创建一个新的表；
每退出作用域，就销毁这个表。
这保证了**局部变量不会与全局变量混淆**。

* 查找变量（identifier lookup）时：
编译器先从当前作用域查找；
如果找不到，再往外层（上一级作用域）查。
这就是“作用域链”的工作方式。

---

## 🔍 五、为什么重要

符号表是编译器的“记忆系统”。
在编译期间：

* 它告诉编译器“这个变量是什么、在哪一段”；
* 它支持变量重名的处理（因为有作用域区分）；
* 它让编译器能正确生成代码，比如：

```
push this 2  // balance
push argument 1  // sum
add
```

---

## 🧩 六、总结

| 概念                | 说明               |
| ----------------- | ---------------- |
| 符号表（symbol table） | 记录变量的名称、类型、类别、编号 |
| 类作用域表             | 存放 static、field  |
| 方法作用域表            | 存放 argument、var  |
| 查找机制              | 从当前表向上逐层查找       |
| 功能                | 为代码生成提供变量的内存定位信息 |

---

\[口语化表达]
这页讲的是编译器是怎么“记住”和管理变量的。
每当你写一个类或函数，编译器都会建一张“符号表”，就像一个表格，里面写着每个变量叫什么、是什么类型、属于哪种变量（比如 static、field、argument、var），还有它在内存中的编号。
像类里面的变量会放到 class-scope 的表里，函数里的变量会放到 method-scope 的表里。
当程序在执行 `balance = balance + sum` 时，编译器就查这张表，知道 `balance` 在 `this 2` 这个位置，`sum` 在 `argument 1`，于是就能生成正确的指令。
一句话总结：**符号表就是编译器的大脑，用来记住每个变量是谁、在哪儿、怎么找。**


---

## 第 33 页

![第 33 页](Lecture_week9(1)_assets/page-033.png)

这页标题是 **“Symbol Table Interface（符号表接口）”**，说明一个最小可用的“符号表”模块应该提供哪些功能，以支持编译器在**进入/退出作用域**时创建与销毁表、**把标识符写入表**以及**按名查询**等基本操作。符号表保存的信息通常包括：`Name`（标识符名）、`Type`（数据类型）、`Kind`（变量种类：static/field/argument/var 等）、`Index`（在对应内存段中的编号）。

---

## 符号表的最小接口与使用时机

### 1) `create()`

* **做什么**：创建一张**空**的符号表。
* **何时调用**：在**解析一个新的作用域之前**使用。
典型场景：开始解析一个**类 / 构造器 / 函数 / 方法**时，为该作用域新建表（方法级表会“罩在”类级表之上）。

### 2) `delete()`

* **做什么**：当作用域结束时，删除（或弹出）这张符号表。
* **何时调用**：在**解析完**一个**类 / 构造器 / 函数 / 方法**之后，退出作用域时调用，避免标识符“泄漏”到外层。

### 3) `insert(name, type, kind)`（插入）

* **做什么**：把一个新条目写入当前表，并为其分配 `Index`（同类目下从 0 递增）。
* **期望行为**：最好能**检测重复定义**（同一作用域、同名同 kind 冲突要报错/警告）。
* **典型条目**：变量声明、参数、字段、静态成员、`this` 参数等。

### 4) `lookup(name)`（查找）

* **做什么**：在**当前表**查找；若找不到，沿着**外层表**（作用域链）逐级向上查。
* **返回**：若找到，返回该条目的 `(type, kind, index)`；若未找到，可返回 `null/None` 或抛错（缺失标识符）。

---

## 作用域与生命周期（为什么要有 create/delete）

* 进入新作用域（如进入方法体），**create** 新表；声明的参数与局部变量**只存在于该表**。
* 离开作用域（方法解析结束），**delete** 当前表；这样**外层**就不可见这些局部名了，避免和类级名冲突。
* 查找时**就近原则**：先在当前表找，找不到再去外层表；这自然支持**变量遮蔽（shadowing）**。

---

## 生成代码时如何利用符号表

* 对变量产生 VM 指令时，先 `lookup(name)` 得到它的 `(kind, index)`，从而映射到正确的**内存段**与**编号**：

* `static` → `static index`
* `field` → `this index`
* `argument` → `argument index`
* `var`（local）→ `local index`
* 例如 `push local 2` 就来自于 `lookup(x)` 返回 `kind=var, index=2`。

---

## 简要使用流程（示例）

1. 解析类：`create()` 类级表 → `insert` 所有 `static/field`。
2. 解析一个方法：`create()` 方法级表 → 先 `insert("this", ClassType, argument)`，再 `insert` 形参与 `var`。
3. 生成代码：遇到标识符 `name` → `lookup(name)` → 发出 `push/pop <segment> <index>`。
4. 方法结束：`delete()` 方法级表。类结束：`delete()` 类级表。

---

\[口语化表达]
这一页就是说：想让编译器记住“这个名字是什么、属于哪类、在内存哪一格”，就得有一套最基本的“符号表”API。新进一个作用域（比如进到方法里）就 `create()` 一张新表；声明变量就 `insert()`；用到名字时就 `lookup()` 按作用域链往外找；作用域结束就 `delete()` 把表收起来。生成 VM 指令时，先查表拿到 kind 和 index，再翻译成像 `push local 0`、`pop this 2` 这样的指令。一句话：**符号表就是编译器的通讯录+座位表，负责建表、销表、登记、查找，保证每个名字都能被定位到正确的内存位置。**


---

## 第 34 页

![第 34 页](Lecture_week9(1)_assets/page-034.png)

这页标题是 **“Symbol Table Interface”**，它延续前一页的主题，但更进一步地讲了在 Jack 编译器中**改进版符号表接口**应如何支持“多层嵌套作用域”（scope nesting），比如类里面的方法、方法里面的局部变量等。这里介绍了三个重要操作：`push()`、`pop()` 和 `offset(segment)`，它们让符号表的管理更自动化、更层次化。

---

## 🧩 一、为什么需要增强接口

在 Jack 编译器中，符号表并不是只有一张表。
程序中存在不同层次的作用域，例如：

* 类（class）
* 构造函数 / 函数 / 方法
* 嵌套块（在更复杂语言中可能存在）

为了能在不同层次间切换、隔离变量，编译器用一个“符号表列表（list of tables）”，每个表代表一个作用域。

所以需要一套类似“堆栈”的管理方法：
**`push()`** 进入新作用域，**`pop()`** 离开作用域。

---

## ⚙️ 二、`push()` 的功能（进入作用域）

* **作用**：在符号表列表的**开头**创建一个新的空表（代表当前作用域）。
* **调用时机**：在**解析一个新的构造函数、函数或方法之前**调用。
* **行为说明**：

* 所有新的 `insert()`（变量声明）操作只会影响当前最顶层表；
* 当执行 `lookup()` 查找变量时，如果当前表找不到，系统会**自动往下一个表查找**（逐层向外搜索）。

🧠 举例：
当编译器进入 `method transfer()` 时，会 `push()` 一个新表；
`sum`、`from`、`when`、`i`、`j` 等变量会被加进这张表；
如果代码里访问了类字段 `balance`，查找不到时就会自动去下一个（类级符号表）中找。

---

## 🧹 三、`pop()` 的功能（退出作用域）

* **作用**：删除并丢弃当前作用域（列表的第一个符号表）。
* **调用时机**：在**解析完一个构造函数、函数或方法之后**调用。
* **目的**：释放局部变量、参数等信息，使符号表回到上一级作用域。

这相当于退出一个函数，让局部变量消失（就像函数执行完会销毁栈帧）。

---

## 📏 四、`offset(segment)` 的功能（计算偏移量）

* **作用**：返回指定内存段（segment）中下一个可用的偏移量。
* **机制**：

* 每调用一次，就把该段的偏移量加 1；
* 例如第一个 `local` 变量是 0，第二个是 1，以此类推；
* 这些偏移量信息存储在当前（最顶层）符号表中；
* 当调用 `push()` 或 `pop()` 时，会自动**重置偏移量计数**（例如进入新函数后 `local` 重新从 0 开始）。

🧠 举例：

```text
method void transfer(int sum, BankAccount from, Date when) {
var int i, j;
var Date due;
}
```

* 当插入 `sum`, `from`, `when` 时：

* `argument` 段 offset 依次为 0, 1, 2。
* 当插入 `i, j, due` 时：

* `local` 段 offset 依次为 0, 1, 2。
* 这些编号通过 `offset(segment)` 自动计算。

---

## 💡 五、总结作用关系

| 函数                | 主要用途    | 调用时机        |
| ----------------- | ------- | ----------- |
| `push()`          | 创建新符号表  | 进入新作用域（解析前） |
| `pop()`           | 删除当前符号表 | 退出作用域（解析后）  |
| `offset(segment)` | 分配变量的序号 | 声明变量时自动计算   |

`push()` / `pop()` 的组合确保每个函数或方法都有自己独立的符号表和编号系统，互不干扰。

---

## ✅ 六、为什么有用（在编译器中）

这些接口让编译器的符号表系统更像“作用域堆栈”：

* 支持多层嵌套；
* 自动清理局部变量；
* 避免命名冲突；
* 动态分配 offset，减少手动管理出错风险。

---

\[口语化表达]
这一页其实是前面符号表接口的“升级版”。
它告诉我们，为了让编译器能轻松地处理多层作用域（比如类、函数、块），符号表得像“堆栈”那样工作。
`push()` 就是进一个新作用域、建一张新表；
`pop()` 是出作用域、把那张表删掉；
`offset(segment)` 则用来算变量在内存段里的编号，比如第一个 local 是 0，第二个是 1。
这样每次进函数、出函数时，符号表都会自动切换，不会乱。
一句话总结：**`push` 进作用域、`pop` 出作用域、`offset` 管编号——让编译器像管理“作用域堆栈”一样管理所有变量的位置。**


---

## 第 35 页

![第 35 页](Lecture_week9(1)_assets/page-035.png)

这页标题是 **“Handling variables: managing their life cycle”（处理变量：管理其生命周期）**。核心在于：**不同种类的变量（static / field / var / argument）在程序运行期的存活时间与存放位置不同**，编译器需要据此放入正确的 VM 内存段并在合适的时机创建/销毁。

---

## 符号表回顾

* 左侧 **Class-scope symbol table**（类作用域符号表）记录类级变量：
`nAccounts, bankCommission`（static），`id, owner, balance`（field）及其类型、种类和编号（#）。
* 右侧 **Method-scope (transfer) symbol table**（方法作用域符号表）记录方法内名字：
`this`（隐式参数，argument 0）、形式参数 `sum/from/when`（argument 1/2/3），局部变量 `i/j/due`（var 0/1/2）。

---

## 各类变量的生命周期与存储段

* **static 变量**：

* **生命周期**：贯穿 **整个程序** 运行期，只有一份拷贝（类共享）。
* **存储段**：`static` 段（如 `static 0, static 1`）。
* **field 变量**（对象字段）：

* **生命周期**：**每个对象**都有自己的一份，随对象创建/释放而生灭。
* **存储段**：`this` 段（如 `this 0, this 1, this 2`）。
* **var 变量**（方法内局部变量）：

* **生命周期**：**进入子程序时创建**，**返回时销毁**。
* **存储段**：`local` 段（`local 0, local 1, …`）。
* **argument 变量**（形参/隐式 this）：

* **生命周期**：**进入子程序时创建**，**返回时销毁**。
* **存储段**：`argument` 段（`argument 0` 通常是 `this`，后续为显式参数）。

> 页脚的好消息：**VM 实现已经替我们处理了这些细节**（如各段基址、调用期的创建/回收），编译器只需依据符号表把名字映射到正确的 `(segment, index)`。

---

## 编译器该做什么

1. 在符号表中给每个名字记录 `Type/Kind/#`。
2. 生成代码时按 `Kind` 选择段（`static/this/argument/local`），用 `#` 作为索引：

* 例：`push local 0`（访问 `i`），`push argument 1`（访问 `sum`），`pop this 2`（写回 `balance`）。

---

\[口语化表达]
这一页说白了就是：不同类型的变量“活多久、放哪儿”不一样。`static` 全局只有一份一直活着；`field` 跟着每个对象各有一份；`argument` 和 `var` 只在函数调用期间存在。编译器做的事就是给它们安排好“住的地址”（对应哪个内存段、第几个位置），用的时候发出像 `push local 0`、`pop this 2` 这样的指令。放心，底层 VM 已经帮我们把创建/销毁的时机处理好了，我们只要对号入座就行。


---

## 第 36 页

![第 36 页](Lecture_week9(1)_assets/page-036.png)

这页讲的是 **“Handling objects: construction / memory allocation”（对象的创建与内存分配）**，说明了编译器在处理 Jack 语言中“对象”的创建时，如何在内存（RAM）中为对象分配空间，并通过构造函数（constructor）初始化字段。核心思想是：**对象在内存中是由一块连续的空间表示的，构造函数的作用是申请这块空间并填充字段值。**

---

## 一、左侧：Jack 代码示例解释

### 1. `class Complex`

这个类表示一个复数（Complex number），有两个字段：

```jack
field int re;  // 实部
field int im;  // 虚部
```

然后定义了一个构造函数：

```jack
constructor Complex new(int re_, int im_) {
let re = re_;
let im = im_;
return this;
}
```

解释：

* 构造函数 `new` 用来创建一个新的 `Complex` 对象；
* 它接收两个参数（实部与虚部）；
* 把参数赋值给对象的字段 `re` 和 `im`；
* `return this;` 返回当前对象的引用。

也就是说：
每次 `Complex.new(...)` 调用时，系统会在内存中分配一块空间，用来存储两个字段，然后返回这块空间的**起始地址**（即对象的引用）。

---

### 2. `class Foo`

另一个类中定义了一个函数：

```jack
function void bla() {
var Complex a, b, c;

let a = Complex.new(5,17);
let b = Complex.new(12,192);
let c = a; // 这里只复制引用（地址）
}
```

解释：

* `a` 和 `b` 分别创建了两个独立的 `Complex` 对象；
* 每次 `new()` 调用都会申请一块新的内存；
* `c = a` 表示 **`c` 和 `a` 指向同一个对象**（即同一内存地址），并不是复制内容。

---

## 二、右侧：RAM 内存分配示意图

右边的图展示了内存中的情况：

| 地址         | 内容      | 含义                     |
| ---------- | ------- | ---------------------- |
| 6712, 6713 | 5, 17   | 对象 `a` 的两个字段（re, im）   |
| 7002, 7003 | 12, 192 | 对象 `b` 的两个字段（re, im）   |
| 326        | 6712    | `a` 保存的对象引用地址          |
| 327        | 7002    | `b` 保存的对象引用地址          |
| 328        | 6712    | `c` 也指向同一个对象（与 `a` 一样） |

所以 `a`、`b`、`c` 本身并不是对象，而是**指针（reference）**。

---

## 三、编译器如何处理对象创建

每当编译器遇到：

```jack
let a = Complex.new(…);
```

它需要做两件事：

1. **分配内存**：
生成代码相当于执行：

```jack
let this = Memory.alloc(n);
```

其中 `n` 是这个类的字段数（`field` 的数量）。
例如 `Complex` 有 2 个字段（`re` 和 `im`），所以会分配 2 个字的空间。

`Memory.alloc(n)` 是操作系统提供的函数，它在 RAM 中找到一块空闲区域，并返回该区域的**基址**。
2. **初始化字段**：
构造函数随后把 `re_` 和 `im_` 的值写进刚分配的空间。

---

## 四、执行过程总结

1. 调用构造函数时，系统先执行 `Memory.alloc(字段数)`；
2. `this` 变量接收这块内存的起始地址；
3. 构造函数用参数初始化字段；
4. 返回 `this`，即对象的引用地址；
5. 变量（如 `a`, `b`）保存该地址。

---

## 五、核心思想

对象 = 一块连续的内存 + 一组字段值
引用变量 = 这块内存的地址
`new()` = “要内存 + 初始化 + 返回地址”

---

\[口语化表达]
这一页讲的其实就是：当我们在 Jack 里用 `new` 创建对象时，系统会在内存里“划一块地”给它住。
比如类 `Complex` 有两个字段（实部和虚部），那每创建一个对象，就用 `Memory.alloc(2)` 申请两个字的空间，然后把 `re_`、`im_` 的值放进去。
像 `let a = Complex.new(5,17)` 这句，返回的是这块空间的地址（比如 6712），所以变量 `a` 保存的其实是一个“指针”。
当你写 `let c = a`，它只是让 `c` 指向同一个对象，不是复制一份。
一句话总结：**对象创建 = 向系统要一块内存 + 填好属性值 + 返回那块内存的地址。**


---

## 第 37 页

![第 37 页](Lecture_week9(1)_assets/page-037.png)

这页题为 **“Handling objects: accessing fields”（处理对象：访问字段）**，演示编译器如何把 Jack 代码里对对象字段的读写，翻译成目标 VM 代码。

---

## 左侧 Jack 代码（类与方法）

```jack
class Complex {
// 字段（属性）
field int re;  // 实部
field int im;  // 虚部

/** 构造函数：用参数初始化字段 */
constructor Complex new(int re_, int im_) {
let this.re = re_;
let this.im = im_;
return this;
}

/** 把当前复数按给定标量相乘；隐藏参数是 this */
method void mult(int c) {
let this.re = this.re * c;
let this.im = this.im * c;
return;
}
}
```

要点：

* `re`、`im` 是 **field**，在对象内存里顺序存放，所以会映射到 `this 0`、`this 1`。
* **方法**有一个隐藏参数 `this`（在符号表里是 `argument 0`），显式参数从 `argument 1` 开始，所以 `c` 是 `argument 1`。

---

## 右侧：把语句编译成 VM 的步骤

以 `let this.im = this.im * c;` 为例：

### 1) 在符号表中做名字解析

* `this.im` → **kind=field** → 段 `this`，索引 **1**（因为 `im` 是第二个字段）。
* `c` → **kind=argument** → 段 `argument`，索引 **1**（`argument 0` 被 `this` 占用）。

### 2) 生成等价的“伪代码”表达

* 读 & 写的目标地址：`this[1]`
* 表达式右侧：`this[1] * argument[1]`
* 合起来：`this[1] = this[1] * argument[1]`

### 3) 转成目标 VM 指令

乘法在 VM 层通过库函数实现（例如 `Math.multiply`）：

```
push this 1          // 取 this.im
push argument 1      // 取参数 c
call Math.multiply 2 // 计算乘积（传入 2 个参数）
pop this 1           // 写回 this.im
```

> 同理，`let this.re = this.re * c;` 会使用 `this 0`。

---

## 小结：字段访问与段映射

* **field** → `this` 段（按声明顺序编号：`re`→`this 0`，`im`→`this 1`）
* **argument** → `argument` 段（`this` 隐式占用 `argument 0`，显式参数从 1 开始）
* 读字段：`push this i`；写字段：`pop this i`
* 表达式用库函数完成，例如 `Math.multiply`

---

\[口语化表达]
这页的意思是：把 `this.im = this.im * c` 这种“改对象字段”的语句，翻译成 VM 指令怎么做。先在符号表里查到 `im` 是对象里的第二个字段，所以是 `this 1`；`c` 是方法参数，所以是 `argument 1`。然后按“先算右边再写回”的套路：`push this 1`、`push argument 1`、`call Math.multiply 2` 算出乘积，最后 `pop this 1` 写回去。总之，字段就是 `this` 段带编号，参数就是 `argument` 段带编号，先取、再算、再存，搞定。


---

## 第 38 页

![第 38 页](Lecture_week9(1)_assets/page-038.png)

这页标题是 **“Handling objects: establishing access to the object’s fields”（处理对象：建立对对象字段的访问）**。它演示了**在方法内部如何把 `this` 对齐到目标对象的内存起始地址**，从而能正确读写该对象的字段。

---

## 场景设定（左上）

* 有一个 **Ball** 类型的对象 **`b`**，它有 4 个字段：`x`、`y`、`radius`、`color`。
* 逻辑视图：`x=120, y=80, radius=50, color=3`。
* RAM 视图（右上中间）：对象 `b` 的实例数据被放在内存从 **3012** 开始的连续 4 个单元：

* `RAM[3012]=120`（x）
* `RAM[3013]=80`（y）
* `RAM[3014]=50`（radius）
* `RAM[3015]=3`（color）
* 变量 `b` 自身存放的是**对象基地址**（例如某处内存里保存了 3012 这个数值）。

---

## 方法与隐藏参数（右上代码）

方法签名（Jack 语义）：

```jack
setR(Ball this, int r) {
let this.radius = r;
return;
}
```

* 在 Jack/VM 约定中，**方法的“隐藏第一个参数”就是 `this`**（这里正好写出来了用于讲解）。调用时，**实参 `b` 被放进 `argument 0`**，`r` 放进 `argument 1`。

---

## 为什么要“建立访问”（对齐 this）

要访问字段（`this.x / this.y / this.radius / this.color`），**`this` 段必须先指向对象的起始地址**。在 VM 语言里：

* **`this` 段的基址由 `pointer 0` 决定**（`that` 段的基址由 `pointer 1` 决定）。
* 因此方法开始时，需把 `argument 0`（也就是对象 `b` 的地址 3012）写入 `pointer 0`，让 `this` 段与对象内存对齐。

对应 VM 指令（右下）：

```
// 方法把 b 的地址写入 this 段基址
push argument 0
pop pointer 0

// 设置 b 的第三个字段（索引 2：radius）为 r
push argument 1
pop this 2
```

解释：

* `pop pointer 0` → 让 `this` 段基址 = 3012。
* `this 0/1/2/3` 于是分别映射到 `RAM[3012/3013/3014/3015]`。
* `pop this 2` → 把 `r` 写到 `RAM[3014]`，即把 `radius` 从 50 改为 17（示例值）。

---

## 虚拟内存段的“前后对比”（底部三图）

* **操作前**：

* `argument[0]=3012`（对象地址 b），`argument[1]=17`（r）。
* `pointer[0]`（也就是 `this` 段基址）尚未设置。
* **执行 `pop pointer 0` 后**：

* `pointer[0]=3012`，**`this` 段对齐到对象 b**。
* 因而 `this 0=120`、`this 1=80`、**`this 2=50`**、`this 3=3`。
* **执行 `pop this 2` 后**：

* `this 2` 从 50 更新为 **17**，即 `b.radius=17`。

> 字段与 `this` 段索引对应关系：
> `x → this 0`，`y → this 1`，`radius → this 2`，`color → this 3`。

---

## 小结

1. 方法调用时，**对象引用（地址）在 `argument 0`**，其他参数依次在 `argument 1..`。
2. **必须先 `pop pointer 0`**（把 `argument 0` 写到 `pointer 0`）让 `this` 段对齐到该对象的起始地址。
3. 之后即可用 `this i` 形式访问/更新第 `i` 个字段，如 `pop this 2` 修改 `radius`。

---

\[口语化表达]
这页就是说：想在方法里改对象 `b` 的字段，第一步得把“`this` 指向 b”。具体就两步：
先把 `b` 的地址（在 `argument 0` 里）丢进 `pointer 0`，这样 `this` 段就对齐到 `b`；
然后用 `this 2` 这种下标访问把 `radius` 写成 `r`（在 `argument 1` 里）。
所以代码是：`push argument 0; pop pointer 0; push argument 1; pop this 2;`——先对齐，再写字段，OK！


---

## 第 39 页

![第 39 页](Lecture_week9(1)_assets/page-039.png)

这页讲 **对象方法调用（method calls）在编译时如何被翻译成 VM 指令**。示例类 `Complex` 有字段 `re/im`、构造函数 `new`，以及方法 `mult(int c)`，把当前对象的两个分量都乘以 `c`。在用户代码里：

```jack
var Complex x;
let x = Complex.new(1,2);
do x.mult(5);
```

### 编译关键点

1. **方法有隐藏实参 `this`**
在 Jack 里，调用 `x.mult(5)` 时，**对象 `x` 会作为第一个隐含参数传入**。因此
`x.mult(5)` 等价于 `Complex.mult(x, 5)`。

2. **生成的 VM 代码**
两种写法都生成相同的指令序列：

```
push x              // 压入对象引用，作为 this
push 5              // 压入显式参数 c
call Complex.mult 2 // 调用，多出来的“2”表示一共 2 个参数：this 和 c
```

3. **一般翻译规则（General rule）**
任何对象方法调用

```
foo.bar(v1, ..., vn)
```

翻译为

```
push foo
push v1
...
push vn
call ClassName.bar (n+1)
```

其中参数个数是 `n+1`，因为包含了隐藏的 `this`。

4. **与构造函数的区别**

* 构造函数 `new` 会先分配内存并返回对象引用（通常借助 `Memory.alloc`），调用者用 `let x = ...` 接收。
* 普通方法（如 `mult`）在调用前只需要把对象引用与显式参数按顺序压栈，再 `call`。

---

\[口语化表达]
这页在说：`x.mult(5)` 并不是只传一个参数，**编译器会把 `x` 本身也当成第一个参数 `this`**。所以它相当于 `Complex.mult(x, 5)`。真正发给 VM 的指令就是先 `push x`、再 `push 5`，最后 `call Complex.mult 2`（两个参数：`this` 和 `5`）。通用套路是：**先把对象压栈，再把所有参数依次压栈，参数总数=显式参数+1，最后 `call`**。


---

## 第 40 页

![第 40 页](Lecture_week9(1)_assets/page-040.png)

这页是 **“Handling arrays: declaration / construction”（数组的声明与创建）**，展示 Jack 语言里数组变量如何**声明**、**在运行时分配内存**，以及这句赋值如何被编译成 VM 代码。

---

## 左侧 Jack 代码讲解

```jack
class Bla {
function void foo(int k) {
var int x, y;
var Array bar;      // 只是声明一个“数组引用”，此时没有内存
...
// 真正创建数组（在运行时分配长度为 10 的连续内存）
let bar = Array.new(10);
let bar[k] = 19;    // 把第 k 个元素写成 19
return;
}
}
do Bla.foo(2);          // 以 k=2 调用
```

* `var Array bar;` 只是**声明**：在局部变量表里给 `bar` 留一个槽位，用来存放“数组基地址”（引用），**并没有分配数组块**。
* `Array.new(10)` 才是**创建**：向系统申请长度为 10 的连续字（word）空间，并返回这块空间的**基地址**。
* `let bar = Array.new(10);` 把返回的**基地址**写入 `bar`（即“局部变量 2”）。
* `let bar[k] = 19;` 计算地址 `base + k`，把 19 写到该地址。

---

## 中间 RAM 状态图

以一次实际调用 `Bla.foo(2)` 为例：

* `k` 作为 `argument 0`，值为 **2**（图中地址 269）。
* 局部变量：`x`（local 0）、`y`（local 1）、`bar`（local 2）。
* `let bar = Array.new(10)` 执行后：`bar`（local 2）里保存了数组基地址 **4315**。
* 于是数组元素就位于 `4315..4324` 这段内存。
* 执行 `let bar[k] = 19`（`k=2`）后，`RAM[4317] = 19`（图中显示 4317 位置为 19），这正是 `4315 + 2`。

> 这也说明：**数组变量本身只保存“基地址”**；数组内容位于堆/自由内存的连续区间里。

---

## 右侧：如何编译“创建数组”

`let bar = Array.new(10);` 是一次**普通函数调用**（只有 1 个参数），编译成 VM：

```
push constant 10
call Array.new 1
pop local 2
```

解释：

* `push constant 10`：把长度参数 10 入栈；
* `call Array.new 1`：调用库函数 **Array.new**，参数个数 1；
* `pop local 2`：把返回的**数组基地址**存入局部变量 `bar`（local 2）。

> 在 Nand2Tetris 的 VM/OS 里，`Array.new(n)` 通常会调用 `Memory.alloc(n)` 分配 `n` 个字并返回基址。

（**补充**：对 `let bar[k] = 19;`，典型翻译会是：计算地址 `bar + k` → `pop pointer 1`（设置 `THAT`）→ `pop that 0` 写值。这里幻灯片重点是“声明/创建”，所以只给出结果内存图。）

---

## 要点归纳

* **声明**（`var Array bar;`）≠ **创建**（`Array.new(10)`）。声明只留“引用位”，创建才分配堆内存并返回基址。
* 数组变量存的是**基地址**；数组元素在堆上是**连续内存**。
* `Array.new(10)` 的编译与普通函数调用相同：`push 参数` → `call` → `pop 到目标变量`。
* 数组元素赋值实质是：**基址 + 下标 → 计算出地址 → 写入**。

---

\[口语化表达]
这页想告诉你：`var Array bar;` 只是说“我有个数组指针”，**没分内存**；真正分内存的是 `Array.new(10)`，返回一串连续位置的**起始地址**，再把这个地址放进 `bar`。所以编译就是 `push 10 → call Array.new 1 → pop local 2`。之后 `bar[k] = 19` 就是“把 19 写到 `bar` 起始地址再往后数 `k` 个的位置”。简单说：**数组是堆上的一条街，`bar` 拿着门牌号，`new` 负责批地盖房，`bar[k]` 就是到第 k 户去放东西。**


---

## 第 41 页

![第 41 页](Lecture_week9(1)_assets/page-041.png)

这页讲的是 **“Handling arrays: accessing an array entry by its index”（数组按下标访问元素）**，也就是编译器如何把 `bar[k] = 19` 这样的语句翻译成 VM 代码。

---

## 一、左侧 Jack 代码解析

```jack
class Bla {
function void foo(int k) {
var int x, y;
var Array bar;      // 声明一个数组变量（仅保存引用）
let bar = Array.new(10); // 分配10个空间的数组
let bar[k] = 19;         // 访问并修改第k个元素
return;
}
}
do Bla.foo(2);  // 调用时 k=2
```

### 含义：

1. `bar` 是一个数组引用（指针），存放数组基地址。
2. `bar[k] = 19` 实际上是：

```
*(bar + k) = 19
```

即计算出内存地址 `bar` 的第 `k` 个偏移位置，然后把值 19 写进去。

---

## 二、RAM 状态（右上方）

执行完 `let bar[k] = 19` 后：

| 地址         | 内容         | 说明                      |
| ---------- | ---------- | ----------------------- |
| 269        | 2          | 参数 k（argument 0）        |
| 276        | -          | 局部变量 x                  |
| 277        | 4315       | 局部变量 bar，存放数组基地址        |
| 4315\~4324 | 数组 bar 的内容 |                         |
| 4317       | 19         | 因为 k=2，写入的 bar\[2] = 19 |

**要点：**
`bar` 存的是数组首地址（4315），
`bar[k]` 就是访问 `4315 + k` 的那一格。

---

## 三、编译过程：`bar[k] = 19` 的翻译逻辑

### （1）伪代码思想（左下）

```
// bar[k] = 19
push bar         // 压入数组首地址
push k           // 压入索引
add              // 相加，得到 bar + k
pop addr         // addr = bar + k
push 19          // 压入要存的值
pop *addr        // 把 19 写入 addr 指向的内存
```

### （2）实际 VM 代码（右下）

```
push local 2      // bar 的地址（bar 是第2个局部变量）
push argument 0   // k （参数）
add               // 得到 bar + k
pop pointer 1     // THAT = bar + k，指向目标元素
push constant 19  // 压入要写的值
pop that 0        // 把 19 写入 THAT[0]
```

**解释：**

* `pop pointer 1` → 设置 VM 的 `THAT` 段指向我们要写入的位置；
* `push constant 19` → 准备要写入的数；
* `pop that 0` → 将值写入 `THAT[0]`（即 bar\[k]）。

---

## 四、关键机制总结

| 操作                 | 含义                |
| ------------------ | ----------------- |
| `push local 2`     | 获取数组变量 bar 的基地址   |
| `push argument 0`  | 获取索引 k            |
| `add`              | 计算目标地址（bar + k）   |
| `pop pointer 1`    | 设置 `THAT` 段指针到该地址 |
| `push constant 19` | 准备要写入的数           |
| `pop that 0`       | 把 19 写入数组对应位置     |

这样编译器就能在 VM 层面实现任意数组元素访问。

---

\[口语化表达]
这页就是说：`bar[k] = 19` 的意思，其实是“把 19 写进内存地址（bar 的基址 + k）那一格”。编译器会先算出地址，再把 VM 的 `THAT` 段指向那个地方，然后执行 `pop that 0` 把值写进去。简单说就是：**先算出目标门牌号，再告诉 VM“下一次写操作写到这户人家”，最后把 19 塞进去。**


---

## 第 42 页

![第 42 页](Lecture_week9(1)_assets/page-042.png)

这页在讲 **表达式的处理（Handling expressions）**：把高级语言里的算术表达式先解析成**语法树**，再按一定规则生成 **VM 指令**。

---

## 例子表达式与语法树

* 高级代码：`((5+1)/-8) * (4+2)`
* 语法树（parse tree）里，以运算符为内节点、以常量/变量为叶子：
根是 `*`，左子树是 `/`（其左为 `5+1`，右为 `-8` 的一元负号），右子树是 `+`（`4` 与 `2`）。

---

## 代码生成思路（自顶向下的后序遍历）

对每个运算结点，**先生成其左右子表达式的代码，再输出该运算的指令**。这个顺序能保证运行时**栈顶**正好是运算所需的操作数。

按这个思路，表达式被翻译为右侧 VM 代码（与图中一致）：

```
push constant 5
push constant 1
add                      // 5+1

push constant 8
neg                      // -8

call Math.divide 2       // (5+1)/(-8)

push constant 4
push constant 2
add                      // 4+2

call Math.multiply 2     // 前面的结果 * (4+2)
```

### 细节说明

* **一元负号 `-8`**：先 `push constant 8`，然后用 `neg` 取反。
* **除法与乘法**：在该 VM 里用库函数实现：

* `call Math.divide 2`：从栈中弹出 2 个参数作整除。
* `call Math.multiply 2`：从栈中弹出 2 个参数作乘法。
* **二元运算（+、-）**：直接用 `add` / `sub` 指令（这里示例用到 `add`）。

---

## 通用生成算法（图下方 codeWrite(exp)）

从语法树 `exp` 生成 VM 代码的规则（化成实现就是**后序遍历**）：

1. **常量 `n`** → 输出 `push n`
2. **变量 `v`** → 输出 `push v`（实际要按变量所在段与索引生成，如 `push local i` 等）
3. **一元运算 `op(e1)`** → 先 `codeWrite(e1)`，再输出对应的一元指令（如 `neg`, `not`）
4. **二元运算 `(e1 op e2)`** → 先 `codeWrite(e1)`；再 `codeWrite(e2)`；最后输出 `op`
5. **函数调用 `f(e1,...,en)`** → 依次 `codeWrite(e1)...codeWrite(en)`；最后 `call f n`

> 这一套规则也正是把语法树的**后序表示**转成**基于栈的字节码**（或 VM 指令）的标准做法。

---

\[口语化表达]
这页说的是：算式先变成一棵树，然后**先算孩子再算父亲**。比如 `((5+1)/-8)*(4+2)`，先压 5 和 1 再 `add`，再压 8 `neg` 成 -8，然后 `call Math.divide 2` 完成除法；接着压 4 和 2 `add` 得到右边，再 `call Math.multiply 2` 把两边乘起来。通用口诀就是：**常量/变量就 `push`，一元先算里面再 `neg/not`，二元先左后右再输出运算符，函数就是把实参一个个压栈，最后 `call`**。这样走下来，栈顶总是你下一步刚好要用的数据。


---

## 第 43 页

![第 43 页](Lecture_week9(1)_assets/page-043.png)

这页讲 **控制流（program flow）** 在编译到 VM 指令时如何落地：把高级语言里的 `if/else` 与 `while` 用 **label + goto/if-goto** 的模式实现。

---

## 1) `if (cond) { s1 } else { s2 }` 的生成方式

右上框的 VM 代码框架（示意）：

1. 先生成计算 `cond` 的代码，并把布尔结果压到栈顶：`VM code to compute and push cond`
2. `if-goto IF_TRUE0`

* VM 的 `if-goto L`：**弹栈**看栈顶是否为真（≠0），若真则跳到 `L`。
3. `goto IF_FALSE0`（若没跳到真分支，就无条件跳到假分支）
4. `label IF_TRUE0`：真分支开始
5. 生成 `s1` 的 VM 代码
6. `goto IF_END0`：真分支执行完直接跳过假分支
7. `label IF_FALSE0`：假分支开始
8. 生成 `s2` 的 VM 代码
9. `label IF_END0`：if 整体结束

## **要点**


---

## 第 44 页

![第 44 页](Lecture_week9(1)_assets/page-044.png)

这页展示的是整个编译过程的一个完整例子 —— **从 Jack 高级代码到最终 VM 代码的生成**，用的是一个叫 **BankAccount（银行账户）** 的类。它把我们前面学的所有部分（变量、内存段、符号表、表达式、方法调用、对象访问等）都串联在了一起。

---

## 一、左上：高层代码（High level code）

```jack
class BankAccount {
static int nAccounts;
static int bankCommission;
field int id;
field String owner;
field int balance;

method int commission(int x) { /* Code omitted */ }

method void transfer(int sum, BankAccount from, Date when) {
var int i, j;
var Date due;
let balance = (balance + sum) - commission(sum * 5);
return;
}
}
```

这段 Jack 代码描述了一个银行账户类，核心逻辑是：

* **静态变量**：`nAccounts`, `bankCommission`（全类共享）
* **字段变量**：`id`, `owner`, `balance`（每个对象独有）
* **方法 `commission`**：计算佣金（省略内容）
* **方法 `transfer`**：转账操作，参数为 `sum`, `from`, `when`
内部通过表达式：

```
balance = (balance + sum) - commission(sum * 5);
```

更新余额。

---

## 二、右上：符号表（Symbol Tables）

### Class-scope symbol table（类级符号表）

| Name           | Type   | Kind   |  # |
| -------------- | ------ | ------ | -: |
| nAccounts      | int    | static |  0 |
| bankCommission | int    | static |  1 |
| id             | int    | field  |  0 |
| owner          | String | field  |  1 |
| balance        | int    | field  |  2 |

→ 说明：

* 静态区 `static` 存放类共享变量；
* 字段区 `field` 存放对象成员属性；
* 每个名字都分配了编号（例如 `balance` 是 `this 2`）。

---

### Method-scope symbol table（方法级符号表）

| Name | Type        | Kind     |  # |
| ---- | ----------- | -------- | -: |
| this | BankAccount | argument |  0 |
| sum  | int         | argument |  1 |
| from | BankAccount | argument |  2 |
| when | Date        | argument |  3 |
| i    | int         | var      |  0 |
| j    | int         | var      |  1 |
| due  | Date        | var      |  2 |

→ 说明：

* `this` 隐含为第 0 个参数；
* 传入参数用 `argument` 段；
* 局部变量用 `var` 段（在 VM 中映射到 `local` 段）。

---

## 三、左下：伪代码（Pseudo VM code）

这是初步生成的中间 VM 代码，还没完全替换内存段名：

```
function BankAccount.transfer
push balance
push sum
add
push this
push sum
push 5
call multiply
call commission
sub
pop balance
...
```

意思是：

1. 先取出当前对象的 `balance`；
2. 加上传入的 `sum`；
3. 然后计算 `commission(sum * 5)`；
4. 最后把结果更新到 `balance`。

---

## 四、右下：最终 VM 代码（Final VM code）

最终版本把所有段名、函数调用和符号表编号都映射成了标准 VM 指令：

```
function BankAccount.transfer 3
push argument 0
pop pointer 0             // this = 当前对象

push this 2               // balance
push argument 1           // sum
add

push argument 1           // sum
push constant 5
call Math.multiply 2

call BankAccount.commission 2
sub
pop this 2                // 更新 balance

push 0
return
```

### 逐句解释：

1. `push argument 0` / `pop pointer 0`
→ 把第一个参数（this）设为当前对象（即 VM 的 `this` 段指向该对象）。

2. `push this 2` / `push argument 1` / `add`
→ 取 `balance`（`this 2`）与 `sum` 相加。

3. `push argument 1` / `push constant 5` / `call Math.multiply 2`
→ 计算 `sum * 5`。

4. `call BankAccount.commission 2`
→ 调用 `commission(sum * 5)`，返回值留在栈顶。

5. `sub`
→ 从 `(balance + sum)` 减去 `commission(sum * 5)`。

6. `pop this 2`
→ 把结果存回到对象的 `balance` 字段。

7. `push 0` / `return`
→ 返回值 0（因为方法是 void）。

---

## 五、总结整体过程

这个例子展示了：

* 类和方法的符号表如何确定每个变量的段（`static`、`field`、`argument`、`local`）；
* 表达式 `(balance + sum) - commission(sum * 5)` 如何通过“语法分析 + 代码生成”一步步变成 VM 指令；
* `this`、函数调用（`call`）、算术操作（`add`、`sub`、`multiply`）和内存存取（`push`、`pop`）如何组合形成最终逻辑。

---

\[口语化表达]
这一页是整个编译流程的“总复习”。BankAccount 类里有静态变量、字段、方法、局部变量，全都在符号表里登记。然后那句 `balance = (balance + sum) - commission(sum * 5)`，编译器先算加法、再算乘法、再调用函数、最后做减法，把结果写回到对象的 balance。
最终生成的 VM 代码就是一条条“压栈、运算、函数调用、弹栈存回”的命令。简单讲，这页告诉我们：**从高级语言到虚拟机指令，编译器干的就是把逻辑拆成一连串精确的 push / pop / call / goto 指令**，每个变量和函数都被映射到具体的内存段和编号上。


---

## 第 45 页

![第 45 页](Lecture_week9(1)_assets/page-045.png)

这页介绍了一个完整的例子 —— **类 Bob（Example Class Bob）**，演示了 Jack 语言的类定义、构造函数（constructor）、静态变量（static）与一般函数（function）的编译生成过程。它展示了从高层 Jack 代码到底层 VM 代码的具体转化方式。

---

## 一、左侧：Jack 高层代码

```jack
class Bob {
static Array bobs;
static int how_many, too_many;
field string name;

constructor Bob baby(string cool_name) {
let name = cool_name;
return this;
}

function void setup(int max_bobs) {
let how_many = 0;
let too_many = max_bobs;
let bobs = Array.new(max_bobs);
return;
}
}
```

这段 Jack 代码里：

* `static` 变量是类级共享的：

* `Array bobs`（存放所有 Bob 实例的数组）
* `int how_many`, `too_many`（计数和上限）
* `field string name` 是对象的字段（每个 Bob 都有自己的 name）
* `constructor baby()` 是构造函数，创建一个新的 Bob 对象。
* `function setup()` 是普通函数，用来初始化类的静态变量。

---

## 二、右侧：VM 翻译后的代码

### (1) `function Bob.baby 0`

```vm
push constant 1
call Memory.alloc 1
pop pointer 0
push argument 0
pop this 0
push pointer 0
return
```

**逐行解释：**

1. `push constant 1`
→ 构造函数要创建一个对象，先申请 1 个字段空间（这里类 Bob 只有一个 field：`name`）。

2. `call Memory.alloc 1`
→ 调用系统函数 `Memory.alloc` 分配内存，返回新对象的起始地址。

3. `pop pointer 0`
→ 把分配的内存地址存入 `this` 指针，使得当前对象的字段可以通过 `this` 访问。

4. `push argument 0` / `pop this 0`
→ 把传入参数 `cool_name` 赋给对象的第一个字段 `name`。

5. `push pointer 0`
→ 把对象自身的引用压回栈顶，作为构造函数的返回值。

6. `return`
→ 返回新对象（即 `this`）。

---

### (2) `function Bob.setup 0`

```vm
push constant 0
pop static 1
push argument 0
pop static 2
push argument 0
call Array.new 1
pop static 0
push constant 0
return
```

**逐行解释：**

1. `push constant 0` / `pop static 1`
→ 把 0 存入静态变量 `how_many`。

2. `push argument 0` / `pop static 2`
→ 把传入的参数 `max_bobs` 存入静态变量 `too_many`。

3. `push argument 0` / `call Array.new 1`
→ 调用系统函数 `Array.new`，创建一个长度为 `max_bobs` 的数组。

4. `pop static 0`
→ 把新建的数组存入 `bobs`（静态变量 0）。

5. `push constant 0` / `return`
→ 返回空（void 函数返回 0 表示正常结束）。

---

## 三、总结：编译器在做什么？

这个例子展示了编译器如何：

1. **分配内存**：构造函数中用 `Memory.alloc` 分配对象的字段空间；
2. **管理 this 指针**：用 `pointer 0` 代表当前对象；
3. **操作静态变量**：用 `static i` 代表类级共享变量；
4. **调用系统函数**：如 `Memory.alloc`、`Array.new`；
5. **返回对象引用**：构造函数通过 `push pointer 0` 把对象自己返回。

---

\[口语化表达]
这页讲的是一个叫 Bob 的类是怎么从 Jack 代码变成 VM 指令的。
在 `baby()` 构造函数里，编译器先调用 `Memory.alloc` 分配对象空间，再把参数 `cool_name` 存进 `this.name`，最后返回对象的引用。
而在 `setup()` 函数里，它设置静态变量 `how_many=0`，`too_many=max_bobs`，再创建一个数组存进 `bobs`。
简单讲，这页告诉我们：**构造函数要负责“造对象”并设好 this；普通函数要操作静态变量或字段；编译器会把这些都翻成一堆 push/pop/call 指令来控制内存和返回值。**


---

## 第 46 页

![第 46 页](Lecture_week9(1)_assets/page-046.png)

这页是“Example Class Bob”的**方法实现与编译结果**示例，展示 Jack 语言里对象方法如何被翻译成 VM 指令。

## 左侧：Jack 源码（对象方法）

* `method string name()`
返回当前对象（`this`）的字段 `name`。
* `method void rename(string cooler_name)`
把当前对象的 `name` 改成传入的 `cooler_name`，然后返回（无返回值）。

## 右侧：对应的 VM 代码含义

### 1) `function Bob.name 0`

```vm
push argument 0      // 方法的隐藏第一个参数 = this 对象指针
pop pointer 0        // 设置 pointer 0 = this，建立“当前对象”上下文
push this 0          // 取出字段 name（假设是第 0 个 field）
return               // 返回 name
```

要点：

* **对象方法**总是把第一个参数当作 `this`，先用 `pop pointer 0` 设定当前对象，再通过 `this <index>` 访问字段。

### 2) `function Bob.rename 0`

```vm
push argument 0      // this
pop pointer 0        // 设置 this 上下文
push argument 1      // cooler_name 参数
pop this 0           // 写入字段 name（field 0）
push constant 0      // void 方法按约定压入 0 作为返回占位
return
```

要点：

* 仍然先建立 `this` 上下文；
* 把第二个参数（`cooler_name`）写入 `this 0`（即 name 字段）；
* **void 方法**在 VM 层通常会在 `return` 前 `push constant 0` 作为“空返回值”。

## 关键信息小结

* **方法 vs. 函数**：对象方法在 VM 层的**第一个参数始终是 `this`**，进入方法的第一步通常是 `pop pointer 0`。
* **字段访问**：对象字段通过 `this i` 读写（i 为字段序号）。
* **void 返回**：VM 约定 `return` 之前会压入 `0`（`push constant 0`）。

\[口语化表达] 这页在说：Bob 的两个对象方法怎么被编译。每次进对象方法，编译器先把“第一个参数”当作 this，`pop pointer 0` 把当前对象上下文设好；`name()` 就直接 `push this 0` 把 name 字段取出来返回；`rename(x)` 就把参数写回 `this 0`，最后因为是 void，还要 `push constant 0` 再 `return`。总之，对象方法=先设 this，再用 `this i` 读写字段，void 返回要补个 0。


---

## 第 47 页

![第 47 页](Lecture_week9(1)_assets/page-047.png)

这页继续使用 **Example Class Bob**，展示了一个更复杂的函数 `remember()`，说明编译器如何将包含 **if 判断、函数调用、数组访问与赋值** 的 Jack 代码翻译为 VM 代码。

---

## 一、左侧：Jack 代码

```jack
function void remember(Bob bob) {
if (how_many < too_many) {
let bobs[how_many] = bob.name();
let how_many = how_many + 1;
}
return;
}
```

解释如下：

1. 该函数是 `Bob` 类的静态函数（`function`），参数是一个 `Bob` 对象。
2. 它检查当前 `how_many` 是否小于 `too_many`：

* 如果还有空位，就把当前 `bob` 的名字存到 `bobs` 数组中对应位置；
* 然后让 `how_many` 自增 1。
3. 如果 `how_many` 不小于 `too_many`，函数什么也不做，直接返回。

---

## 二、右侧：编译后的 VM 代码

```vm
function Bob.remember 0
push static 1         // how_many
push static 2         // too_many
lt                    // 比较 how_many < too_many
if-goto IF_TRUE0      // 如果为真，跳转执行 if 块
goto IF_FALSE0        // 否则跳到 if 结束
label IF_TRUE0
push static 1         // how_many
push static 0         // bobs
add                   // 计算 bobs[how_many] 的地址
push argument 0       // 取 bob 对象
call Bob.name 1       // 调用 bob.name() 得到名字
pop temp 0
pop pointer 1         // pointer 1 = that = bobs[how_many] 的基址
push temp 0
pop that 0            // 把名字写入 bobs[how_many]
push static 1
push constant 1
add
pop static 1          // how_many = how_many + 1
label IF_FALSE0
push constant 0
return
```

---

## 三、执行逻辑详解

### 1. 条件判断

* `push static 1` / `push static 2` / `lt`
→ 比较 `how_many < too_many`
* `if-goto IF_TRUE0`
→ 条件成立进入 if 块，否则跳转 `IF_FALSE0`。

### 2. 写入数组元素

* `push static 1` + `push static 0` + `add`
→ 计算出数组元素地址 `bobs + how_many`。
* `push argument 0` + `call Bob.name 1`
→ 调用参数对象的 `name()` 方法，得到字符串结果。
* `pop temp 0` / `pop pointer 1` / `push temp 0` / `pop that 0`
→ 设置 `pointer 1`（即 `that` 段）指向要写入的数组位置，把名字存进去。

### 3. 更新计数器

* `push static 1` / `push constant 1` / `add` / `pop static 1`
→ 执行 `how_many = how_many + 1`。

### 4. 结束与返回

* 跳转标签 `label IF_FALSE0`
* `push constant 0` / `return`
→ 因为是 `void` 函数，返回 0 表示结束。

---

## 四、编译器展示的关键机制

1. **if 控制流的 VM 实现**：通过 `lt` + `if-goto` + `goto` + `label` 组合实现条件判断。
2. **对象方法调用**：`call Bob.name 1`，会自动将 `bob` 对象引用作为第一个参数传入。
3. **数组访问**：通过计算基址加偏移（`add`），然后用 `pointer 1` 和 `that` 段操作实现。
4. **静态变量共享**：`static` 段存放类级共享数据（`bobs`, `how_many`, `too_many`）。

---

\[口语化表达]
这页展示的是 Bob 类里的一个“记住对象”的函数。代码逻辑是：如果现在的 Bob 数还没超上限，就把传进来的 bob 的名字塞进数组 bobs，然后让 how\_many 加 1。编译器把这个 if 判断翻成了 `lt` + `if-goto` + `label` 的跳转结构，还要算出数组元素地址，再用 `that` 段写入数据。最后因为是 void 函数，它还会 `push constant 0` 再 `return`。简单讲，这页就是在演示：**if 判断、函数调用、数组赋值、静态变量更新**是怎么一步步变成 VM 指令的。


---

## 第 48 页

![第 48 页](Lecture_week9(1)_assets/page-048.png)

这页是一个**结尾/过渡页**（只有深色背景和阿德莱德大学的校徽，没有正文内容）。它通常用于：

* 表示**本次讲解结束**或进入**提问/讨论**环节；
* 作为**章节分隔页**，给观众一点视觉“喘息”，准备切换到下一部分；
* 也可能是放映中的**留白背景**，方便讲者口头总结或演示。

没有需要解读的技术点或文本信息；它的作用主要是**视觉提示**与**节奏控制**。

\[口语化表达]
这页啥内容都没有，就一个深色底加学校 logo，意思是“这一段讲完啦/休息一下/进入问答”。相当于演示文稿的收尾或分隔页，用来让大家缓一口气、切换到下一部分。


---

## 第 49 页

![第 49 页](Lecture_week9(1)_assets/page-049.png)

这页是课程结尾的“本周任务说明页”，主要是提醒学生**这一周要做的事情**，属于教学计划通知。

---

## 一、内容逐项解释

### 1️⃣ Review Chapters 9–11 of the Text Book

意思是：

> “复习课本第 9 到第 11 章（如果你还没复习的话）。”

👉 说明这些章节可能是下周课上内容的基础或考试重点。
这属于**自学复习任务**。

---

### 2️⃣ Prac 6 Available Wednesday, due Week 11 (we’ll keep it small)

意思是：

> “第六次实验（Practical 6）将在本周三开放，截止日期是第 11 周。我们会让它的工作量比较小。”

👉 “Prac” 是实践作业（Practical exercise）的简称。
也就是说，这一周学生要开始新的实验，但老师保证它不会太难、太耗时。

---

## 二、整体含义总结

这页就是讲师在提醒学生：

* 本周要**巩固课本的第 9–11 章**；
* 同时要**开始第 6 次实验练习（Prac 6）**；
* 实验不复杂，且截止时间宽松（第 11 周）。

这通常是教学幻灯片的最后一页，用来安排学习进度和提醒学生课后任务。

---

\[口语化表达]
这页就是老师在跟你说：“这周记得复习课本第 9 到 11 章啊，如果还没看的赶紧补。然后第六次实验周三就会上线，截止到第 11 周，别担心，这次作业会比较轻松点。” 也就是说——**复习+开始新实验，这周的节奏不重。**
