

---

## 第 1 页

![第 1 页](Lecture09-1 (1)_assets/page-001.png)

这是一张**阿德莱德大学（The University of Adelaide）计算机科学课程封面页**，是讲义或幻灯片的首页，标题为：

> **COMP SCI 2000 Computer Systems — Lecture 9**

---

### 一、页面结构与含义

#### 1️⃣ 上方图像部分

图片展示了阿德莱德大学主校区（North Terrace Campus）的校园景观。
画面中：

* 左侧是阿德莱德大学标志性建筑之一 **Bonython Hall（邦尼松礼堂）**；
* 右边是另一座哥特风格教学楼；
* 前景有学生走路、骑车、聊天，体现出**校园生活的活力与学习氛围**。

这是学校常用的宣传图片，用来体现阿德莱德大学的**历史底蕴 + 现代校园气息**。

---

#### 2️⃣ 左上角的标志与名称

* 校徽上是阿德莱德大学的 **Logo**：盾牌中有一本展开的书（代表知识）、南十字星（代表南半球）、以及校训卷轴。
* 下方写着：

> **THE UNIVERSITY of ADELAIDE**
> 表示该讲义属于阿德莱德大学官方教学资料。

---

#### 3️⃣ 中部文字内容

> **School of Computer Science**
> 表示课程隶属于**计算机科学学院（School of Computer Science）**。

> **COMP SCI 2000 Computer Systems**
> 这是课程代码与课程名称。

* **COMP SCI 2000** 是课程编号（对应大学课程系统中的中级或核心课程）。
* **Computer Systems** 意思是“计算机系统”，通常涉及计算机体系结构、操作系统、编译原理等内容。

> **Lecture 9**
> 表示这是该课程系列讲义中的**第 9 次课**。

---

#### 4️⃣ 下方信息

* **adelaide.edu.au** 是阿德莱德大学的官方网站。
* 右下角的口号 **seek LIGHT** 是学校品牌的一部分，意味着“追求光明、追求知识”。
* 左下角的 **CRICOS PROVIDER 00123M** 是学校的国际注册编号，说明该校有资格接收海外留学生。

---

## \[口语化表达]

这页就是阿德莱德大学《计算机系统》课程第九讲的封面。上面那张照片是学校的主校区，阳光、树荫、骑车的学生，挺有学术气息。左上角是学校的Logo，说明这门课属于计算机科学学院。下面写的“COMP SCI 2000”是课程编号，“Lecture 9”表示这是第九节课。右下角那句“seek LIGHT”是学校的口号，意思是“追求光明、追求知识”。总体来说，这页就是在告诉你——这是阿德莱德大学计算机系统课程


---

## 第 2 页

![第 2 页](Lecture09-1 (1)_assets/page-002.png)

这张幻灯片的标题是 **“Review – Last week”（回顾——上周内容）**，主要是在课件的开头回顾前一节课讲的内容，属于课程衔接性的复习页。

---

### 🧠 内容详解

1. **主要内容主题：Hardware（硬件部分）**
这张幻灯片回顾了上周讲课的主题——计算机硬件，涵盖了几个方面：

* **History of Architecture（体系结构的历史）**：介绍了计算机体系结构的发展历程，比如冯·诺依曼结构等。
* **Memory and I/O（内存与输入输出）**：讲解了计算机存储器的层次结构（RAM、ROM、Cache 等）以及输入输出设备的基本工作原理。
* **The HACK machine（HACK 机器）**：这是计算机系统课程中常用的一种简化教学模型，用来帮助学生理解计算机的指令执行过程和体系结构。
* **The CPU and basic computers（中央处理器与基本计算机）**：学习了 CPU 的组成（如控制单元、算术逻辑单元 ALU、寄存器等）以及它们如何协同工作执行程序。

2. **最后一句话的意思：**

> “That was the last week of talking hardware in lectures.”
> 意思是——“上周是我们课堂上最后一次讲硬件的内容。”
> 表示从这一讲（Lecture 9）开始，课程将从“硬件”转向其他主题，比如“软件”、“编译”或“操作系统”等更高层次的计算机系统内容。

---

### 📘 总体理解

这页幻灯片的作用是承上启下：先回顾上一讲的硬件内容，然后暗示课程内容将正式从硬件部分过渡到新的主题（通常是计算机系统的软件层面）。

---

\[口语化表达]
这页其实就是老师在上课开头做个小复习，意思是：“上周我们讲的是计算机硬件那块——包括体系结构的历史、内存和输入输出、HACK 教学机还有 CPU 这些内容。那堂课也就是硬件部分的最后一节，从今天开始，我们要转到新的主题啦。”


---

## 第 3 页

![第 3 页](Lecture09-1 (1)_assets/page-003.png)

Unexpected token '<', "<!DOCTYPE "... is not valid JSON


---

## 第 4 页

![第 4 页](Lecture09-1 (1)_assets/page-004.png)

这张幻灯片标题是 **“Where we are at:”（我们现在学到哪儿了）**，它用一张分层结构图总结了整个计算机系统课程的知识体系，并标出当前讲课的阶段。整图展示的是计算机从**物理世界（Physics）**到**人类思维（Human Thought）**的抽象层级递进关系，也就是**从硬件到软件的层次结构**。

---

## 🧩 图的整体逻辑

这幅图其实分成了两大部分：

* 下半部分是 **Hardware hierarchy（硬件层次）**
* 上半部分是 **Software hierarchy（软件层次）**

整个课程就是沿着这两层结构，从底层的物理与电路开始，一步步构建出完整的计算机系统。

---

## ⚙️ 硬件层次（Hardware hierarchy）

1. **Physics（物理）**
一切的基础来自物理定律，比如电子、电流等。
→ 属于电气工程（Electrical Engineering）的范畴。

2. **Chips & Logic Gates（芯片与逻辑门）**
通过电子元件和逻辑门构成电路（第 1–3 章）。
→ 这是计算机的最底层逻辑结构。

3. **Hardware Platform（硬件平台）**
逻辑门组合成更复杂的硬件模块（寄存器、ALU、内存），搭建完整的计算机平台（第 4–5 章）。

4. **Machine Language（机器语言）**
硬件能直接理解的二进制指令语言。
→ 从这一层开始，进入“计算机体系结构（Computer Architecture）”。

---

## 💾 软件层次（Software hierarchy）

1. **Assembly Language（汇编语言）**
人类可读的低级语言，使用符号代替机器码（第 6 章）。
汇编器（Assembler）把它翻译成机器语言。

2. **Virtual Machine（虚拟机）**
抽象出比汇编更高一层的编程模型，屏蔽底层硬件差异（第 7–8 章）。
用 VM Translator（虚拟机翻译器）把虚拟机指令转换成汇编。

3. **H.L. Language & Operating Sys.（高级语言与操作系统）**
比如 C、Java 等高级语言（第 9、12 章）。
编译器（Compiler）把高级语言转换为虚拟机代码。

4. **Human Thought（人类思维）**
最高层，代表程序设计与抽象思维。
从人类的逻辑和算法出发，通过层层抽象，最终在底层硬件上执行。

---

## 📍 当前所在位置（“Where we are at”）

蓝框内重点区域表明：
本课程目前正从 **汇编语言（Assembly Language）** 过渡到 **虚拟机（Virtual Machine）** 与 **编译器（Compiler）** 的部分，也就是从硬件层往上进入**软件体系结构**。
换句话说，课程已经从“机器怎么运行”转向“程序怎么运行在机器上”。

---

## \[口语化表达]

这页图是在告诉我们整个课程的“大地图”。最底下从物理开始，经过逻辑门、硬件平台、机器语言，这些都是硬件层的内容；再往上，就是软件层：汇编语言、虚拟机、高级语言，一直到人类思维的抽象逻辑。现在课程学到中间靠上的位置——我们刚结束硬件那块，正要进入软件世界，也就是要学习虚拟机和编译器，开始理解“程序是怎么被翻译成能跑在机器上的代码”的。


---

## 第 5 页

![第 5 页](Lecture09-1 (1)_assets/page-005.png)

这张幻灯片标题是 **“Where we are at:”（我们现在学到哪一步了）**，它展示的是整个计算机系统课程的**知识结构层次图**，从最底层的物理学一直到最上层的人类思维，说明了计算机系统的构建是一个**层层抽象、由下至上**的过程。该图同时标注了教材章节对应的内容，让学生清楚课程目前所处的位置。

---

## 🧩 整体逻辑结构

图中分成两个主要部分：

* **Hardware hierarchy（硬件层次）**：负责物理和电路层面的实现。
* **Software hierarchy（软件层次）**：负责抽象、编程和逻辑层面的实现。

它展示了计算机从“物理世界”到“人类逻辑思维”的整个抽象上升链条。

---

## ⚙️ 硬件层次（Hardware hierarchy）

这是计算机的底层世界，从物理规律到电路、再到机器语言：

1. **Physics（物理）**
一切计算机原理都源自物理学，例如电流、电子运动等，这是计算机的最基础层。

2. **Electrical Engineering（电气工程）**
利用物理定律设计电路系统，是电子元件工作的学科基础。

3. **Chips & Logic Gates（芯片与逻辑门）**
利用电信号构建“逻辑门”电路，如与门、或门、非门等，这些逻辑门组成更复杂的芯片模块。对应教材 **Chapters 1–3**。

4. **Hardware Platform（硬件平台）**
多个逻辑电路模块组合成计算机核心结构（ALU、寄存器、内存等）。这是硬件架构层。对应 **Chapters 4–5**。

5. **Machine Language（机器语言）**
硬件能直接执行的二进制指令（0 和 1 的组合）。
从这里开始，计算机能理解人类定义的“语言”了。

> 这一部分由“Assembler（汇编器）”连接到上层软件。汇编器将汇编语言翻译成机器语言。

---

## 💾 软件层次（Software hierarchy）

从机器语言往上走，就是计算机软件系统的世界：

1. **Assembly Language（汇编语言）**
机器语言的符号化形式，人类可读但仍接近底层。对应 **Chapter 6**。

2. **Virtual Machine（虚拟机）**
一种抽象计算模型，用来屏蔽底层硬件差异，让程序能在更通用的环境中运行。对应 **Chapters 7–8**。

3. **Compiler（编译器）**
负责把高级语言（如 C、Java）转换成虚拟机代码。对应 **Chapters 10–11**。

4. **H.L. Language & Operating Sys.（高级语言与操作系统）**
高级语言（如 Python、C++）代表人类的思维逻辑在机器上的实现，而操作系统负责管理程序与硬件的交互。对应 **Chapters 9、12**。

5. **Human Thought（人类思维）**
最高层抽象，代表人类通过编程和算法，将思维转化为计算机行为。

---

## 📍 当前所处阶段

这张图的蓝框标注了课程目前所在的部分：
课程已经完成了硬件部分（从物理、逻辑门到机器语言），现在正往上进入\*\*汇编语言与虚拟机（Assembly & VM）\*\*部分，也就是从“如何让机器工作”转向“如何让程序运行”。

---

## \[口语化表达]

这张图就是在告诉我们整门课的大地图：计算机系统是从底层的物理世界，一步步抽象到能写程序的高级语言。最底下是电流和电路（物理和逻辑门），中间是硬件平台和机器语言，再往上是汇编、虚拟机、编译器、高级语言，最后到人类思维。我们现在的位置大概是在中间偏上的地方，也就是刚刚结束硬件部分，正开始进入软件的世界——学习汇编语言、虚拟机和编译器，看看程序是怎么一步步被翻译成机器能理解的代码的。


---

## 第 6 页

![第 6 页](Lecture09-1 (1)_assets/page-006.png)

这张幻灯片的标题依然是 **“Where we are at:（我们现在学到哪一步）”**，但与前一页不同的是，这里用红色椭圆和箭头特别**强调了 “Assembler（汇编器）”** 这个位置。也就是说，这一讲课程的主题，正是关于**汇编器的概念与作用**。

---

## 🧩 整体图结构回顾

这幅图展示的是计算机系统从底层硬件到上层软件的分层关系：

* 下半部分是 **Hardware hierarchy（硬件层次）**：由物理学、电气工程、逻辑门、硬件平台、机器语言构成。
* 上半部分是 **Software hierarchy（软件层次）**：包括汇编语言（Assembly Language）、虚拟机（Virtual Machine）、编译器（Compiler）、高级语言与操作系统（H.L. Language & Operating System）等。

每一层之间通过“**抽象接口（abstract interface）**”连接，使得复杂的系统能够逐层搭建。

---

## 🔴 当前重点：Assembler（汇编器）

红色椭圆标出的部分正是“Assembler（汇编器）”，也就是当前课程的核心内容。

汇编器的作用是：

1. **将汇编语言翻译成机器语言。**
汇编语言是人类可读的低级语言（如 `ADD R1, R2`），而机器语言则是计算机真正能执行的二进制指令（如 `1010110`）。
汇编器负责自动完成这两者之间的转换。

2. **连接硬件和软件的中间层。**
汇编语言属于软件层，而机器语言属于硬件层。汇编器正是桥梁，它把程序员写的符号化指令，翻译成能在 CPU 上运行的指令集。

3. **课程章节对应：第 6 章（Chapter 6）**
图上写着“Assembler – Chapter 6”，说明这部分是书本或课程中第 6 章的内容，也标志着从“硬件”过渡到“软件”的关键节点。

---

## ⚙️ 从图中能看出的层次逻辑

* 从左到右代表**抽象程度的提升**。
从“Machine Language（机器语言）”到“Assembly Language（汇编语言）”，再到“Virtual Machine（虚拟机）”和“Compiler（编译器）”，抽象层次越来越高。

* 汇编器是**整个体系的连接点**。
它把底层硬件的机器指令，和上层的软件逻辑对接起来，是理解“程序如何在机器上运行”的关键工具。

---

## 🧠 简单总结

这页的重点就是告诉我们：
课程现在正处于“从硬件走向软件”的中间阶段，具体要学的就是——汇编器（Assembler）。
也就是说，我们已经理解了计算机硬件是怎么工作的，接下来要学习**怎么把人类写的符号化指令翻译成机器能执行的代码**，从而真正让硬件“动起来”。

---

\[口语化表达]
这页图的意思是：我们现在学的内容正卡在“硬件”和“软件”的交界处，也就是汇编器（Assembler）这一步。它负责把汇编语言翻译成机器能懂的二进制代码，是人写的程序能在电脑上跑起来的关键环节。简单说，前几章讲的是机器怎么造的、怎么工作的；而现在开始，我们要学习怎么让机器“听懂人话”，用汇编器把人写的代码变成机器语言。


---

## 第 7 页

![第 7 页](Lecture09-1 (1)_assets/page-007.png)

这张幻灯片标题是 **“What is an assembler?”（什么是汇编器？）**，它简洁地解释了汇编器（Assembler）的定义和重要性。虽然只有两条内容，但涵盖了汇编器在计算机系统中核心的两个角色。

---

## 🧩 内容详解

1. **“Translator for a simple language.”（一种简单语言的翻译器）**

* 这句话的意思是：
汇编器是一个**翻译器（Translator）**，它把用汇编语言（Assembly Language）写的程序**翻译成机器语言（Machine Language）**。
* 汇编语言比高级语言简单得多，几乎是一种“可读的机器语言”，每一条汇编语句都直接对应一条机器指令。
例如：

```
ADD R1, R2   →   1010110010（机器码）
```
* 所以汇编器本质上是**一个结构清晰但功能直接的语言翻译器**。

2. **“Contains most of the tricks and techniques required to make compilers work.”（包含了实现编译器的大部分技巧与技术）**

* 这句话的意思是：
虽然汇编器看起来比编译器简单得多，但它已经涉及了**编译原理的核心机制**，例如：

* 语法分析（Parsing）
* 符号表管理（Symbol Table）
* 指令生成与地址映射（Code Generation）
* 也就是说，学习汇编器不仅能理解底层代码的转换过程，还能为学习编译器（Compiler）打下基础。
编译器可以看作是汇编器的“复杂版本”——它从更高级的语言（如 C、Java）出发，最终生成机器码，而汇编器就是编译器工作原理的缩小模型。

---

## ⚙️ 小结

这页幻灯片强调：

* 汇编器是一个**翻译器**，能把汇编语言翻译成机器能执行的代码。
* 它虽然简单，但包含了构建编译器所需的绝大多数关键技术，因此是学习编译器设计的入门和基础。

---

\[口语化表达]
这页讲的意思是：汇编器其实就是一种“翻译器”，专门把汇编语言转成机器语言，让电脑能直接执行。而且虽然汇编器看起来简单，但它其实用到了很多编译器的核心技巧，比如语法分析、符号处理和代码生成。所以你可以把它当成是编译器的“迷你版”——理解了汇编器，就等于是迈出了学编译原理的第一步。


---

## 第 8 页

![第 8 页](Lecture09-1 (1)_assets/page-008.png)

这张幻灯片讲的是 **汇编器（Assembler）如何把汇编语言转换成机器能执行的二进制代码**，也就是程序从“源代码（source code）”到“目标代码（target code）”的翻译过程。整页内容展示了这个转换过程的示意，并解释了汇编器的功能和设计挑战。

---

## 🧩 图示讲解

### 左边：Source code（源代码）

* 这里展示的是一个汇编语言的例子，它的功能是：
计算 `1 + 2 + 3 + ... + RAM[0]` 的和，并把结果存到 `RAM[1]` 里。
* 代码中的一些说明：

```
@i      // 声明变量 i
M=1     // i = 1
@sum
M=0     // sum = 0
(LOOP)
@i
D=M
@R0
D=D-M   // 比较 i 是否超过 RAM[0]
@WRITE
D;JGT   // 如果 i > RAM[0]，跳到 WRITE
...
```

这种汇编语言（例如 Hack 汇编）是一种**人类可读但接近底层的语言**。每条语句都代表一条机器操作，比如数据移动、加法、判断跳转等。

---

### 中间箭头：assemble（汇编）

* 这个过程是由\*\*汇编器（Assembler）\*\*完成的。
* 汇编器会**读取每一条汇编指令，翻译成机器能直接执行的二进制代码（0 和 1）**。
* 比如：

```
@i        → 0000000000010000
D=M       → 1111110000010000
```
* 这种转换遵循严格的**语法规则（syntax rules）**，就像语言翻译一样。

---

### 右边：Target code（目标代码）

* 右边那一列的全是二进制数字，也就是**机器语言（Machine Code）**。
* CPU 最终执行的就是这种指令。
* 比如 `1110110000010000` 就告诉 CPU 去执行某个“把寄存器内容写入内存”的操作。

---

## 📘 下方解释文字

### 🔹 The program translation challenge（程序翻译的挑战）

汇编器在“语言翻译”中要解决两个核心问题：

1. **提取程序语义（semantics）**：
从源代码中读懂它的意思，比如 `D=D-M` 表示“让 D 寄存器的值减去 M”。
2. **重新表达语义**：
用目标语言（机器语言）的语法规则，把相同的意思重新表达出来。
例如汇编语言的一行语句，可能需要生成一条或多条二进制机器指令。

---

### 🔹 Assembler = simple translator（汇编器 = 简单翻译器）

这部分总结了汇编器的本质：

* 它是一个**简单的翻译程序**，把汇编命令一条条转成机器码。
* 它还要**处理符号（symbols）**，比如：

* `@i`、`@sum` 是变量符号；
* `(LOOP)` 是标签（跳转目标）。
汇编器需要建立“符号表（symbol table）”，在翻译时找到它们的对应地址。

---

## ⚙️ 总结核心概念

* 汇编器的任务就是：**把人类可读的汇编代码，翻译成 CPU 能执行的机器语言（0 和 1）**。
* 它的工作看起来像是“逐行翻译”，但实际上包含了语法分析、符号管理、语义转换等复杂步骤。
* 这是理解编译器和计算机执行机制的重要基础。

---

\[口语化表达]
这张图讲的就是：汇编器干的活儿就是当“翻译官”。左边是人写的汇编代码，比如“@i、M=1、D=D-M”这些符号化的指令，中间的箭头“assemble”代表汇编器，它会把这些汇编语句一个个翻译成右边那堆由 0 和 1 组成的机器码。CPU 只看得懂后面那些数字，所以汇编器就相当于在帮人和机器沟通。下面那几条总结就是说，汇编器的任务是读懂源代码的意思，然后用目标语言（机器语言）的语法重新表达出来。它其实就是个简单的翻译器，同时还能处理符号、变量和跳转标签。


---

## 第 9 页

![第 9 页](Lecture09-1 (1)_assets/page-009.png)

这张幻灯片标题是 **“Revisiting Hack low-level programming”（重新回顾 Hack 低级编程）**，主要讲的是如何使用 Hack 汇编语言编写程序，并通过 CPU 模拟器（emulator）运行这个程序来观察结果。它展示了从汇编代码到计算结果的完整过程。

---

## 🧩 左侧内容：Hack 汇编程序（sum.asm）

左边的代码块展示了一个 Hack 汇编语言程序 `sum.asm`，它的作用是：

> 计算从 1 加到 RAM\[0] 的结果，并把求和结果存入 RAM\[1]。

比如：如果 RAM\[0] = 10，程序会计算 1 + 2 + 3 + ... + 10 = 55，并把 55 存在 RAM\[1]。

### 程序逻辑分解如下：

1. **初始化变量：**

```asm
@i
M=1     // i = 1
@sum
M=0     // sum = 0
```

创建两个变量 `i` 和 `sum`，分别用于循环计数与累计和。

2. **主循环 LOOP：**

```asm
(LOOP)
@i
D=M         // D = i
@0
D=D-M       // 比较 i 和 RAM[0]
@WRITE
D;JGT       // 如果 i > RAM[0]，跳转到 WRITE
```

这里的逻辑是判断是否到达求和上限（RAM\[0]）。

3. **执行求和并递增：**

```asm
@i
D=M
@sum
M=D+M       // sum += i
@i
M=M+1       // i++
@LOOP
0;JMP       // 跳回 LOOP
```

4. **结束写入：**

```asm
(WRITE)
@sum
D=M
@1
M=D         // RAM[1] = sum
(END)
@END
0;JMP       // 停止程序
```

整个程序完成“从 1 到 n 的求和”功能。

---

## 💻 右侧内容：CPU 模拟器执行结果

右边显示的是 Hack CPU 模拟器的界面截图（`CPU Emulator`）。
这个模拟器可以执行 `.asm` 汇编代码，并显示寄存器（RAM、ROM）中的运行情况。

### 主要部分说明：

* **ROM（程序内存）**：显示正在运行的汇编指令，如 `@i`、`M=1` 等。
* **RAM（数据内存）**：显示程序运行时的数据变化。

* **RAM\[0] = 10** → 表示用户输入的上限（用户输入部分，`user supplied input`）。
* **RAM\[1] = 55** → 表示程序计算出来的结果（程序输出部分，`program generated output`）。

程序执行后，CPU 模拟器会自动完成符号解析（把符号如 `@sum`、`@i` 替换成具体内存地址），并逐条执行机器指令。

---

## ⚙️ 下方说明文字解释

> “The CPU emulator allows loading and executing symbolic Hack code.
> It resolves all the symbolic symbols to memory locations, and executes the code.”

意思是：

* 这个 CPU 模拟器能加载并运行 Hack 汇编语言程序；
* 它能把程序中用到的符号（例如变量名或标签）自动解析成具体的内存地址；
* 然后逐条执行指令，模拟实际 CPU 的工作过程。

---

## 🧠 核心总结

这页的重点是展示：

1. **Hack 汇编语言的结构与执行流程**；
2. **CPU 模拟器如何运行并验证程序功能**；
3. 汇编语言和底层计算机执行的关系 —— 程序员写符号化代码，CPU 运行的是解析后的内存指令。

---

\[口语化表达]
这页讲的其实就是一个完整的小实验：我们写了一个 Hack 汇编程序，用来算从 1 加到某个数（比如 RAM\[0]=10），最后得到结果 55 并存到 RAM\[1]。左边那堆代码就是汇编语言，右边是它在 CPU 模拟器里运行的画面。模拟器能把这些符号（像 @sum、@i）翻译成具体的内存地址，然后让 CPU 一条条执行。最终，用户输入的数是 10，程序输出的结果是 55。简单说，这页图是在告诉我们——汇编语言写的程序真能在底层 CPU 上跑起来，而且你能在模拟器里“亲眼看到”机器在工作。


---

## 第 10 页

![第 10 页](Lecture09-1 (1)_assets/page-010.png)

这张幻灯片标题是 “Assembler’s view of an assembly program”（汇编器眼中的汇编程序），意思是“从汇编器的角度看一个汇编程序”。
它解释了汇编器是如何“理解”和“处理”一段汇编语言的：即把文本形式的代码，按类型分类，并翻译成机器能执行的16位二进制指令。
🧩 左边：汇编程序（Assembly program）
左边显示的汇编代码是之前讲过的 Hack 汇编程序 sum.asm，它的功能是计算从 1 加到 RAM[0] 的总和，然后把结果存到 RAM[1] 里。
例如：如果 RAM[0] = 10，最后程序会输出 55。
这部分代码仍然是人类编写的“符号化指令”，包含变量、循环和跳转。
汇编器要做的，就是从文本转成 CPU 真正能执行的机器指令（0和1）。
🧩 右边：汇编程序在汇编器眼中的组成结构
右边列出了汇编器在读取程序时看到的几种“类型”，也就是汇编语言中出现的四种行（Line types）：
A-instruction（A指令）
格式：@value 或 @symbol
功能：把一个值或地址加载到寄存器A中。
例如：
@i 表示把变量 i 对应的地址加载到寄存器。
@100 表示把数值 100 加载到寄存器。
C-instruction（C指令）
格式：dest=comp;jump
功能：描述计算（comp）、存储（dest）和跳转（jump）。
例如：
D=M 表示把内存M的值放入寄存器D。
D;JGT 表示“如果D>0就跳转”。
Symbol declaration（符号声明）
格式：(LABEL)
用于标记程序位置（比如循环或跳转目标）。
例如：(LOOP)、(END)。
汇编器会在“符号表”中记录这些符号对应的行号或内存地址。
Comment or whitespace（注释或空行）
格式：// comment
用于人类阅读，不会被翻译成机器指令。
⚙️ 汇编器面临的挑战（The challenge）
汇编器要解决的核心任务是：
把这些不同类型的文本行翻译成 CPU 能执行的 16 位二进制指令。
也就是说，每条 A 或 C 指令都要被转换为：
复制
编辑
1110xxxxxxxyyyyy
这种形式的机器码，精确地告诉硬件该怎么操作。
例如：
@5 → 0000000000000101
D=M → 1111110000010000
最终，汇编器输出的结果是一串 16 位指令序列，可以直接加载到计算机硬件（如 CPU 模拟器）中运行。
🧠 总结
这页重点讲的是：汇编器如何“看待”汇编语言。
在汇编器看来，一个程序只是由不同类型的文本行组成的结构化数据流，每一行都有固定语法规则（A指令、C指令、符号声明、注释）。
汇编器的任务就是识别这些行的类型，解析其含义，并翻译成16位二进制机器码。
[口语化表达]
这页讲的是，从汇编器的角度看，一个汇编程序其实就是一堆有规律的文本行。每一行要么是 @xxx 这种A指令，要么是像 D=M 这种C指令，要么是标签 (LOOP) 这种符号声明，要么就是注释。汇编器不会去“理解”代码逻辑，它只负责把这些行一条条识别出来，然后把能执行的部分翻译成16位的二进制机器码。也就是说，在汇编器眼里，程序不是人类思维的算法，而是一串需要被精确转换成硬件能读懂的指令。


---

## 第 11 页

![第 11 页](Lecture09-1 (1)_assets/page-011.png)

这张幻灯片标题是 **“Translating / assembling A-instructions”**，意思是“如何翻译/汇编 A 指令”。
它讲解了 Hack 汇编语言中 **A 指令（Address Instruction）** 的结构、含义，以及汇编器是如何把它转换成二进制机器码的。

---

## 🧩 一、A 指令的符号形式（Symbolic form）

幻灯片上写的：

```
Symbolic:   @value
```

意思是：

* A 指令以 `@` 开头，后面跟一个 **值（value）**。
* 这个 value 可以是：

1. 一个非负整数（例如 `@21`）；
2. 或一个符号（symbol），即某个变量名或标签（例如 `@i`、`@LOOP`）。

A 指令的功能：

> 把 `value` 的值（或其对应的内存地址）加载到寄存器 A（Address register）中。

比如：

* `@21` 表示把常数 21 加载到 A 寄存器。
* `@sum` 表示把符号 `sum` 对应的地址加载到 A 寄存器（例如内存地址 16）。

---

## 🧮 二、A 指令的二进制形式（Binary form）

幻灯片中的图：

```
Binary:  0 v v v v v v v v v v v v v v v
```

解释如下：

* **A 指令的机器码是 16 位二进制数。**
* 第一位始终是 `0`，表示这是 A 指令（区别于 C 指令，C 指令开头是 `111`）。
* 后面的 15 位（`vvvvvvvvvvvvvvv`）表示 value 的二进制值。

例如：

```
@5   →  0000000000000101
@21  →  0000000000010101
```

如果 value 是符号（symbol），汇编器会先在符号表中查找该符号对应的地址（例如 `@sum` 可能是 `@16`），然后再把这个数字转换为二进制。

---

## ⚙️ 三、翻译成二进制的过程（Translation to binary）

幻灯片底部列出了两种情况：

1. **如果 value 是一个非负整数：**

* 很简单，直接把十进制数转换为 15 位二进制即可。
* 例如：`@21` → `0000000000010101`。

2. **如果 value 是一个符号（symbol）：**

* 汇编器会从“符号表（symbol table）”中找到该符号对应的内存地址；
* 然后用这个地址的二进制值替换符号。
* 例如：假设 `sum` 在符号表中对应地址 16，则
`@sum` → `0000000000010000`。

---

## 📘 四、关键点总结

* A 指令用于 **把数值或内存地址加载到 A 寄存器**。
* 它的机器码总是以 `0` 开头。
* 汇编器要么直接翻译数值，要么查符号表找地址。
* 最终生成的都是 16 位二进制指令。

---

\[口语化表达]
这页其实在讲：A 指令就是最简单的一类汇编指令，形式是“@什么东西”。它的作用就是把一个数字或者变量的地址装进寄存器 A 里。汇编器在看到这种语句时，会干两件事：如果是数字，就直接把它变成二进制；如果是符号（比如变量名或循环标签），就先去符号表查它的内存地址，然后再转成二进制。所有 A 指令的机器码都是 16 位的，并且第一个位一定是 0，用来告诉 CPU 这是一条地址指令。简单来说，就是“@”代表告诉机器：去那里！


---

## 第 12 页

![第 12 页](Lecture09-1 (1)_assets/page-012.png)

这张幻灯片标题是 **“Translating / assembling C-instructions”**，意思是“如何翻译/汇编 C 指令”。
它讲的是 Hack 汇编语言中第二类指令——**C 指令（Compute Instruction）** 的结构、功能，以及如何把它翻译成二进制机器码。

---

## 🧩 一、C 指令的符号形式（Symbolic form）

C 指令的通用写法如下：

```
dest = comp ; jump
```

表示：

> 把 `comp`（一个计算表达式）的结果存到 `dest` 指定的位置（寄存器或内存），
> 然后根据 `jump` 条件，决定是否跳转到别的代码行。

其中：

* **`comp`** 是计算部分（比如 `D+1`、`A-1`、`M+D`、`!D` 等）；
* **`dest`** 是存储目标（比如 `D`、`M`、`MD`、`AMD` 等）；
* **`jump`** 是跳转条件（比如 `JGT`、`JEQ`、`JMP` 等）。

> 注意：`dest` 或 `jump` 可以省略。
>
> * 如果没有 `dest`，则不需要 `=`。
> * 如果没有 `jump`，则不需要 `;`。
>
> 例如：
>
> ```
> D=M        // 把 M 的值存到 D
> D=D+1      // D 加 1
> 0;JMP      // 无条件跳转
> ```

---

## 🧮 二、C 指令的二进制形式（Binary form）

C 指令总是以三位 `111` 开头，用来区别 A 指令。
结构如下：

```
Binary:  1 1 1 a c1 c2 c3 c4 c5 c6 d1 d2 d3 j1 j2 j3
```

### 字段说明：

| 字段      | 含义                            |
| ------- | ----------------------------- |
| `111`   | 固定前缀，表示 C 指令                  |
| `a`     | 表示 comp 部分是否访问内存（A 寄存器或 M 内存） |
| `c1–c6` | 计算（comp）的二进制编码                |
| `d1–d3` | 存储目标（dest）的二进制编码              |
| `j1–j3` | 跳转条件（jump）的二进制编码              |

---

## 🧮 三、comp / dest / jump 的编码表

幻灯片下面给出了三个重要对照表：

### ① comp（计算）编码表

* 当使用 `A` 时，`a=0`；
* 当使用 `M` 时，`a=1`；
* `c1–c6` 的组合表示不同的计算操作。

例如：

| 表达式 | a | c1–c6  | 说明              |       |
| --- | - | ------ | --------------- | ----- |
| 0   | 0 | 101010 | 常数 0            |       |
| 1   | 0 | 111111 | 常数 1            |       |
| -1  | 0 | 111010 | 常数 -1           |       |
| D   | 0 | 001100 | 取 D 寄存器         |       |
| A   | 0 | 110000 | 取 A 寄存器         |       |
| M   | 1 | 110000 | 取内存地址 \[A] 对应的值 |       |
| D+1 | 0 | 011111 | D 加 1           |       |
| D+A | 0 | 000010 | D 加 A           |       |
| D   | A | 0      | 010101          | D 或 A |

---

### ② dest（存储目标）编码表

| dest | d1 d2 d3 | 含义         |
| ---- | -------- | ---------- |
| null | 000      | 不存储        |
| M    | 001      | 存到内存 \[A]  |
| D    | 010      | 存到寄存器 D    |
| MD   | 011      | 存到 M 和 D   |
| A    | 100      | 存到寄存器 A    |
| AM   | 101      | 存到 A 和 M   |
| AD   | 110      | 存到 A 和 D   |
| AMD  | 111      | 存到 A、M 和 D |

---

### ③ jump（跳转条件）编码表

| jump | j1 j2 j3 | 含义           |
| ---- | -------- | ------------ |
| null | 000      | 不跳转          |
| JGT  | 001      | 若 out > 0 跳转 |
| JEQ  | 010      | 若 out = 0 跳转 |
| JGE  | 011      | 若 out ≥ 0 跳转 |
| JLT  | 100      | 若 out < 0 跳转 |
| JNE  | 101      | 若 out ≠ 0 跳转 |
| JLE  | 110      | 若 out ≤ 0 跳转 |
| JMP  | 111      | 无条件跳转        |

---

## 🔧 四、举例说明

假设我们有一条指令：

```
D = M + 1
```

步骤如下：

1. `comp = M+1` → a=1, c1–c6 = 111011
2. `dest = D` → d1d2d3 = 010
3. `jump = null` → j1j2j3 = 000

因此，机器码为：

```
1111110111010000
```

---

## ✅ 五、总结

* C 指令是 Hack 汇编语言中最常用、最灵活的指令；
* 它以 `111` 开头，由 **计算部分 + 目标部分 + 跳转部分** 组成；
* 汇编器只需根据表格查出相应的二进制编码即可；
* 转换过程“相对简单”（如幻灯片底部所说），但非常规律。

---

\[口语化表达]
这页其实在讲 C 指令是怎么被翻译成机器码的。C 指令长得像 “dest=comp;jump”，意思是“把计算结果存到某个地方，然后看条件要不要跳转”。比如 `D=M+1` 就是“把内存 M 的值加 1，存到 D 里”。每条 C 指令都会变成 16 位二进制码，前 3 位永远是 `111`，后面按表格把 comp、dest、jump 三个部分换成对应的二进制就行。换句话说，只要查查这三张表，汇编器就能把一行汇编指令翻译成硬件能直接执行的机器码。


---

## 第 13 页

![第 13 页](Lecture09-1 (1)_assets/page-013.png)

这张幻灯片标题是 **“The overall assembly logic”**，意思是“汇编器的整体逻辑”。
它讲的是：当汇编器（Assembler）在工作时，如何一步一步地把汇编语言程序翻译成机器能执行的二进制指令。

---

## 🧩 一、左边：汇编程序（Assembly program）

左侧展示的是一段 Hack 汇编程序（之前的例子 `sum.asm`），功能是计算 1 + 2 + ... + RAM\[0] 的和，并把结果存入 RAM\[1]。
它包含：

* **A 指令**（如 `@i`, `@sum`），负责加载地址或常量；
* **C 指令**（如 `M=M+1`, `D;JGT`），负责执行运算和控制；
* **标签（Label）**（如 `(LOOP)`、`(WRITE)`、`(END)`），用于跳转定位。

---

## 🧮 二、右边：汇编器的整体处理逻辑

右边的部分详细描述了汇编器（Assembler）在处理每一条有效指令时的核心流程。

### 步骤 1：解析指令（Parse the command）

> 把一条汇编语句分解成其组成部分。

* 对于 A 指令（`@xxx`），提取出 `xxx`；
* 对于 C 指令（`dest=comp;jump`），要拆出：

* `dest`（目标寄存器）
* `comp`（运算部分）
* `jump`（跳转部分）。

这一步就像“语法分析”，把原始字符串结构化。

---

### 步骤 2：翻译 A 指令（Translate A-instruction）

> 把符号（symbol）或常量转换成数字地址。

* 如果是数字（如 `@21`），直接转成二进制；
* 如果是符号（如 `@sum`），查“符号表”找到对应内存地址；
* 汇编器稍后会有详细机制来处理符号定义与替换。

例子：

```
@sum → 0000000000010000
```

---

### 步骤 3：翻译 C 指令（Translate C-instruction）

> 把 C 指令中的各部分转换成二进制。

* 对 `comp`、`dest`、`jump` 三部分分别查编码表；
* 把它们拼成完整的机器码格式：

```
111 a c1 c2 c3 c4 c5 c6 d1 d2 d3 j1 j2 j3
```
* 最终是一条 16 位二进制指令。

例子：

```
D=M+1 → 1111110111010000
```

---

### 步骤 4：组合并输出（Assemble and write output）

> 把翻译好的各字段组合成完整的 16 位机器码，并写入输出文件。

例如：

```
1111110000010000
0000000000010000
```

会依次输出到 `.hack` 文件，供计算机或模拟器加载运行。

---

## ⚙️ 三、总结：汇编器的工作循环

对于每一条“真实指令”（非注释、非空行），汇编器都会：

1. 解析；
2. 区分 A 或 C 指令；
3. 翻译成 16 位二进制；
4. 写入输出文件。

这个流程会一直重复，直到整个汇编程序被完全翻译。

---

## ✅ 四、核心思想

汇编器的工作本质上是一个“文本翻译器”：

* 输入是人类可读的汇编语言；
* 输出是机器能直接执行的二进制指令；
* 每条汇编指令都被独立识别、处理、编码；
* 最终生成一个 `.hack` 文件，即可运行的机器码程序。

---

\[口语化表达]
这一页讲的其实就是汇编器工作的总流程。它要做的事情就像一个“翻译官”：读一行汇编语句，把它拆开看看是哪种指令，然后查表把符号和计算部分都换成二进制。比如看到 `@sum`，就去符号表查它的地址；看到 `D=M+1`，就按规则拼出对应的机器码。每条指令都翻译成16位的0和1后，汇编器再把这些输出到一个文件里。这样，原来人能读的汇编代码就成了机器能直接执行的“语言”了。


---

## 第 14 页

![第 14 页](Lecture09-1 (1)_assets/page-014.png)

这张幻灯片标题是 **“Example Assembly”**（汇编示例），意思是通过一个具体的 Hack 汇编程序例子，演示汇编语言如何被汇编器翻译成机器码（即 0 和 1 组成的二进制指令）。

---

## 🧩 一、假设条件

幻灯片上方写着：

> Assume BOB has value 31
> 意思是：“假设符号 BOB 的值是 31”。
> 这表示在符号表（symbol table）中，`BOB` 代表内存地址 **31**。

---

## 🧮 二、汇编代码与对应机器码

表格左边是汇编代码，右边是每条汇编语句对应的 16 位二进制机器码。
我们逐条解释如下 👇：

---

### ① `@7`

这是一个 **A 指令**，表示“把常数 7 加载进寄存器 A”。
其二进制结构是：

```
0 + 15位二进制数
```

7 的二进制是 `0000000000111`，所以整条指令是：

```
0000000000000111
```

---

### ② `D=0`

这是一个 **C 指令**，表示“把常数 0 赋值给寄存器 D”。

* `comp=0` → `a=0`, `c1–c6 = 101010`
* `dest=D` → `d1d2d3 = 010`
* `jump=null` → `j1j2j3 = 000`
于是拼接成：

```
1110101010001000
```

---

### ③ `0;JMP`

这条 C 指令表示“无条件跳转”。

* `comp=0` → `a=0`, `c1–c6 = 101010`
* `dest=null` → `000`
* `jump=JMP` → `111`
所以机器码为：

```
1110101010000111
```

也就是“计算结果为0，但无条件跳转”。

---

### ④ `A=D&M;JLT`

这是更复杂的一条 **C 指令**：

* `comp=D&M` → `a=1`, `c1–c6 = 000000`
* `dest=A` → `100`
* `jump=JLT`（当结果 < 0 时跳转）→ `100`
拼接得到：

```
1111000000100100
```

---

### ⑤ `@BOB`

又是一条 **A 指令**，这次是符号形式。
汇编器查符号表，`BOB = 31`，即十进制 31。
31 的二进制为 `0000000000011111`。
所以整条机器码为：

```
0000000000011111
```

---

### ⑥ `AD=!M`

这是 C 指令，表示“把内存 M 的内容取反后，存入寄存器 A 和 D”。

* `comp=!M` → `a=1`, `c1–c6 = 110001`
* `dest=AD` → `110`
* `jump=null` → `000`
拼接后为：

```
1111110001111000
```

---

## ✅ 三、总结：这张图展示了什么

整张幻灯片的目的是**演示从汇编语言到机器码的转换过程**。
每一条人类可读的汇编语句（如 `@7`, `D=0`, `0;JMP` 等），
汇编器都会把它转化为对应的 16 位二进制编码。

换句话说，这个表展示了汇编语言与机器码一一对应的关系。
这是计算机“读懂”程序的关键步骤。

---

\[口语化表达]
这页就是在举个具体例子告诉你，汇编语言到底是怎么变成机器能读的 0 和 1 的。比如 `@7` 就变成 “0000000000000111”，意思是把 7 装进 A 寄存器；`D=0` 是让 D 等于 0，对应的二进制是“1110101010001000”；`0;JMP` 表示无条件跳转，也是有固定的二进制编码。甚至像 `@BOB` 这种符号，汇编器会先查出 BOB 的地址（假设是31），再把它转成“0000000000011111”。总的来说，这页图就是在告诉你：汇编器就是把人写的这些汇编指令，一条条翻译成 16 位的 0 和 1，机器才能真正执行。


---

## 第 15 页

![第 15 页](Lecture09-1 (1)_assets/page-015.png)

这页讲的是 **汇编器如何处理“符号（symbol）”**，也叫 **符号解析（symbol resolution）**。在汇编语言里，我们不仅写具体数字地址，还会写人类可读的名字，比如 `(LOOP)`、`@sum`、`@KBD` 等。汇编器需要把这些名字最终都换成**确定的数字地址**，才能生成机器码。

## 1) 为什么需要“符号”

典型的汇编程序里会出现很多符号：

* **跳转目标的标签**：例如 `(LOOP)`，供 `0;JMP` 或 `D;JGT` 之类的指令跳转到。
* **特殊内存位置的名字**：如屏幕、键盘、栈指针等（平台预定义）。
* **变量名**：例如 `@sum`、`@i`，让程序更好读。

## 2) Hack 汇编里的三类符号

* **预定义符号（平台内置）**：由 Hack 平台提前约定的名字，指向固定地址，例如 `SP`、`LCL`、`ARG`、`THIS`、`THAT`、`SCREEN`、`KBD`、以及 `R0`～`R15` 等。
* **标签（用户自定义）**：写作 `(LABEL)`，表示**当前这一行之后**第一条指令在 ROM 中的地址；供跳转使用。
* **变量（用户自定义）**：在指令里以 `@varName` 首次出现时，汇编器会为其分配一个**空闲的 RAM 地址**（Hack 规范从地址 16 开始往上分配），之后再遇到同名变量都用同一个地址。

## 3) 汇编器如何“解析”符号（常见做法）

* **第一遍（扫描标签）**：忽略注释/空行，只数“真实指令”的条数；遇到 `(LABEL)` 就把它记录到**符号表**里，值为“下一条指令的 ROM 地址”。
* **第二遍（替换与分配）**：翻译指令。

* `@数字` → 直接转成 A 指令的二进制。
* `@预定义符号/标签` → 用符号表里的地址替换。
* `@变量名`（未在表中）→ 从 16 起分配新 RAM 地址，加入符号表并替换。

这样，所有 `@xxx` 最终都会变成 **“@某个确定的数字地址”**，从而输出正确的 16 位机器码。

---

\[口语化表达]
这页在说：汇编里的“名字”都得最后变成数字地址。名字分三种：系统自带的（比如 SP、SCREEN）、你自己写的标签（像 (LOOP) 给跳转用）、还有你自己起的变量（像 @sum）。汇编器通常扫两遍：第一遍把所有标签记成“这儿的下一条指令在第几号”；第二遍把每个 @名字 换成具体数字——预定义和标签直接查表，第一次见到的变量就从地址 16 开始往上分配。总之，程序里看着友好的名字，最后都会被翻译成实打实的地址。


---

## 第 16 页

![第 16 页](Lecture09-1 (1)_assets/page-016.png)

这页介绍 **Hack 汇编里的“预定义符号（Predefined Symbols）”**——也就是在汇编开始前，汇编器已经准备好的一批名字，它们**自动映射到固定的内存地址**，方便写程序时不用直接写硬编码的数字地址。

## 1) 预定义符号是什么

* 在汇编器启动时就已经放入符号表。
* 它们**本身没有魔法**，只是**固定地址的别名**，让代码更清晰易读。

## 2) 三大类预定义符号

### A. 虚拟寄存器（Virtual registers）

* **`R0` … `R15`**
* **对应 RAM 地址 `0 … 15`**。
用法示例：`@R0` 等价于 `@0`。

### B. I/O 指针（I/O pointers）

* **`SCREEN`**：屏幕显存基址 → **RAM 地址 16384**
* **`KBD`**：键盘映射基址 → **RAM 地址 24576**
这两个是**内存映射 I/O**的起始地址，常用于图形绘制、键盘读取。

### C. VM 控制指针（VM control pointers）

* **`SP, LCL, ARG, THIS, THAT`**
* **对应 RAM 地址 `0, 1, 2, 3, 4`**（栈指针与若干基址指针）。
在 Nand2Tetris 的 VM/编译器阶段会频繁用到。

> 右侧代码框给了“典型的符号化汇编代码”示例：既有 `@R0`、`@SCREEN` 这些预定义符号，也有用户自定义的变量（如 `@counter`、`@x`）和标签 `(LOOP)`、`(END)`。汇编时，预定义符号直接替换为各自固定地址；自定义变量/标签按符号解析规则处理。

---

### 实际使用小贴士

* **A 指令中用最自然**：`@SCREEN`、`@KBD`、`@R13` 等。
* 与普通数字等价，但**可读性更高**；移植和维护更省心。
* 写图形/键盘程序时，记住 **`SCREEN=16384`**、**`KBD=24576`** 就行。

---

\[口语化表达]
这页就是在说：Hack 已经帮你起好了几组常用“地址昵称”。像 `R0` 到 `R15` 就是 RAM 的 0～15；`SCREEN` 是 16384（屏幕显存起点），`KBD` 是 24576（键盘寄存器）；`SP/LCL/ARG/THIS/THAT` 是 0～4 这些控制指针。写程序时直接用这些名字，汇编器会自动换成固定地址，代码更好读，也不怕记错数字。右边例子就演示了把这些预定义符号跟你自己起的变量、标签混着用。


---

## 第 17 页

![第 17 页](Lecture09-1 (1)_assets/page-017.png)

这页讲的是 **用户自定义符号（User Defined Symbols）**，也就是程序员在 Hack 汇编语言中自己起的名字，用来标记跳转位置或变量。相比上页的预定义符号（系统自动提供的），这些是**程序员自己定义的符号**，汇编器会在翻译时动态地给它们分配地址。

---

## 一、标签符号（Label Symbols）

* 标签符号用于给**跳转命令**（如 `0;JMP`, `D;JGT` 等）指定目标位置。
* 它通过伪命令 `(XXX)` 来声明。
比如：

```
(LOOP)
D=M
@LOOP
0;JMP
```

这里 `(LOOP)` 定义了一个名为 `LOOP` 的标签，它代表“下一条指令”（也就是 `D=M`）所在的**指令内存地址（instruction memory location）**。
当汇编器翻译 `@LOOP` 时，它会查符号表，把 `LOOP` 替换成该地址（例如第 4 行）。

---

## 二、变量符号（Variable Symbols）

* 任何在汇编代码中出现的符号（如 `@counter`, `@sum`, `@x`），如果：

* 不是预定义符号；
* 也没有被 `(XXX)` 定义为标签；
那它就会被认为是**变量**。
* 汇编器会**自动为这种变量分配内存地址**，从 **RAM 地址 16** 开始依次分配。
例如：

```
@counter  → RAM[16]
@sum      → RAM[17]
@x        → RAM[18]
```

每个变量只在第一次出现时分配地址，以后再次使用就直接引用该地址。

---

## 三、命名约定（Conventions）

* Hack 程序员一般**用小写字母写变量名**（如 `counter`, `sum`, `x`），
**用大写字母写标签和系统符号**（如 `(LOOP)`, `@SCREEN`, `@END`）。
* 这样更符合“人类交流”的习惯，易读、易区分。
幻灯片特别强调这一点：
👉 “**Communicating with humans!**” —— 编程不只是写给机器看，也要让人能读懂。

---

## 四、右侧代码框举例说明

右边的 Hack 汇编代码示例展示了几种符号的混合使用：

* 系统预定义符号：`@R0`, `@SCREEN`
* 用户自定义变量：`@counter`, `@x`
* 用户自定义标签：`(LOOP)`, `(END)`

汇编器会在翻译时：

1. 先在第一遍扫描中记录 `(LOOP)`、`(END)` 对应的 ROM 地址；
2. 然后在第二遍扫描时，把 `@counter`, `@x` 分配到 RAM 16、17 等；
3. 最终全部替换成数字地址生成机器码。

---

\[口语化表达]
这页讲的是“程序员自己起的名字”，主要有两种：标签和变量。像 `(LOOP)` 这种标签，是给跳转命令定目标用的，汇编器会记下它对应的指令地址；而 `@counter`、`@x` 这种符号，如果没在别处定义过，就当变量处理，从内存 16 开始给它们一个个分配地址。Hack 里还约定写法：变量小写、标签和系统符号大写，这样看起来更清楚。总的来说，这一页就是告诉我们，汇编程序里除了固定名字，还能自己造名字，汇编器会帮你把它们变成具体的数字地址。


---

## 第 18 页

![第 18 页](Lecture09-1 (1)_assets/page-018.png)

这页在回答：**Hack 汇编里“符号（symbol）都有哪几类？**
通过中间那段示例代码，配合红色箭头，把 4 类最常见的符号指给你看：

1. **预定义符号：虚拟寄存器（Predefined · Virtual Register）**

* 例子：`@R0`、`@R1` … `@R15`。
* 作用：这些名字在汇编开始前就已经映射到固定的 RAM 地址 0–15。写 `@R0` 等价于写 `@0`，更直观。

2. **变量（Variable）**

* 例子：`@counter`、`@x` 等。
* 规则：凡是在代码里出现、且不是预定义符号、也不是用 `(LOOP)` 这种方式定义为“标签”的名字，都会当作**变量**。
* 分配：由汇编器自动从 **RAM 地址 16** 起依次分配空闲地址，之后再次使用同名变量就指向同一地址。

3. **预定义符号：I/O 指针（Predefined · I/O Pointer）**

* 例子：`@SCREEN`、`@KBD`。
* 作用：分别指向屏幕显存与键盘输入的**内存映射基址**（固定地址）。做图形或键盘读取时用它们而不是硬编码数字。

4. **标签符号（Label Symbol）**

* 例子：`(LOOP)`、`(END)`。
* 作用：用来**标记跳转目标**。标签代表“下一条指令在指令存储器（ROM）中的地址”。
* 使用：跳转时写 `@LOOP`、`0;JMP` 等，汇编器会把 `LOOP` 替换为它对应的指令地址。

> 小结：**预定义**的是系统先给的固定地址别名（虚拟寄存器、I/O 指针等）；**用户自定义**的分两类：
>
> * **标签**：标记指令地址，给跳转用；
> * **变量**：自动从 RAM16 开始分配数据存储地址。

---

\[口语化表达]
这页就是拿一段 Hack 代码告诉你：代码里的名字主要有四种——`@R0` 这种是系统预先给的“虚拟寄存器”；`@SCREEN` 是预先给好的 I/O 地址（屏幕/键盘）；`(LOOP)`、`(END)` 这种用括号的是“标签”，给跳转用；`@counter`、`@x` 这种就是普通变量，汇编器会从 RAM16 往后给它们分配内存地址。总之：预定义的都指固定地址；自己起名的，要么是跳转标签，要么是会被自动分配地址的变量。


---

## 第 19 页

![第 19 页](Lecture09-1 (1)_assets/page-019.png)

这页是一个**符号表（symbol table）示例题**：给出左侧这段 Hack 汇编程序，问**汇编完成后**，符号表里各类符号对应的地址是多少，并给出标准写法（右侧）。

### 要点说明

* **预定义符号（虚拟寄存器）**：`R0…R15` 在汇编开始前就固定映射到 RAM 地址 `0…15`。
所以：`R0 → 0`，`R1 → 1`。
* **标签符号（Label）**：形如 `(LOOP)`、`(WRITE)`、`(END)`。
规则：**标签代表“其后第一条指令”的 ROM 地址**（即指令序号，不计注释与空白）。
因此示例中：

* `LOOP → 4`：`(LOOP)` 后面的第一条指令地址是 4；
* `WRITE → 18`：`(WRITE)` 后面的第一条指令地址是 18；
* `END → 22`：`(END)` 后面的第一条指令 `@END` 的地址是 22。
* **变量符号（Variable）**：形如 `i`、`sum`。
规则：**第一次出现的用户变量**，从 RAM **16** 开始**依次**分配：

* `i → 16`（本程序中首次出现的变量）；
* `sum → 17`（第二个出现的变量）。
* 右侧给的最终符号表（题目指定格式）：

```
R0     0
R1     1
i      16
sum    17
LOOP   4
WRITE  18
END    22
```
* 汇编器通常**两遍**处理：
① 第一遍记录所有**标签**的 ROM 地址；
② 第二遍在翻译指令时，给**变量**从 RAM16 起顺序分配地址，并把所有符号替换成具体数值。

---

\[口语化表达]
这页就是拿一段 Hack 代码练手：算完汇编后，符号表该长啥样。系统自带的寄存器像 `R0、R1` 固定就是地址 0、1；你自己起的变量像 `i、sum`，第一次碰到就从 RAM16 往后排，所以是 16、17；用括号的标签 `(LOOP)`、`(WRITE)`、`(END)` 不是占内存，它们指向**后面那条指令**的 ROM 序号，所以分别是 4、18、22。最后表格就写成：`R0=0, R1=1, i=16, sum=17, LOOP=4, WRITE=18, END=22`。


---

## 第 20 页

![第 20 页](Lecture09-1 (1)_assets/page-020.png)

这页标题是 **“Next”**，意思是“接下来要做的事”。
内容非常简短，说明这是课程或讲座的最后一页，用来**总结并引出后续工作**。

---

### 一、幻灯片内容解释

1. **Completing the assembler（完成汇编器）**

* 这表示下一个学习或实践任务是“完善汇编器的实现”。
* 在前面几页我们已经学习了汇编器（assembler）的核心组成部分：

* 识别 A 指令、C 指令、标签符号等；
* 将符号转成地址；
* 把指令翻译成二进制。
* 所以“completing the assembler”意味着：
→ 要把这些逻辑整合起来，做出一个完整的程序，可以从 Hack 汇编代码自动生成机器码（`.hack` 文件）。

2. **Questions?（有问题吗？）**

* 这是老师或讲师用于结尾提问环节的常规提示，
鼓励学生就汇编器实现过程中的疑惑提出问题，比如：

* 符号表如何维护？
* 如何处理两遍扫描？
* 翻译过程中的错误检测怎么实现？

---

### 二、总结性理解

这页的重点不在内容，而在信号：
课程到此为止，下一步进入**完整实现阶段**。之前学的语法分析、符号处理、A/C 指令翻译等内容要整合到一起，实现一个能真正运行的 Hack 汇编器。

---

\[口语化表达]
这一页其实是结尾总结，意思是“接下来我们要把汇编器做完整”。前面讲了怎么识别 A 指令、C 指令、符号、标签，现在该把这些拼起来，写出一个真正能把汇编代码翻成二进制机器码的程序。然后老师顺带问一句：“有问题吗？”——就是提醒大家如果汇编流程、符号表或指令翻译还有不懂的，现在可以提问。
