

---

## 第 1 页

![第 1 页](Chapter 3 - Programmable Logic ___lers (slides with annotations)_assets/page-001.png)

这张幻灯片来自德国亚琛工业大学（RWTH Aachen University）的一门课程，题为 **“12.24196 Introduction to Embedded Systems”**（嵌入式系统导论）。以下是详细解释：

---

### 🧩 内容解析

#### 1. 学校与课程信息

* **学校**：RWTH Aachen University（亚琛工业大学）是德国著名的理工大学之一，以工程学和计算机科学见长。
* **院系**：Informatik 11 – Embedded Software（计算机科学第11研究所：嵌入式软件方向）。
* **教授与助教**：

* **Prof. Dr.-Ing. Stefan Kowalewski**：该研究所的负责人之一，主要研究嵌入式系统与安全性。
* **Julius Kahle, M. Sc.**：硕士学位持有者，可能是助教或讲师。
* **学期**：Summer Semester 2025（2025年夏季学期）。
* **课程编号**：12.24196 —— 通常用于学校内部标识课程。

#### 2. 课程名称与主题

* **课程总标题**：Introduction to Embedded Systems（嵌入式系统导论）。
该课程介绍嵌入式系统的基础理论与应用，通常涵盖硬件架构、实时操作系统、软件设计、系统控制等主题。

* **当前章节（Part 3）**：Programmable Logic Controllers（可编程逻辑控制器，简称 PLC）。
PLC 是工业自动化领域中非常核心的设备，用于控制生产线、机器人、传送带、机床等。
在嵌入式系统课程中，这一部分通常讲解：

* PLC 的工作原理；
* 输入/输出信号处理；
* 梯形图（Ladder Diagram）编程；
* 实时控制逻辑；
* 与其他嵌入式设备或传感器的通信。

---

### 🧠 总结要点

这页幻灯片是该课程第3部分的标题页，介绍的是 **“可编程逻辑控制器（PLC）”**，属于**嵌入式系统课程**的一部分，由亚琛工大的**Kowalewski 教授**团队在**2025年夏季学期**授课。

---

### \[口语化表达]

这张幻灯片是亚琛工业大学嵌入式系统导论课的第3部分，主要讲“可编程逻辑控制器”（PLC）。课程由Kowalewski教授和他的助教Julius Kahle在2025年夏天讲授。PLC是用来控制工业设备的核心系统，比如工厂的生产线、自动化机械等。这一部分的课会教学生PLC的原理、编程方式和它在嵌入式系统中的应用。


---

## 第 2 页

![第 2 页](Chapter 3 - Programmable Logic ___lers (slides with annotations)_assets/page-002.png)

这张幻灯片是上一张的延续，展示了课程 **“Part 3: Programmable Logic Controllers（可编程逻辑控制器）”** 的**内容纲要（Content）**。下面是详细说明：

---

### 📘 内容详细解释

#### 1. Logic Control（逻辑控制）

这是PLC系统的核心思想。逻辑控制指的是使用布尔逻辑（如与、或、非）来控制设备的运行状态。例如，只有当两个传感器都检测到某个条件满足时，机器才会启动。
👉 这一部分主要讲解逻辑运算、控制流，以及如何用逻辑实现自动化操作。

#### 2. PLC Technology（PLC技术）

介绍PLC的**硬件组成和工作原理**。包括：

* **输入/输出模块（I/O）**：与传感器和执行器相连；
* **CPU**：执行控制逻辑；
* **内存**：存储程序和数据；
* **通信接口**：与其他系统或设备连接。
👉 这部分让学生了解PLC是怎样感知外界、做出决策并控制设备的。

#### 3. Programming Languages（编程语言）

PLC有自己独特的编程方式，与一般的C或Python不同。常见的三种PLC语言如下：

* **Function Block Diagram (FBD，功能块图)**
使用“功能块”表示逻辑或数学运算，比如加法、比较、触发器等，适合可视化编程。

* **Ladder Diagram (LD，梯形图)**
形似电气接线图，用于描述逻辑关系，非常常见于工业控制。它用“继电器逻辑”方式表现控制流程。

* **Instruction List（指令表）**
类似汇编语言，用文字指令编写程序，执行效率高但可读性较差。

👉 这一部分教学生掌握不同的PLC编程方法。

#### 4. Model-based Design（基于模型的设计）

介绍如何用数学模型来设计和验证控制系统。
例如，可以在计算机上建立系统模型、模拟控制逻辑，再将其自动转换成PLC程序。
👉 这是一种现代的自动化开发方式，用于减少错误、提高效率。

#### 5. Sequential Controllers（顺序控制器）

顺序控制指系统根据特定步骤依次执行动作，比如生产流水线分阶段操作。
其中包括：

* **Sequential Function Charts (SFC，顺序功能图)**
一种描述状态转换和动作顺序的图形语言，展示“先做什么，再做什么”。

👉 这一部分帮助学生理解如何实现多步骤的自动化流程。

---

### 🧠 总结要点

这页幻灯片是PLC部分的**教学目录**，涵盖从基本逻辑控制、硬件技术、编程语言到模型设计和顺序控制的完整学习路径。可以看出，课程既讲**理论基础**，也强调**实际编程与工业应用**。

---

### \[口语化表达]

这页其实就是PLC这一章的课程目录。它会先讲逻辑控制的基本原理，然后介绍PLC的硬件结构。接着是几种PLC常用的编程语言，比如功能块图、梯形图和指令表。后面还会讲一种更高级的“基于模型的设计”，就是用建模的方式来做控制系统。最后会讲顺序控制，比如一个机器要按步骤执行动作的逻辑。这一章基本上就是从“原理—实现—优化”的顺序，把PLC讲得很系统。


---

## 第 3 页

![第 3 页](Chapter 3 - Programmable Logic ___lers (slides with annotations)_assets/page-003.png)

这张幻灯片是讲解 **“逻辑控制（Logic Control）与连续控制（Continuous Control）”** 的第一部分内容。通过一个实际例子来说明什么是逻辑控制。下面是详细解释：

---

### 📘 详细内容解读

#### 1. 主题：Logic Control vs. Continuous Control（逻辑控制 vs 连续控制）

* **逻辑控制（Logic Control）**：指系统通过“开/关”、“是/否”这类离散逻辑判断来决定动作，例如“温度超过100°C就关闭加热器”。
* **连续控制（Continuous Control）**：指控制变量是连续变化的，比如调节温度保持在一个稳定值（PID控制）。

这页主要是讲逻辑控制的例子。

---

#### 2. Example 1: A Trip (Abschaltung, Notabschaltung)

* “Trip”在这里指一种**紧急停机（紧急断开）**操作，也称为**安全切断（Abschaltung / Notabschaltung）**。
* 它的功能是：**当检测到危险或异常情况时，自动关闭某个系统部分，以防止事故发生**。
例如：温度过高 → 自动关闭加热器。

---

#### 3. Representation（图形表示）

幻灯片中的示意图是一个 **P\&ID 图（Piping and Instrumentation Diagram）**，按照 **ISO 3511** 标准绘制。

* **P\&ID 图**用于表示工业系统中主要的设备与控制关系，例如：
管道（pipes）、储罐（tanks）、阀门（valves）以及控制仪表（instruments）。
* 在图中可以看到一个 **Tank（储罐）**，里面装有液体；旁边有一个**加热元件**和\*\*阀门（valve）\*\*控制流体流动。

---

#### 4. 功能说明（Function of the Trip）

> “Switch off heating, when temp has reached a certain value.”
> 意思是：**当温度达到设定值时，自动关闭加热系统**。

在图中，“TIS⁺” 是一个温度测量与控制信号：

* **T** = Temperature（温度）
* **I** = Indication（指示）
* **S⁺** = Switching at upper limit（在上限值时触发开关）

也就是说，当温度超过安全上限时，TIS⁺ 信号会触发一个**逻辑动作（switch off）**，使加热器停止工作。

---

#### 5. Purpose（目的）

> “Avoid undesired (e.g. dangerous) process states”
> 即：**避免系统进入不期望或危险状态**。
> 例如防止过热、爆炸或设备损坏，这就是逻辑控制的重要意义——在安全边界上起保护作用。

---

### 🧠 总结要点

这页课件通过“温度过高→自动关机”的例子解释了逻辑控制的概念：
逻辑控制使用离散信号进行决策（要么开，要么关），与连续控制（持续调节）不同。
例子中的P\&ID图展示了实际工业系统中如何用传感器和逻辑信号保障安全。

---

### \[口语化表达]

这页主要讲逻辑控制的概念，用的是一个“温度过高自动断电”的例子。图上是一个储罐系统，有温度传感器TIS⁺来监控加热情况。当温度达到设定上限时，这个信号就会触发系统关闭加热器，防止危险发生。它用的是P\&ID这种工业标准图，能看到罐子、阀门和加热装置。简单来说，这页讲的就是：逻辑控制是一种“要么开要么关”的安全保护机制，用来避免系统出问题。


---

## 第 4 页

![第 4 页](Chapter 3 - Programmable Logic ___lers (slides with annotations)_assets/page-004.png)

这张幻灯片延续上一页内容，继续讲解 **“逻辑控制 vs 连续控制（Logic Control vs. Continuous Control）”**，这次展示的是第二个逻辑控制的例子 —— **Interlock（联锁，德语：Verriegelung）**。
下面是详细解释 👇

---

### 📘 详细内容解析

#### 1. Example 2: An Interlock（联锁）

“Interlock” 的意思是 **联锁保护**，即**在特定条件下，系统自动允许或禁止某些操作**。
在工业系统中，联锁用于防止操作人员执行错误的动作，从而避免造成危险或损坏。

---

#### 2. Function of the Interlock（联锁的功能）

> “Enable only desired operator action (disable undesired ones).”
> 意思是：**只允许符合条件的操作动作，禁止不合适的操作。**

举个例子：

* 假设一个储罐内的液位太低，如果这时允许操作员打开排放阀，就会造成空转或设备损坏。
* 所以系统设置了一个**联锁逻辑**：当液位低于某个阈值时，控制器会**自动禁用（disable）阀门操作**。

幻灯片右侧的图中：

* 罐体（Tank）内部液位由**LIS**监测；
* **L = Level（液位）**
* **I = Indication（指示）**
* **S– = Switching at lower limit（在下限值时触发开关）**

当液位过低时，LIS 传感器会发出信号，让控制系统**禁用“开阀”的操作**（即“enable/disable”线路控制操作权限）。

---

#### 3. Purpose（目的）

> “Avoid undesired process states caused by undesired operator actions.”
> 意思是：**防止因为人为误操作而导致不期望的工艺状态**。

换句话说，联锁系统是一种**逻辑安全保护机制**，用来限制操作员的行为，确保只有在安全、合理条件下才能进行某些操作。

---

### 🧠 总结要点

这页讲的是逻辑控制中的第二种应用——**联锁（Interlock）**。
它的核心思想是：通过逻辑条件控制操作权限，防止操作员做出会导致危险或错误状态的动作。
图中以液位传感器LIS为例，当液位过低时，系统自动禁止打开阀门，从而避免损坏或事故。

---

### \[口语化表达]

这页讲的是联锁控制，也就是系统在特定条件下自动“锁住”某些操作。比如图里这个储罐装液体的例子：当液位太低时，LIS传感器会发出信号，让系统禁止操作员再开阀放料，防止设备出问题。只有当液位正常时，操作才会被允许。这种控制就是为了防止人为误操作引起危险，可以理解成系统在帮人“防呆防错”。


---

## 第 5 页

![第 5 页](Chapter 3 - Programmable Logic ___lers (slides with annotations)_assets/page-005.png)

这张幻灯片是 **“Logic Control vs. Continuous Control (3)”（逻辑控制与连续控制 第3部分）**，讲的是逻辑控制的第三种典型应用——**顺序控制（Sequence Controller，德语：Ablaufsteuerung）**。下面是详细解释 👇

---

### 📘 详细内容解析

#### 1. Example 3: Sequence Controller（顺序控制器）

“Sequence Controller” 的意思是 **按照预定顺序自动执行一系列工艺步骤**。
它常用于工业自动化流程，比如灌装、加热、冷却、清洗等环节，系统会根据逻辑条件自动控制各个动作的执行顺序。

---

#### 2. Function of a Sequence Controller（顺序控制器的功能）

> “Realize a desired sequence of process steps.”
> 即：**让系统按指定顺序完成一系列操作步骤**。
> 这种控制方式确保每一步都在合适的条件下执行，前一步未完成，后一步不会启动。

---

#### 3. 例子说明（Here）

幻灯片中给出了一个典型的储罐系统控制流程，包含三个自动执行的步骤：

1. **Fill tank（灌装罐体）**

* 打开阀门 V1（进料阀），
* 直到液位传感器 **LIS⁺**（液位上限）检测到罐体液面达到目标高度时，关闭阀门。

2. **Heat up（加热）**

* 打开阀门 V2（蒸汽或加热介质阀），
* 直到温度传感器 **TIS⁺**（温度上限）检测到温度达到设定值时，关闭加热阀门。

3. **Drain tank（排空罐体）**

* 打开阀门 V3（出料阀），
* 直到液位传感器 **LIS⁻**（液位下限）检测到罐体空了为止。

整个过程依次执行，不需要人工干预，由逻辑控制系统自动判断各传感器状态。

---

#### 4. 图中符号含义

* **MS** = Multivariable Switching（多变量逻辑控制器）
表示系统根据多个传感器信号（液位、温度等）综合判断下一步该做什么。
* **LIS⁺ / LIS⁻** = 液位传感器（上限 / 下限）
* **TIS⁺** = 温度传感器（上限）
* **V1 / V2 / V3** = 各个控制阀门，对应进料、加热、排料操作。

虚线箭头代表信号线路：传感器 → 控制逻辑（MS） → 控制阀动作。

---

#### 5. 总结逻辑

这个系统通过逻辑信号实现了一个**自动化生产序列**。
每个动作（开阀、关阀、加热、排料）都是通过**逻辑条件触发**的，而不是连续控制（比如PID调节）。
因此它属于典型的 **离散事件逻辑控制系统（Discrete Event Logic Control）**。

---

### 🧠 总结要点

这一页讲的“顺序控制器”是一种能自动按照设定步骤执行任务的逻辑控制方式。
幻灯片以储罐操作为例，展示了：
1️⃣ 自动灌装 → 2️⃣ 自动加热 → 3️⃣ 自动排料。
每一步都由传感器信号决定是否进入下一步，整个流程安全、高效、无需人工干预。

---

### \[口语化表达]

这页讲的是顺序控制，也就是系统能自己按照固定步骤自动运行。举例来说，这个储罐系统会先打开V1灌装，液位到达上限后自动关阀；接着打开V2加热，温度达到设定值后又自动停；最后打开V3排料，一直到液位降到下限。整个过程都是由传感器和逻辑控制器自动判断完成的，人不用手动操作。这种控制方式在工厂里很常见，比如自动清洗、灌装、加热、冷却等流程，全靠顺序控制实现。


---

## 第 6 页

![第 6 页](Chapter 3 - Programmable Logic ___lers (slides with annotations)_assets/page-006.png)

这张幻灯片延续了前一页的内容，仍然是讲 **“Logic Control vs. Continuous Control (3)”（逻辑控制与连续控制 第3部分）**，但这里展示的是顺序控制器（Sequence Controller）在**时间控制**条件下的另一种实现方式。下面是详细解释 👇

---

### 📘 详细内容解析

#### 1. Example 3: Sequence Controller（顺序控制器）

标题中的 **Ablaufsteuerung（德语）** 意为“过程顺序控制”或“流程控制”。
这个控制方式用于**自动执行一系列工艺步骤**，系统会按照预定逻辑顺序，依次完成每个操作。

---

#### 2. Function of a Sequence Controller（顺序控制器的功能）

> “Realize a desired sequence of process steps.”
> 意思是：**让系统自动实现一连串工艺步骤的顺序控制**。
> 它确保每一步按照计划、有逻辑地执行，防止同时或错误操作。

---

#### 3. 示例（Here）

幻灯片中的例子展示了一个典型的储罐自动控制流程，与前一页类似，但区别在于——这次不是根据传感器信号，而是**基于时间控制**（time-based control）。

具体步骤如下：

1. **Fill tank（灌装罐体）**

* 打开阀门 **V1**，
* 一直运行，直到液位传感器 **LIS⁺** 检测到液面达到上限为止。

2. **Heat up（加热）**

* 打开阀门 **V2**（控制加热介质流入），
* **不是根据温度传感器TIS⁺**，而是**保持加热 m 分钟**（定时加热）。
* “m minutes” 意味着这一步是**时间驱动**的逻辑操作。

3. **Drain tank（排空罐体）**

* 打开阀门 **V3**，
* **保持 n 分钟**后关闭。
* 同样，这一步也是基于时间控制的，而不是依赖液位传感器。

---

#### 4. 图中符号解释

* **MS = Multivariable Switching（多变量切换控制）**：表示中央逻辑控制模块，根据多个条件（时间、液位、温度等）决定动作顺序。
* **LIS⁺ / LIS⁻**：液位传感器，上限/下限检测。
* **TIS⁺**：温度传感器。
* **V1、V2、V3**：分别是进料、加热和排料阀门。
* 图中的虚线箭头代表信号或逻辑关系：MS根据传感器信号或时间逻辑决定哪些阀门打开或关闭。

---

#### 5. 与前一页的区别

前一页的顺序控制是\*\*基于传感器反馈（event-driven）**的，而这一页则是**基于时间（time-driven）\*\*的。
这说明逻辑控制可以通过不同方式实现过程控制，不一定都要依赖实时测量数据。

---

### 🧠 总结要点

这一页讲的仍然是顺序控制（Sequence Control），但强调了**时间控制逻辑**。
系统会按照以下顺序自动运行：
1️⃣ 灌装到上限；
2️⃣ 加热 m 分钟；
3️⃣ 排空 n 分钟。
每一步都有明确的时序逻辑，由中央控制器（MS）协调执行。
这是一种常见的**自动化流程控制方案**，尤其用于简单、可预测的生产过程。

---

### \[口语化表达]

这页讲的是顺序控制的另一种形式，就是用时间来控制流程。比如这个储罐系统：先打开V1灌装到液位上限；然后打开V2加热m分钟，不管温度有没有达到某个值；最后打开V3排料n分钟后自动关掉。所有动作的先后顺序和持续时间都由控制器MS来管理。这种逻辑不靠传感器信号，而是靠时间来推进整个过程，常见于一些固定节拍的自动化生产线上。


---

## 第 7 页

![第 7 页](Chapter 3 - Programmable Logic ___lers (slides with annotations)_assets/page-007.png)

这张幻灯片是 **“Logic Control vs. Continuous Control (4)”（逻辑控制与连续控制 第4部分）**，讲的是“连续控制器”（Continuous Controller）这一类控制方式。
这部分的重点是说明连续控制和前面提到的逻辑控制的根本区别。下面是详细解释 👇

---

### 📘 详细内容解析

#### 1. Example 4: A Continuous Controller（连续控制器）

**Continuous Controller** 意为“连续控制器”，即能够**持续调节**控制量以维持系统稳定的控制方式。
与逻辑控制（开/关式控制）不同，连续控制不是单纯地“开”或“关”，而是**不断计算输出**，使系统变量保持在目标值（setpoint）附近。

---

#### 2. Function of a Continuous Controller（连续控制器的功能）

> “Keep process variable at a desired value (despite disturbances or in case of changes of the settings).”
> 意思是：
> **让过程变量（process variable）在期望值处保持稳定，即使受到扰动或设定值变化的影响。**

这类控制器能在系统环境波动或负载变化时，自动调节控制输出，抵消干扰。例如：

* 如果温度偏低，系统会逐渐加大加热功率；
* 如果温度偏高，系统则减小加热功率。
它不是简单地“开加热 / 关加热”，而是“连续地调整”功率大小。

---

#### 3. 图示说明

幻灯片右侧的图展示了一个典型的**连续控制系统**：

* **Tank（储罐）**：被控对象，里面装有液体。
* **TIC**：Temperature Indicating Controller（温度指示控制器）。

* “T” = Temperature（温度）
* “I” = Indication（测量与显示）
* “C” = Controller（控制器）
它负责测量液体温度，并与设定值比较。
* **阀门（valve）**：调节加热介质的流量。
控制器（TIC）根据测得温度与设定值的偏差，连续调节阀门的开度，使温度保持在目标范围。

这种控制方式一般使用**PID控制算法**（比例-积分-微分控制），是工业过程控制中最常见的连续控制形式。

---

#### 4. 对比逻辑控制

| 对比项目 | 逻辑控制（Logic Control） | 连续控制（Continuous Control） |
| ---- | ------------------- | ------------------------ |
| 控制输出 | 开 / 关（离散）           | 可变（连续）                   |
| 控制目标 | 触发条件                | 维持稳定值                    |
| 示例   | 超温自动断电              | 自动调节加热功率维持恒温             |
| 应用场景 | 安全保护、顺序操作           | 温度、压力、流量等过程控制            |

换句话说，逻辑控制像“开关控制”，而连续控制更像“自动恒温器”那样**持续微调**。

---

### 🧠 总结要点

这一页讲述了\*\*连续控制（Continuous Control）\*\*的概念。
它的主要任务是：**让被控变量（例如温度、压力、液位）始终保持在设定值附近，即使有外界干扰。**
图中的温度控制器TIC通过连续调节阀门开度实现这种平衡。
这种控制方式是工业自动化中维持稳定生产状态的关键技术。

---

### \[口语化表达]

这页讲的是“连续控制器”，也就是那种能自动、连续调整系统状态的控制方式。比如图里的温度控制器TIC会不断测量罐里的温度，然后自动调节阀门开度，让温度保持在设定值附近。它不是简单地“开或关”，而是一直在微调，哪怕外界有干扰也能保持稳定。可以想象成家里的空调自动恒温功能——温度低了就多加点热，高了就少一点热，这就是连续控制。


---

## 第 8 页

![第 8 页](Chapter 3 - Programmable Logic ___lers (slides with annotations)_assets/page-008.png)

这张幻灯片是 **“Logic Control vs. Continuous Control (5)”（逻辑控制与连续控制 第5部分）**，主要讲解两种控制方式在结构上的**通用控制体系（General Control Structure）**。
它将之前介绍的三种逻辑控制和一种连续控制放到统一框架中进行总结。
下面是详细说明 👇

---

### 📘 详细内容解析

#### 1. 标题含义

> “General Control Structure (for all three examples)”
> 意思是：**这是适用于前面所有控制类型（逻辑控制、顺序控制、连续控制）的通用控制结构模型。**

这页展示的是控制系统的总体构成，包括人机交互、控制器、执行元件（actuators）以及传感器（sensors）等部分。

---

#### 2. 三个主要模块说明

##### (1) Operating Elements / Monitor / Displays（操作与监控部分）

* **Operating Elements**：操作界面，人可以输入指令（比如设定温度、启动流程）。
* **Monitor**：监视模块，用于观察系统状态。
* **Displays**：显示设备，如仪表盘或人机界面（HMI）。
👉 这是人机交互部分，让操作员与系统进行沟通。

##### (2) Controller（控制器）

* 控制器是系统的大脑，接收输入信号（比如温度、液位），与目标值（setpoint）比较，决定输出动作。
* 根据不同控制类型，控制器的工作方式不同：

* **逻辑控制（Logic Control）**：输出是“开/关”、“启/停”等离散信号；
* **连续控制（Continuous Control）**：输出是连续可调信号（比如调节阀门开度、调功率大小）。

##### (3) Plant (Strecke)（被控对象）

* “Plant”指的是实际的被控系统，如储罐、机械臂、传送带、加热装置等。
* 包含两个部分：

* **Actuators（执行器）**：根据控制器的命令行动，例如电机、阀门、加热器。
* **Sensors（传感器）**：测量系统当前状态（温度、压力、液位等），反馈给控制器。

---

#### 3. 图中手写标注解析

教授手写的红色和绿色标记区分了：

* **红色路径：逻辑控制（Logic / Discrete Control）**

* 离散事件驱动的控制；
* 控制器只在特定条件下动作；
* 比如“液位高→关阀”、“温度低→开加热”；
* 属于“Steuerung（控制）”类型。
* **绿色路径：连续控制（Continuous Control）**

* 控制器持续调节输出；
* 比如通过PID算法维持温度恒定；
* 属于“Regelung（调节）”类型。

底部的德语部分说明了两种控制结构的差异：

* **Regelkreis（反馈控制回路）**：连续控制，有反馈（如PID系统）。
* **Steuerung（开关控制）**：逻辑控制，无持续反馈，只依赖逻辑条件。

---

#### 4. 总体逻辑总结

这个图展示了一个工业控制系统的完整闭环：

1. 操作员输入目标 →
2. 控制器计算并发出命令 →
3. 执行器执行动作，影响系统 →
4. 传感器反馈系统状态 →
5. 控制器再根据反馈调整输出（若是连续控制）。

逻辑控制和连续控制都遵循这套结构，只是：

* 前者是离散触发式；
* 后者是连续调节式。

---

### 🧠 总结要点

这页总结了逻辑控制与连续控制的**通用结构模型**。
系统由操作界面、控制器、执行机构和传感器组成，形成一个闭环。
逻辑控制负责“开关决策”，连续控制负责“平滑调节”。
两者都遵循相同的信息流：**输入 → 决策 → 执行 → 反馈**，只是反馈是否持续起作用不同。

---

### \[口语化表达]

这页是对前面几种控制方式的总结，讲的是所有控制系统的通用结构。一个系统一般都有三部分：人机操作界面（操作、显示、监控）、控制器，以及被控对象（比如机器或储罐）。人输入目标，控制器发出指令，执行器去行动，传感器再把结果反馈回来。逻辑控制就是那种“达到某条件就开/关”的方式，而连续控制是“实时调节保持稳定”的方式。教授在图上还用红色标出了逻辑控制（离散控制）的路径，用绿色标出了连续控制（带反馈的调节）。总结一句话，这页就是在告诉我们：不管是哪种控制，核心结构其实都一样，只是控制信号的类型不同。


---

## 第 9 页

![第 9 页](Chapter 3 - Programmable Logic ___lers (slides with annotations)_assets/page-009.png)

这张幻灯片是 **“Logic Control vs. Continuous Control (6)”（逻辑控制与连续控制 第6部分）**，是这一章节的总结页，重点讲解**逻辑控制和连续控制的本质区别**。
下面是详细说明 👇

---

### 📘 详细内容解析

#### 1. 问题：两种控制方式的主要区别是什么？

> “Main difference between logic (trip, interlock, sequence controller) and continuous control?”
> 意思是：**逻辑控制（如Trip、Interlock、Sequence Controller）和连续控制之间的主要区别是什么？**

简单来说，区别就在于——
🔹 **逻辑控制（Logic Control）** 处理**离散变量（discrete variables）**，
🔹 **连续控制（Continuous Control）** 处理**连续变量（continuous variables）**。

---

#### 2. 逻辑控制的主要目的

> “The main purpose of logic controllers is the processing of discrete variables.”
> 逻辑控制器的核心任务是**处理离散信号**，即那些只有“开 / 关”、“真 / 假”、“高 / 低”两种状态的输入输出。

例如：

* 传感器只告诉你“温度是否超过阈值”；
* 开关只表示“设备是否开启”；
* 逻辑控制根据这些条件作出判断（如关闭加热器或打开安全阀）。

这种控制通常用于安全保护、自动启停、顺序控制等场景。

---

#### 3. 举例说明：Trip（紧急停机控制）

幻灯片用“Trip”作为例子来比较两种控制方式对温度（temp）信号的处理方式：

##### 🔸 Logic Control（逻辑控制）

> **temp(t) ∈ {below\_limit, above\_limit}**
> 意思是：温度只有两种可能状态——

* “低于限值 (below\_limit)”
* “高于限值 (above\_limit)”

也就是说，系统只根据条件切换状态。
比如：

* 当温度 < 阈值：加热器“开”；
* 当温度 ≥ 阈值：加热器“关”。

控制输出是**离散的（discrete）**，只有两种动作。

---

##### 🔸 Continuous Control（连续控制）

> **temp(t) ∈ ℝ × {°C}**
> 意思是：温度是一个**连续变量**，属于实数集合 ℝ（即可以取任意数值），单位是摄氏度（°C）。
> 控制器会根据这个连续数值不断调整输出。
> 例如：

* 当温度略低时，稍微加大加热；
* 当温度接近目标值时，减小加热功率；
* 当温度超过目标时，自动降温。

控制过程是**连续变化的（continuous）**，而非“开 / 关”两种状态。

---

#### 4. 总结对比

| 对比维度 | 逻辑控制 (Logic Control)     | 连续控制 (Continuous Control) |
| ---- | ------------------------ | ------------------------- |
| 控制变量 | 离散变量（两种状态）               | 连续变量（无限取值）                |
| 控制输出 | 开 / 关、真 / 假              | 连续调节输出                    |
| 响应方式 | 条件触发                     | 实时平滑调节                    |
| 示例   | 超温自动断电、顺序操作              | 恒温控制、流量调节                 |
| 数学表示 | temp(t) ∈ {below, above} | temp(t) ∈ ℝ × {°C}        |

---

### 🧠 总结要点

这一页总结了逻辑控制和连续控制的根本区别：

* 逻辑控制只处理“有 / 没有”、“开 / 关”这样的离散状态，用在安全保护或状态切换；
* 连续控制处理的是可以无限变化的物理量（如温度、压力等），并持续调节输出。
逻辑控制像“开关”，连续控制像“旋钮”——一个跳变，一个平滑。

---

### \[口语化表达]

这页其实是在总结前面所有内容。它告诉我们逻辑控制和连续控制的核心区别在于：前者只处理“开或关”的信号，而后者能处理像温度这种连续变化的数据。举个例子，逻辑控制只会判断“温度超过限制就关掉加热器”，而连续控制会根据温度变化不断微调加热功率，让温度保持稳定。简单来说，逻辑控制是“有信号就动作”，连续控制是“看变化来调节”。


---

## 第 10 页

![第 10 页](Chapter 3 - Programmable Logic ___lers (slides with annotations)_assets/page-010.png)

这张幻灯片仍然是 **“Logic Control vs. Continuous Control (6)”** 的延续页，配合图表更直观地说明了\*\*连续控制（Continuous Control）**与**逻辑控制（Logic Control）\*\*在信号表示上的根本区别。
这页主要是通过温度信号（temperature signal）的变化示例来对比两种控制方式处理数据的不同。

---

### 📘 详细内容解析

#### 1. 图表总体介绍

幻灯片上有两个不同的温度曲线，分别代表：

* **上方曲线 temp₍C₎(t)** → 连续控制（Continuous Control）
* **下方阶梯 temp₍D₎(t)** → 逻辑控制（Discrete / Logic Control）

这两个曲线展示了同一个温度过程在两种控制逻辑下的表达方式。

---

#### 2. 连续控制（Continuous Control）

> **temp₍C₎(t) ∈ \[−30°, 200°]**

意思是：温度在时间 t 的变化范围是一个**连续区间**，可以取任意值，从 −30°C 到 200°C 之间的所有实数。

在图中，上方的黑色曲线代表一个实际温度变化过程。
你可以看到它随着时间平滑变化，可能升温、降温，但**没有跳变**。

**特点：**

* 温度是连续的；
* 控制器会根据每一时刻的精确数值进行调节；
* 适合用于恒温、压力控制、速度调节等需要“平滑控制”的场景。

---

#### 3. 逻辑控制（Logic / Discrete Control）

> **temp₍D₎(t) ∈ {cold, warm, hot}**

意思是：温度只被划分为三个**离散状态**：

* **cold（冷）**
* **warm（温）**
* **hot（热）**

这时温度不再用连续的数值表示，而是被分类成几个等级。
下方绿色的阶梯图就说明了这一点：

* 当温度低于 0°C → 状态为 **cold**
* 在 0°C 到 50°C 之间 → 状态为 **warm**
* 超过 50°C → 状态为 **hot**

随着时间变化，系统温度仍在连续变化，但逻辑控制器只会在越过阈值时“切换状态”。
例如：

* 从冷变暖；
* 从暖变热；
* 再从热变回暖。

**特点：**

* 控制信号是“分级的”或“开关式”的；
* 控制器只在状态改变时动作；
* 适合用于安全保护、报警、启停逻辑等任务。

---

#### 4. 对比总结

| 控制类型                  | 数学表达                           | 信号特征        | 控制响应   |
| --------------------- | ------------------------------ | ----------- | ------ |
| **连续控制 (Continuous)** | temp₍C₎(t) ∈ \[−30°, 200°]     | 平滑、连续、可取任意值 | 实时连续调节 |
| **逻辑控制 (Discrete)**   | temp₍D₎(t) ∈ {cold, warm, hot} | 离散、跳变、分类状态  | 条件触发动作 |

换句话说：

* 连续控制**看重“精确的数值”**；
* 逻辑控制**看重“处于哪个状态”**。

两者的区别，就像“测温计的读数”（连续）和“温控器的三档开关”（离散）。

---

### 🧠 总结要点

这张幻灯片用温度的例子说明：

* **连续控制**把温度视为一个随时间连续变化的量（可以是 10.5°C、37.2°C……），控制器据此不断调整输出；
* **逻辑控制**只关心温度属于哪个区间（冷 / 温 / 热），并在阈值变化时进行“状态切换”。
因此，连续控制更精细，而逻辑控制更简洁、稳定，常用于自动启停和安全保护。

---

### \[口语化表达]

这页是用温度的例子来说明逻辑控制和连续控制的区别。上面那条黑线代表连续控制的温度变化，温度可以在 −30°C 到 200°C 之间任意变化，控制器会根据每一时刻的真实温度不断调整，比如让温度保持稳定。而下面那条绿色的阶梯线代表逻辑控制，温度只被分成三档：冷、温、热。系统不会管温度具体是多少，只会在跨过某个阈值时切换状态，比如从冷变温、从温变热。所以连续控制更细腻、反应更灵敏，而逻辑控制更简单、可靠，用来判断和执行开关动作最合适。


---

## 第 11 页

![第 11 页](Chapter 3 - Programmable Logic ___lers (slides with annotations)_assets/page-011.png)

这张幻灯片是 **“Logic Control vs. Continuous Control (7)”（逻辑控制与连续控制 第7部分）**，主要通过一个“加热系统（heating system）”的例子，展示了**逻辑控制的离散状态特征**。
与前几页讲的连续控制相比，这一页强调的是逻辑控制在时间上的“状态切换”特性。

---

### 📘 详细内容解析

#### 1. heating(t) 的定义

> **heating(t) ∈ {on, off, broken, inrepair}**

意思是：在任意时刻 *t*，加热系统（heating）的状态只能是以下四种之一：

* **on**：正在运行；
* **off**：关闭；
* **broken**：故障（损坏）；
* **inrepair**：正在维修。

这里的 *heating(t)* 不是一个连续变量（如温度），而是一个**离散状态变量**，它只能在几个固定值之间切换。

---

#### 2. 图表内容说明

图中纵轴表示不同状态（on、off、broken、inrepair），横轴是时间 *t*。

黑色水平线段表示系统在某一段时间内的状态。例如：

* 一开始系统处于 **off**；
* 然后启动变为 **on**；
* 接着设备出现故障 → 进入 **broken**；
* 维修人员修复 → 状态变为 **inrepair**；
* 最后再次恢复正常 → 回到 **on** 或 **off**。

可以看到，系统的状态是**分阶段的跳变**，每个时间段内状态保持不变，一旦条件触发，就切换到下一个状态。

---

#### 3. 与连续控制的区别

连续控制（Continuous Control）中的变量（例如温度 temp(t)）可以随时间**平滑变化**，没有固定状态类别；
而逻辑控制（Logic Control）中的变量（例如 heating(t)）只会在有限个**离散状态**之间切换。

也就是说：

* 连续控制 → “变量值随时间连续变化”；
* 逻辑控制 → “系统状态在几个固定模式之间跳变”。

这个例子展示的是一种**典型的状态机（state machine）式控制**，是PLC和嵌入式系统常见的逻辑模型。

---

#### 4. 为什么叫“Difference?”

幻灯片底部的问题“**Difference?**”是在引导学生思考：

> “这种离散状态变化（逻辑控制）与之前讲的连续变量调节（连续控制）有什么本质不同？”

答案是：

* 连续控制关注的是“变量的数值”；
* 逻辑控制关注的是“系统的状态”。
换句话说，前者调节“多少”，后者判断“是哪种状态”。

---

### 🧠 总结要点

这张幻灯片展示了逻辑控制的核心特征：
系统通过**离散状态**来描述行为（开、关、故障、维修），每个状态持续一段时间，然后在触发事件后跳转到下一个状态。
这种控制方式常见于工业自动化中，例如生产线控制、机器启停、安全保护逻辑等。
相较之下，连续控制则是对温度、压力等物理量进行连续调节。

---

### \[口语化表达]

这页讲的是逻辑控制在时间上的表现方式。它用加热系统举例，说明系统在运行中只会处于几个离散的状态，比如开、关、坏了、修理中。每个状态都保持一段时间，直到发生某个事件才会切换到下一个，比如机器坏了就从“on”变成“broken”，修完又变成“inrepair”，再回到“on”。它和连续控制最大的不同是，连续控制关注“温度到底是多少”，而逻辑控制关注“系统现在在什么状态”。简单说，连续控制是调节数值，逻辑控制是切换状态。


---

## 第 12 页

![第 12 页](Chapter 3 - Programmable Logic ___lers (slides with annotations)_assets/page-012.png)

这张幻灯片是本节课 **《Programmable Logic Controllers（可编程逻辑控制器）》** 的**目录页（Content）**，列出了接下来要讲的五个主要主题。它相当于整章的学习路线图。下面是详细解释 👇

---

### 📘 详细内容解析

#### 1. Logic Control（逻辑控制）

这一部分讲**逻辑控制的原理与概念**。
逻辑控制是PLC（可编程逻辑控制器）的基础思想，它基于“开/关”、“真/假”、“高/低电平”等离散信号进行决策。
比如：“如果温度太高就关闭加热器”、“如果按钮被按下就启动电机”。
这一章通常介绍不同类型的逻辑控制，如：

* **Trip（紧急停机）**
* **Interlock（联锁）**
* **Sequence Control（顺序控制）**

它帮助学生理解PLC在工业自动化中如何“用逻辑”控制机器。

---

#### 2. PLC Technology（PLC 技术）

这一部分会讲解**PLC 的硬件和运行机制**，包括：

* PLC 的结构（CPU、输入/输出模块、通信接口等）；
* PLC 的工作原理（扫描循环 Scan Cycle）；
* 不同类型PLC的区别（例如西门子、三菱、欧姆龙等品牌架构）；
* 如何将传感器、开关、继电器等连接到PLC上。

这是从理论过渡到实际设备理解的重要部分。

---

#### 3. Programming Languages（PLC 编程语言）

PLC 有几种国际标准化的编程语言（IEC 61131-3），这一部分主要介绍三种：

* **Function Block Diagram (FBD，功能块图)**
使用可视化“模块”连接逻辑单元，每个模块代表一种功能（如加、减、逻辑与、计时器等）。
适合图形思维、结构化编程。

* **Ladder Diagram (LD，梯形图)**
外形类似电气接线图，以“继电器逻辑”为基础。是最常见、最直观的PLC语言。
工程师可以像画电路一样写程序。

* **Instruction List（指令表）**
类似汇编语言，用简短的指令（如 LD、AND、OUT 等）来描述逻辑。
速度快、执行效率高，但可读性较低。

---

#### 4. Model-based Design（基于模型的设计）

在现代控制系统中，设计人员常用数学模型（如Simulink）来模拟系统行为。
这一部分介绍如何通过模型来设计、验证逻辑，然后自动生成PLC代码。
这种方式可以在系统投入运行前就发现逻辑错误，提高开发效率和安全性。

---

#### 5. Sequential Controllers（顺序控制器）

顺序控制是一种**按步骤执行任务**的控制方式。
例如：
1️⃣ 打开进料阀；
2️⃣ 液位达到上限后关闭阀门并启动加热；
3️⃣ 温度达标后开始搅拌。

PLC 可以用顺序逻辑图（Sequential Function Charts，简称SFC）实现这种控制流程。
这一部分将介绍SFC的语法和应用实例。

---

### 🧠 总结要点

这张幻灯片是PLC章节的**学习大纲**。
它从基础的逻辑控制讲起，逐步深入到PLC硬件、编程语言、基于模型的设计方法，最后讲到复杂的顺序控制系统。
整个内容体系完整，既包括理论，也涵盖实践编程与工业应用。

---

### \[口语化表达]

这页其实是PLC章节的内容目录。它会先讲什么是逻辑控制，也就是用开关信号来让机器动作；接着讲PLC的硬件结构和工作原理；然后介绍几种常用的编程方式，比如功能块图、梯形图和指令表；再往后讲现代的基于模型的设计方法，用模拟模型来帮我们验证控制逻辑；最后是顺序控制，教你怎么让系统一步步自动运行，比如先加料、再加热、再排空。简单说，这页是在告诉我们，这一章就是带你从逻辑基础学到能编程控制整个工业流程。


---

## 第 13 页

![第 13 页](Chapter 3 - Programmable Logic ___lers (slides with annotations)_assets/page-013.png)

这张幻灯片标题为 **“Programmable Logic Controllers (1)”（可编程逻辑控制器 第一部分）**，主要讲的是**实现逻辑控制器（logic controllers）的几种设备平台**。也就是说，在工业自动化中，逻辑控制可以用不同类型的硬件系统来实现。
下面是详细解释 👇

---

### 📘 详细内容解析

#### 🟧 1. Dedicated hardware（专用硬件逻辑控制）

又叫 **“hardwired logic”**，中文通常称为**继电器逻辑控制**或**硬接线控制系统**。

* **特点**：

* 使用物理电路（如继电器、接触器、开关、定时器）直接连接形成逻辑控制；
* 控制逻辑写在**电线连接方式**里，而不是程序中；
* 修改逻辑时必须重新布线，灵活性差。
* **德语**：**Verbindungsprogrammierte Steuerung (VPS)**，意思是“连接式编程控制”。
* **应用场景**：早期的工业自动化系统，比如传统的电气控制柜、简单的生产线控制。

👉 这种控制方式虽然稳定可靠，但已经被现代PLC大部分取代。

---

#### 🟧 2. Programmable Logic Controllers (PLC)（可编程逻辑控制器）

这是工业自动化控制的**核心设备类型**。

* **定义**：PLC是一种基于微处理器的工业控制计算机，用来替代传统的继电器控制。
* **原理**：通过**程序**来实现逻辑判断、顺序控制、计时、计数等功能。
* **德语**：**Speicherprogrammierbare Steuerung (SPS)**，意思是“存储程序控制系统”。
* **优点**：

* 灵活（逻辑修改只需改程序）；
* 稳定可靠（工业级耐干扰设计）；
* 可扩展（可加模块控制更多设备）。
* **应用**：几乎所有现代工业生产线、机械臂、楼宇自动化系统都使用PLC。

---

#### 🟧 3. Distributed Control Systems (DCS)（分布式控制系统）

DCS 是一种**更复杂的控制架构**，通常用于大型工业过程（如化工厂、电厂）。

* 它由多个PLC或控制单元组成，每个部分控制系统的一部分。
* 所有控制单元通过通信网络（如以太网或现场总线）协调工作。
* **德语**：**Prozessleitsysteme (PLS)**，意思是“过程控制系统”。
* **特点**：

* 分布式架构；
* 高度可靠；
* 可同时监控、控制多个子系统。

---

#### 🟧 4. Industrial PCs (IPCs)（工业计算机）

* 是**基于PC架构**的工业控制设备，比PLC性能更强。
* 通常用于需要高计算能力的应用，比如图像处理、数据分析、复杂算法控制。
* 可以运行操作系统（如Windows或Linux），同时控制多个设备。
* 比PLC更“智能”，但抗干扰性略差。

---

#### 🟧 5. Soft-PLCs（软件PLC）

* 是一种**虚拟化的PLC系统**，在普通计算机或工业PC上以软件形式运行。
* 不再依赖专用硬件，而是通过软件模拟PLC功能。
* 常用于实验、仿真或中小型自动化应用。
* 优点：灵活、成本低；
* 缺点：实时性和稳定性不如真正的PLC硬件。

---

### 🧠 总结要点

这页总结了实现逻辑控制器的几种主要平台，从传统到现代依次为：
1️⃣ 硬接线控制（VPS） →
2️⃣ 可编程逻辑控制器（PLC / SPS） →
3️⃣ 分布式控制系统（DCS / PLS） →
4️⃣ 工业PC（IPC） →
5️⃣ 软件PLC（Soft-PLC）

它展示了工业自动化控制系统的发展过程：从电气继电器逻辑到现代的计算机化、分布式和虚拟化控制架构。

---

### \[口语化表达]

这页讲的是实现逻辑控制的几种硬件平台，也可以理解为控制系统的发展历程。最早是用继电器和电线连起来的“硬接线逻辑”，那时候要改逻辑就得重新布线，非常麻烦。后来出现了PLC，用程序来控制设备，灵活又稳定，现在工业上基本都是它。再往后是DCS，也就是大型工厂那种分布式系统，能同时管多个子系统。再后来有工业电脑（IPC），性能更强，还能做复杂任务。最后是Soft-PLC，也就是在电脑上运行的软件版PLC，成本低、调试方便。简单说，这页是从“老式电路”讲到“智能化控制”的一个发展演变。


---

## 第 14 页

![第 14 页](Chapter 3 - Programmable Logic ___lers (slides with annotations)_assets/page-014.png)

这张幻灯片标题为 **“Programmable Logic Controllers (2)”（可编程逻辑控制器 第二部分）**，展示的是一个PLC（可编程逻辑控制器）的**实际实例**，并详细标注了PLC系统的主要组成模块。图中所示的是日立（Hitachi）的 **EH-150 系列PLC**。
这页的目的是帮助学生**了解PLC硬件的结构与模块功能**。

---

### 📘 详细内容解析

#### 1. 什么是PLC？

PLC 是一种**专门用于工业自动化控制的计算机设备**，通过程序逻辑来控制机器、生产线、机器人等。
它由多个模块组成，不同模块负责不同功能，可以根据应用需求自由组合。

---

#### 2. 图中PLC的主要组成模块

图中每个模块都有特定功能，从左到右依次如下：

---

##### 🟪 Power Supply Module（电源模块）

* 负责给整个PLC系统提供稳定的电源（通常是24V DC或220V AC）。
* 是PLC的“能量核心”，没有它系统无法启动。

---

##### 🟩 Base Unit（基座 / 安装底板）

* 提供模块插槽与电气连接接口；
* 所有模块都固定安装在这块基座上；
* 通过内部总线（backplane bus）互相通信。

---

##### 🟦 CPU Module（中央处理单元模块）

* PLC的大脑，负责：

* 执行用户编写的逻辑程序；
* 处理输入信号；
* 控制输出设备；
* 管理通信与诊断信息。
* 通常还带有存储板（Memory Board），用于保存程序和数据。

---

##### 🟨 I/O Controller（输入/输出控制器）

* 管理外部信号的读写；
* **输入（Input）**：接收来自传感器、按钮、开关的信号；
* **输出（Output）**：控制执行机构，如电机、阀门、灯等。
* I/O 控制器通过专用连接线与外围设备通信。

---

##### 🟧 Analog Input / Output Modules（模拟量输入输出模块）

* **Analog Input Module（模拟输入）**：读取连续信号（如温度、压力、电压）。
* **Analog Output Module（模拟输出）**：输出连续信号给执行设备（如变频器、调节阀）。
* 这些模块让PLC能处理连续变量，而不仅仅是开关量。

---

##### 🟨 Communication Module（通信模块）

* 让PLC与其他设备（例如电脑、上位机、其他PLC）通信。
* 支持多种协议（如 Modbus、Ethernet、Profibus 等）。
* 是现代自动化中**网络化控制**的关键部分。

---

##### 🟩 Counter Module / Positioning Module（计数与定位模块）

* 用于处理高速脉冲信号，如：

* 编码器脉冲计数；
* 电机位置控制；
* 流水线速度检测。
* 在运动控制、包装设备中应用广泛。

---

##### 🟦 Dummy Module（占位模块）

* 没有控制功能，只用于占据空槽；
* 保持模块布局整齐，防止灰尘进入未使用的接口。

---

##### ⚙️ Cables for Connecting Peripheral Devices（外设连接电缆）

* 连接外部设备（例如显示器、人机界面HMI、传感器或执行器）。
* 保证PLC与外部世界通信。

---

#### 3. 整体结构逻辑

从左到右，可以看出PLC系统的典型信号流方向：

> 电源模块供电 → CPU处理逻辑 → 各I/O模块与外部设备交互 → 通信模块传输数据。

这是一种**模块化、可扩展的架构**，工程师可以根据实际需要增加或更换模块。

---

### 🧠 总结要点

这张幻灯片展示了一个典型PLC（以日立EH-150为例）的模块组成。
主要包括：

* 电源模块；
* CPU（控制核心）；
* 输入输出模块；
* 模拟量与通信模块；
* 特殊功能模块（计数、定位）；
* 以及结构支撑模块（基座、占位模块）。

它体现了PLC系统的**灵活性与可扩展性**，这也是它能在工业自动化中被广泛使用的原因。

---

### \[口语化表达]

这页展示的是一个真实的PLC设备——日立EH-150系列。可以看到，它由很多模块组成：最左边是电源模块，负责供电；中间是CPU，是整个系统的大脑；后面是各种输入输出模块，用来连接传感器、开关、马达等外部设备；还有模拟量模块可以处理温度、电压这种连续信号；通信模块负责让PLC和电脑或别的PLC联网；甚至还有专门的计数、定位模块。所有模块都插在底座上，形成一个完整的控制系统。简单来说，这页就是告诉我们：PLC就像一台可以自由拼装的工业电脑，每个模块都有专门的用途。


---

## 第 15 页

![第 15 页](Chapter 3 - Programmable Logic ___lers (slides with annotations)_assets/page-015.png)

这张幻灯片标题为 **“Programmable Logic Controllers (3)”（可编程逻辑控制器 第3部分）**，主要展示了**各种类型的PLC（可编程逻辑控制器）实例**，以帮助学生了解现实中PLC设备的外观、结构和多样性。

这页的关键词是 “**Examples（实例）**” 和 “**Typical PLCs（典型PLC）**”。
它展示了工业界常见的不同品牌和型号的PLC设备。

---

### 📘 详细内容解析

#### 1. PLC的多样性

幻灯片中的图片展示了来自不同厂商的**典型PLC控制器**。这些设备虽然外形各异，但基本原理和功能都类似：

* 接收输入信号（来自传感器、按钮等）；
* 执行逻辑控制程序；
* 输出控制信号给设备（如电机、阀门、灯光）。

## PLC的种类大体可以分为三类：

#### 🟦 (1) 大型PLC（Modular PLCs）

图中左上角那一组体积较大的PLC属于**模块化PLC系统**，常用于复杂的大型工业过程控制。

* **特点**：

* 拥有多个插槽，可自由插入不同功能模块（输入输出、通信、模拟信号、运动控制等）；
* 功能强大，适合控制大型生产线或工厂；
* 可以与上位机（SCADA、DCS系统）通信协作。

* **典型品牌**：

* 西门子（Siemens S7 系列）
* 三菱（Mitsubishi Q 系列）
* 罗克韦尔（Allen-Bradley ControlLogix）
* 欧姆龙（Omron CJ/CS 系列）

---

#### 🟩 (2) 中型PLC（Compact PLCs）

位于图片中部的PLC尺寸中等，通常为**集成式结构**，将输入、输出和CPU集成在一个壳体中。

* **特点**：

* 适用于中小型自动化设备（如包装机、传送带、装配线）；
* 模块数量有限，但扩展性仍然较好；
* 成本和复杂度介于大型PLC和微型PLC之间。

* **典型代表**：

* 西门子 S7-1200
* 三菱 FX 系列
* 欧姆龙 CP1 系列

---

#### 🟨 (3) 小型 / 微型PLC（Micro / Nano PLCs）

右下角展示的就是这类PLC，体积最小、价格最低，通常用于简单的自动化任务。

* **特点**：

* 集成度高（电源、CPU、I/O 全部在一个小盒子里）；
* 适合简单逻辑控制，比如门禁系统、自动照明、液位控制；
* 有的甚至带有简单的LCD显示屏和按钮，用于手动设置参数。

* **典型产品**：

* 西门子 LOGO!
* 三菱 Alpha 系列
* 欧姆龙 Zen 系列

---

#### 2. 为什么要展示这些例子？

教授通过这些真实PLC实例，想让学生理解：

* PLC并不是抽象的概念，而是具体的硬件设备；
* 不同型号的PLC适用于不同的控制规模；
* 无论品牌如何，它们都遵循同样的逻辑控制原理，只是在**性能、体积、可扩展性**上不同。

换句话说，从大型工厂到小型机器，都能找到合适的PLC解决方案。

---

### 🧠 总结要点

这张幻灯片展示了工业中常用的不同类型PLC设备：

* **大型模块化PLC** → 适合复杂生产线；
* **中型紧凑式PLC** → 适合中小型设备；
* **小型或微型PLC** → 用于简单控制任务。

所有PLC的核心功能都是一样的：**读取输入 → 执行逻辑 → 输出控制信号。**
区别只是规模和灵活性。

---

### \[口语化表达]

这页展示的是各种真实的PLC设备，让我们看看它们在实际中长什么样。左边是大型的模块化PLC，用在大工厂或生产线，功能强、可以加很多模块；中间的是中型PLC，结构紧凑，常见于包装机、传送带等设备；右边那些小盒子是微型PLC，体积小、价格低，用来控制简单的系统，比如水泵、门禁或照明。虽然大小和品牌不一样，但它们的核心原理都是一样的：接收输入、执行逻辑、输出控制。这页就是让我们认识到PLC在工业里形态多样，但逻辑是一致的。


---

## 第 16 页

![第 16 页](Chapter 3 - Programmable Logic ___lers (slides with annotations)_assets/page-016.png)

这张幻灯片标题为 **“Programmable Logic Controllers (4)”（可编程逻辑控制器 第4部分）**，展示的是两种**小型PLC（Micro PLC）或紧凑型PLC（Compact PLC）** 的实际例子。
这页延续了前几页的“Examples（实例）”主题，展示工业中常见的紧凑型PLC设备，用于简单或中等复杂度的自动化任务。

---

### 📘 详细内容解析

#### 1. 左侧：**Keyence KV 系列小型PLC**

* **品牌**：Keyence（基恩士，日本）
* **类型**：微型PLC，常用于自动化测试设备、传送带控制、装配机等。
* **特点**：

* **体积小巧**，适合嵌入设备内部；
* 前面板带有LED显示屏，可直接查看输入/输出状态、错误信息或运行参数；
* 带有操作按钮（或键盘接口），可直接进行手动控制或程序调试；
* 支持数字I/O，也可扩展模拟量模块；
* 通常通过USB或RS232与电脑相连，用Keyence专用软件编程。

👉 它属于典型的“即插即用型PLC”，安装方便、易于操作，特别适合单机自动化设备。

---

#### 2. 右侧：**Allen-Bradley MicroLogix 系列PLC**

* **品牌**：Allen-Bradley（罗克韦尔自动化，美国）
* **型号示例**：MicroLogix 1200 / 1400 系列
* **类型**：小型可扩展PLC
* **特点**：

* 拥有强大的逻辑控制能力，兼容RSLogix编程环境；
* 集成数字与模拟输入输出接口；
* 内置通信端口（RS232 / Ethernet），可与其他设备联网；
* 带有状态指示灯（POWER、RUN、FAULT、FORCE），方便诊断系统运行状态；
* 设计坚固，适用于工业现场环境。

👉 它比Keyence KV系列更强大，适合需要联网通信、远程监控或小型生产线控制的场景。

---

#### 3. 这两种PLC的共同点

* 都属于 **小型PLC（Micro PLC）**；
* 都是**独立单元结构（Integrated Unit）**，即CPU、电源、I/O接口一体化；
* 都能实现逻辑判断、定时控制、顺序控制、计数等基本功能；
* 都支持PC端编程，也可现场调试；
* 适合用于中小规模控制任务，如包装机、食品设备、温度控制系统、液位监控等。

---

#### 4. 与大型PLC的区别

| 项目 | 小型PLC（如图所示） | 大型PLC        |
| -- | ----------- | ------------ |
| 结构 | 一体化         | 模块化（可插拔扩展）   |
| 功能 | 基本逻辑与通信     | 复杂逻辑、网络、冗余系统 |
| 价格 | 较低          | 较高           |
| 应用 | 单机、小型自动化    | 整厂、生产线、过程控制  |

这张幻灯片重点是让学生认识：**PLC不仅仅是大型工业机柜里的控制器，也有体积小、灵活、适合嵌入设备的小型版本。**

---

### 🧠 总结要点

这页展示了两种典型的小型PLC实例：

* **Keyence KV 系列** → 轻便、直观、适合单机控制；
* **Allen-Bradley MicroLogix 系列** → 功能更强、支持联网、工业级稳定性高。

它们都体现了PLC技术的小型化和智能化发展趋势，让控制设备更容易集成到现代自动化系统中。

---

### \[口语化表达]

这页展示了两款小型PLC的例子。左边的是日本Keyence的KV系列，它体积小、带显示屏，操作简单，常用于一些小型自动化设备，比如包装机或传送带控制；右边的是美国Allen-Bradley的MicroLogix系列，它性能更强，带通信接口和指示灯，可以联网控制，适合小型生产线或独立控制系统。两者的共同点是都把电源、CPU和输入输出接口整合在一起，占空间小、成本低，但依然能实现完整的逻辑控制功能。简单说，这页就是告诉我们：PLC不一定都是又大又复杂的系统，这种小型PLC也能高效地控制很多实际设备。


---

## 第 17 页

![第 17 页](Chapter 3 - Programmable Logic ___lers (slides with annotations)_assets/page-017.png)

这张幻灯片标题为 **“Programmable Logic Controllers (5)”（可编程逻辑控制器 第5部分）**，继续展示PLC（可编程逻辑控制器）的**实际应用实例**，尤其是**模块化结构与可扩展设计**的PLC设备。
这些图片展示了现代工业中常见的PLC外观与结构，强调其灵活性与网络通信能力。

---

### 📘 详细内容解析

#### 1. 上方图片：Eaton（伊顿）模块化PLC系统

* **品牌**：Eaton（伊顿，来自美国的工业自动化和电气系统制造商）。

* **结构特点**：

* **模块化设计（Modular Design）**：每个功能单元（I/O模块、通信模块、CPU模块等）都是独立的，可以根据应用需求灵活组合。
* **可扩展性强（Expandable）**：用户可像积木一样增加新的模块来扩展输入/输出数量或通信功能。
* **易于维护**：出现故障时，只需更换某一个模块，不影响其他部分。

* **图中展示**：
右侧手中正在安装的模块就是一个典型的“扩展I/O模块”，用于增加系统的输入输出端口。
各模块之间通过总线连接（Backplane Bus），实现高速数据通信。

👉 **应用场景**：
这类PLC常用于生产线、装配设备、自动仓储、能源管理等场景。
它适合需要**灵活配置和长期维护**的工业系统。

---

#### 2. 下方图片：带通信接口的智能PLC系统

* 这组设备展示了支持**现代工业通信协议**的PLC，例如：

* **Fieldbus（现场总线）**
* **Ethernet（以太网）**
* **Serial Interface（串行接口）**

* **功能特点**：

* 支持与上位机（如SCADA系统、工业PC）通讯，实现远程监控与数据采集；
* 兼容多种工业通信标准，可在不同设备之间协同工作；
* 常用于智能制造、自动化工厂和物联网系统中。

👉 它代表了PLC技术从“单机控制”发展到“网络化、信息化控制”的趋势。

---

#### 3. 技术关键点总结

这些PLC的设计体现出现代自动化系统的几个核心特点：

* **模块化（Modularity）**：方便扩展、安装和维修；
* **通信能力（Connectivity）**：支持以太网、现场总线，实现设备互联；
* **可集成性（Integration）**：能与传感器、执行器、监控系统无缝衔接；
* **智能化（Smart Control）**：可处理更复杂的逻辑、数据运算与远程管理任务。

这些特性使PLC不再只是“设备控制器”，而是整个工厂自动化网络中的关键节点。

---

### 🧠 总结要点

这张幻灯片展示了**现代模块化PLC的结构与通信特性**。
上图的Eaton系统展示了可自由扩展的模块式设计，而下图的PLC展示了支持多种通信接口（以太网、现场总线、串口）的智能化控制系统。
这表明现代PLC不仅能独立运行，还能作为网络中“可互联、可扩展”的控制核心。

---

### \[口语化表达]

这页展示的是现代模块化PLC的实际样子。上面那张图是伊顿（Eaton）的PLC系统，可以看到它由很多模块拼在一起，每个模块都有不同功能，比如输入输出、通信、或逻辑处理。它就像积木一样，想加新功能就插个新模块，非常灵活。下面那张图展示的是带有通信功能的PLC，它能通过以太网或现场总线和其他设备联网，实现远程控制和数据采集。总体来说，这页告诉我们，现在的PLC不只是一个单独控制机器的盒子，而是整个工业网络中的“大脑节点”，能扩展、能联网，还能智能管理工厂。


---

## 第 18 页

![第 18 页](Chapter 3 - Programmable Logic ___lers (slides with annotations)_assets/page-018.png)

这张幻灯片标题为 **“Programmable Logic Controllers (6)”（可编程逻辑控制器 第6部分）**，展示了德国西门子（**Siemens**）公司出品的几代经典PLC系统实例。
这些图片展示了西门子PLC的**发展历程与系列区别**，主要包括：**SIMATIC S5、S7-300 和 S7-200 系列**。这些型号是全球工业自动化中最常见、应用最广的PLC系统。

---

### 📘 详细内容解析

#### 🟩 1. 左图：**SIMATIC S5 系列（早期PLC）**

* **制造商**：Siemens（西门子）
* **型号**：SIMATIC S5
* **特点**：

* 属于20世纪80年代至90年代的**早期PLC系列**；
* 模块化设计，包含多个插槽（CPU模块、I/O模块、通信模块）；
* 编程使用专用语言（STEP 5），通过PG编程设备或RS-232接口实现；
* 当时广泛用于工厂控制、机床自动化、楼宇控制等；
* 如今已被S7系列取代，但在一些老旧工厂中仍可见到。

**结构说明：**

* 左侧竖条为**电源与CPU模块**；
* 中间部分是输入/输出模块（带接线端子）；
* 红色模块是安全锁定或警示部件；
* 整个系统通过机架总线（Backplane Bus）实现模块通信。

> ✅ **总结**：S5代表PLC的早期时代，是工业自动化的奠基型号。

---

#### 🟦 2. 右上图：**SIMATIC S7-300 系列**

* **制造商**：Siemens
* **系列定位**：中高端模块化PLC
* **特点**：

* 替代S5的后续型号，使用**STEP 7**软件编程；
* 模块化结构，支持多种通信协议（如Profibus、Ethernet）；
* 性能高、稳定性强，适用于大型自动化生产线；
* 支持冗余、远程I/O、过程控制等高级功能。
* **模块组成**：CPU模块、数字I/O模块、模拟I/O模块、通信模块等。

**应用领域**：
汽车制造、化工厂、发电厂、食品加工、物流自动化等。

> ✅ **总结**：S7-300 是工业控制系统的主力型号，被称为“工业控制标准机”。

---

#### 🟨 3. 右下图：**SIMATIC S7-200 系列**

* **制造商**：Siemens
* **系列定位**：小型、经济型PLC
* **特点**：

* 一体化设计（CPU、电源、I/O集成在一个机体中）；
* 使用**STEP 7 Micro/WIN**软件编程；
* 简单易用，安装方便，成本低；
* 适合中小型机械设备、自动门、液位控制、包装机等应用；
* 可通过RS485、Modbus通信与其他设备连接。

> ✅ **总结**：S7-200 以小巧灵活著称，是教育、培训和小型项目的常见选择。

---

#### 🧩 4. Siemens PLC系列的发展脉络

| 年代          | 系列名称                               | 特点            | 状态    |
| ----------- | ---------------------------------- | ------------- | ----- |
| 1980s–1990s | SIMATIC S5                         | 早期PLC，模块化设计   | 已淘汰   |
| 1990s–2010s | SIMATIC S7-300 / S7-400            | 主流工业级PLC      | 仍广泛使用 |
| 2000s–现在    | SIMATIC S7-200 / S7-1200 / S7-1500 | 小型 / 新一代智能PLC | 主推产品  |

👉 可以看到，PLC技术随着时间演进，不断在性能、通信、编程便利性等方面提升。

---

### 🧠 总结要点

这页幻灯片展示了西门子PLC的三个经典代表：
1️⃣ **S5** → 早期PLC系统（已停产）；
2️⃣ **S7-300** → 模块化高性能控制系统，工业标准；
3️⃣ **S7-200** → 紧凑型、小型化控制器，性价比高。

它们展示了PLC技术从“基础逻辑控制”到“智能化联网控制”的发展方向，西门子SIMATIC系列几乎定义了现代工业PLC的标准。

---

### \[口语化表达]

这页展示的是西门子PLC的不同系列，也就是PLC的发展历程。最左边的是早期的S5系列，它结构复杂、用老式编程设备，但在八九十年代非常经典。右上是S7-300系列，现在工厂里常见的中大型PLC，功能强、模块多，能控制整条生产线。右下是S7-200系列，体积小、价格低，适合单台设备或教学实验用。简单说，这页就是在告诉我们，PLC从S5到S7一路进化，西门子从早期的老机型一路发展到现代智能控制系统，几乎成了工业自动化的代名词。


---

## 第 19 页

![第 19 页](Chapter 3 - Programmable Logic ___lers (slides with annotations)_assets/page-019.png)

这张幻灯片标题为 **“Programmable Logic Controllers (7)”（可编程逻辑控制器 第7部分）**，展示了一个**PLC在实际工业环境中的使用场景**。
画面中的技术人员正在使用笔记本电脑连接并调试PLC控制柜，说明PLC不仅是理论上的自动化控制设备，更是**实际工业系统中需要配置、编程、测试与维护的核心控制单元**。

---

### 📘 详细内容解析

#### 🟩 1. 图片场景说明

这张照片拍摄于一个\*\*工业控制柜（control cabinet）\*\*内部：

* **控制柜上部**：安装了一排蓝色模块，这些是 **PLC模块**（极有可能是西门子 SIMATIC S7 系列）。

* 每个模块都负责特定功能，如输入采集（传感器信号）、输出控制（继电器、电磁阀）、通信或处理逻辑等。
* 模块间通过内部总线连接。

* **控制柜下部**：有电源单元、断路器、继电器等辅助元件；

* 电源模块为PLC及外设提供稳定电压；
* 继电器实现PLC输出与高功率设备之间的电气隔离。

* **笔记本电脑**：工程师通过\*\*编程电缆（通常是RS232、USB或以太网）\*\*连接到PLC的CPU模块上；

* 运行的是PLC编程软件（如Siemens STEP 7或TIA Portal）；
* 用于下载控制程序、实时监控运行状态、查看输入输出信号或调试逻辑功能。

> ✅ 这个场景展示了**PLC系统的调试与维护过程**，是工业自动化工程师的日常工作之一。

---

#### 🟦 2. 工程师正在做的事情

根据画面推断，这位工程师可能在进行以下任务之一：

1. **程序下载（Program Download）**：
将在电脑中编写好的控制逻辑程序传输到PLC内部存储器。

2. **在线监控（Online Monitoring）**：
实时查看PLC输入/输出状态或变量值，以检测控制逻辑是否正常工作。

3. **系统调试（Commissioning）**：
在新设备安装后测试整个系统功能，比如启动顺序、传感器反馈、紧急停机功能等。

4. **故障诊断（Troubleshooting）**：
如果设备出现问题，工程师可以通过软件读取PLC的错误信息（Fault Codes），快速定位故障模块或信号异常点。

---

#### 🟨 3. 这页的教学重点

教授通过这张图片，意在让学生理解：

* PLC不是抽象的编程概念，而是与**真实设备**（如马达、传感器、执行器）相连的**工业控制核心**；
* 学会PLC编程只是第一步，更重要的是能在**现场调试和维护**中正确使用；
* 自动化工程师的工作不仅包括写程序，还要：

* 设计系统逻辑；
* 接线调试；
* 检查输入输出；
* 与生产设备协调运作。

换句话说，**PLC是嵌入式系统在工业世界的真实体现。**

---

### 🧠 总结要点

这页幻灯片展示了PLC在现实工业环境中的应用：

* 控制柜中安装了PLC模块、供电单元和外围设备；
* 工程师通过电脑与PLC通信，进行程序调试或监控；
* 展现了PLC在自动化系统中作为“大脑”的实际工作状态；
* 说明PLC工程的核心不仅是编程，更是设备调试与系统集成。

---

### \[口语化表达]

这页展示的是PLC在实际工厂里怎么用的。画面里工程师正拿着笔记本连接到控制柜里的PLC，通过软件来调试或监控系统。上面一排蓝色模块就是PLC的不同单元，有的负责输入信号、有的控制输出。电脑上可能在运行西门子的STEP 7软件，用来下载程序或查看实时数据。这种场景在工厂很常见，说明PLC不是纸上谈兵的概念，而是真实控制着机器的“大脑”。工程师不仅要会写逻辑程序，还要在现场测试、排错、优化，让整个自动化系统稳定运行。


---

## 第 20 页

![第 20 页](Chapter 3 - Programmable Logic ___lers (slides with annotations)_assets/page-020.png)

这张幻灯片标题为 **“Programmable Logic Controllers (8)”（可编程逻辑控制器 第8部分）**，主要介绍的是**工业自动化的金字塔模型（Pyramid model of industrial automation）**。
它解释了**PLC在整个自动化系统中的位置与作用**，以及不同控制层级之间的功能分工。
这是理解自动化系统架构的核心内容之一。

---

## 📘 详细内容解析

### 🏗️ 1. 工业自动化金字塔模型概念

所谓“工业自动化金字塔模型”，是对工厂自动化系统的层级结构的一种抽象表示。
它反映了从\*\*底层物理设备（传感器、执行器）**到**上层生产管理（MES/ERP系统）\*\*的控制与信息流动。
这张图展示了其中的三个主要层次：

---

### 🟩 (1) **Process（过程层）**

这是最底层，直接与物理世界交互。

* **包含内容**：

* 实际被控制的对象，如：电机、阀门、泵、加热器、传感器等。
* **主要作用**：

* 进行具体的**物理过程**（比如加热、搅拌、输送、灌装等）。
* 提供实时数据（温度、压力、速度等）给上层系统。

👉 它是整个自动化系统的“现实基础”。

---

### 🟨 (2) **Field Layer（现场层）**

这是连接过程设备与控制系统的中间层。

* **功能**：

* **信号采集（sensing）**：读取传感器数据；
* **执行操作（actuating）**：通过继电器、驱动器控制设备动作；
* **本地操作（local manual operation）**：现场人员可手动干预；
* **本地显示（local display）**：显示实时状态。

👉 这一层的设备包括传感器、执行器、信号转换器、HMI面板等。
它把真实世界的信号转换为PLC可以理解的电信号。

---

### 🟦 (3) **Process Control Layer（过程控制层）**

这是PLC所在的核心层，主要负责**逻辑与控制任务**。
图中标出了两个部分：

* **process station（PLC）** → 执行控制逻辑（如顺序控制、报警、安全联锁）；
* **operator station（PC, WS）** → 操作与监控工作站，用于显示系统状态、设定参数。

**功能划分：**

* **Basic Functions（基础功能）**：

* Basic continuous control（基础连续控制）
* Sequence control（顺序控制）
* Threshold supervision（阈值监控）
* Safety trips（安全停机保护）
* Interlocks（互锁保护逻辑）

* **Higher Functions（高级功能）**：

* Advanced continuous control（高级连续控制）
* Recipe control（配方控制，用于食品或化工）
* Alarm handling / registration（报警处理与记录）
* Visualization（可视化显示）
* Displaying / operating（人机交互操作）

👉 这层相当于“控制大脑”，PLC在这里实现自动化逻辑，PC负责监控与管理。

---

### 🟧 (4) **Production Control Layer（生产控制层）**

位于最上层，负责**生产管理和优化**。

* **主要任务**：

* 调度生产计划；
* 管理物料与能耗；
* 分析产量与效率；
* 进行全局决策（与MES/ERP系统衔接）。

👉 它不直接控制机器，而是基于数据做管理决策。
它代表了**信息流的上层逻辑控制**。

---

## 🔁 各层之间的关系

| 层级                 | 信息流方向           | 控制流方向     | 主要设备          |
| ------------------ | --------------- | --------- | ------------- |
| Production Control | 从下层采集数据、上行至管理系统 | 向下发布生产指令  | 服务器、数据库、MES系统 |
| Process Control    | 上下双向交互，负责逻辑运算   | 控制设备动作    | PLC、PC工作站     |
| Field              | 从过程层采集信号        | 执行命令、反馈状态 | 传感器、执行器       |
| Process            | 提供真实物理响应        | 被动执行控制指令  | 电机、泵、阀门等      |

简而言之：

* **数据向上流动**（监控信息）；
* **控制命令向下传递**（执行动作）。

---

## 🧠 总结要点

这张图展示了工业自动化的分层结构，也说明了**PLC在整个系统中的位置**：

* PLC处于“过程控制层（Process Control Layer）”，
* 它连接上层的操作站（PC）和下层的传感器/执行器，
* 执行逻辑控制、顺序控制、安全联锁等任务。

整个金字塔模型体现了自动化系统的**分层管理、分层控制**理念，从物理过程到底层设备、再到上层监控与决策，形成完整的自动化生态。

---

## \[口语化表达]

这页讲的是工业自动化的金字塔结构，也就是整个控制系统是怎么分层的。最底层是实际的设备，比如电机、阀门、传感器，这些执行真正的物理动作。往上一层是现场层，用来采集信号、驱动设备，也能让工人现场手动操作。再往上是过程控制层，这就是PLC的工作区域，它是整个系统的大脑，负责逻辑控制、顺序控制、报警、安全保护等等。PLC之上还有生产控制层，它不直接控制机器，而是管理生产计划、能耗、数据分析等。简单来说，就是底层干活，中层管动作，上层做决策，而PLC正是连接“实际机器”和“控制电脑”的关键核心。


---

## 第 21 页

![第 21 页](Chapter 3 - Programmable Logic ___lers (slides with annotations)_assets/page-021.png)

这张幻灯片标题为 **“Programmable Logic Controllers (9)”（可编程逻辑控制器 第9部分）**，主要介绍的是 **PLC的体系结构（PLC architecture）**。
它展示了PLC内部的工作原理、数据流动方式，以及PLC如何与外部传感器（Sensors）和执行器（Actuators）交互。
这是理解PLC“如何运行”的核心知识点之一。

---

## 📘 详细内容解析

### 🧩 1. 整体结构概览

幻灯片中灰色区域是一个典型的PLC结构示意图，左边是**编程设备（Programming Device）**，右边是**工业现场的过程与监控系统（Process and Monitor）**。
整个数据流从传感器信号进入PLC，经处理后输出控制信号到执行设备。

---

### 🟦 2. 左侧：Programming Device（编程设备）

* 工程师通过笔记本电脑或专用编程器将逻辑程序写入PLC。
* 程序被存入PLC的\*\*Program Memory（程序存储器）\*\*中。
* 典型软件包括 Siemens STEP 7、TIA Portal、GX Developer 等。

➡️ **作用**：是PLC的“程序输入端”，相当于告诉PLC要执行什么逻辑。

---

### 🟨 3. PLC内部结构（核心部分）

PLC内部可以分为几个主要模块：

#### (1) **Program Memory（程序存储器）**

* 存储用户编写的逻辑程序；
* 程序通常是循环执行（scan cycle），不断读取输入、计算逻辑、输出控制。

---

#### (2) **CPU（中央处理单元）**

* 是PLC的大脑；
* 按顺序执行存储在程序存储器中的指令；
* 从输入模块读取数据（Input Memory），计算逻辑，再写入输出模块（Output Memory）。

➡️ **主要职责**：

* 逻辑运算；
* 定时、计数；
* 数据比较；
* 通信管理；
* 错误检测。

---

#### (3) **Internal Data Memory（内部数据存储器）**

* 存放临时变量、内部寄存器状态、中间计算结果；
* 在程序运行时动态更新。

---

#### (4) **Input Interface & Input Memory（输入接口与输入映像区）**

* **Input Interface**：接收来自传感器的电信号，如开关量（on/off）或模拟量（温度、电压等）。
* **Input Memory（PAE，Prozessabbild der Eingänge）**：

* 德语意为“输入的过程映像”；
* 它存储当前所有输入信号的状态，供CPU读取。

💡 相当于一个“输入缓存区”：CPU不会直接访问物理传感器，而是从这里获取最新信号。

---

#### (5) **Output Interface & Output Memory（输出接口与输出映像区）**

* **Output Memory（PAA，Prozessabbild der Ausgänge）**：

* 德语意为“输出的过程映像”；
* 存储CPU计算后要输出的结果值。
* **Output Interface**：

* 将这些结果转化为电信号发送给执行器（Actuators），如马达、阀门、灯等。

💡 可以理解为“输出缓存区”，CPU把结果放进去，然后物理模块执行输出动作。

---

#### (6) **Register（寄存器）**

* 用于存储临时数据、计数器、定时器的当前值等；
* 在PLC内部运行期间起辅助作用。

---

#### (7) **Network Interface（网络接口）**

* 让PLC与其他设备通信（如其他PLC、DCS系统或上位机PC）；
* 通过以太网、Profibus、Modbus等协议交换数据。

---

### 🟥 4. 右侧：Process and Monitor（过程与监控系统）

包括两类设备：

* **Sensors（传感器）**：测量物理量（温度、压力、液位、速度等），把信号送入PLC的输入接口。
* **Actuators（执行器）**：根据PLC的输出信号执行动作（开阀、启泵、驱动马达等）。

整个过程形成一个闭环：

> 传感器 → 输入接口 → CPU处理 → 输出接口 → 执行器。

---

### 🔁 5. PLC的运行循环（Scan Cycle）

PLC在运行时不断重复以下三个步骤：
1️⃣ 读取输入（更新PAE）；
2️⃣ 执行逻辑程序（CPU处理）；
3️⃣ 输出结果（更新PAA）。

整个循环在毫秒级内完成，因此系统可以实时响应变化。

---

### 🧠 总结要点

* PLC通过“输入映像区（PAE）”和“输出映像区（PAA）”与现实设备交互；
* CPU负责执行逻辑计算，是PLC的核心控制单元；
* 编程设备用来下载和修改程序；
* 内部存储区与寄存器用于存放中间数据；
* 网络接口实现PLC之间或与上位机的通信；
* 整个系统遵循“采集 → 处理 → 输出”的循环机制。

这就是PLC的基本硬件结构与信号流转逻辑。

---

## \[口语化表达]

这页讲的是PLC的内部结构，也就是它是怎么“思考”和“行动”的。左边是工程师用来写程序的电脑，程序被存进PLC的程序存储器里。中间是PLC的核心部分：CPU负责执行逻辑运算，输入模块负责接收传感器信号，输出模块负责控制执行器动作。输入信号会先被放进一个输入映像区（PAE），CPU从这里读取状态进行计算，然后把结果放进输出映像区（PAA），再通过输出接口让设备动作。整个过程是一个不断循环的流程：读取→计算→输出。右边的部分就是现实世界的传感器和执行器，它们把实际的状态传给PLC，再由PLC做出控制决策。简单说，这页就是在告诉我们，PLC就像一个小型计算机，它不断地接收外部信号、处理逻辑、输出命令，实现自动化控制的闭环。


---

## 第 22 页

![第 22 页](Chapter 3 - Programmable Logic ___lers (slides with annotations)_assets/page-022.png)

这张幻灯片标题为 **“Programmable Logic Controllers (10)”（可编程逻辑控制器 第10部分）**，主题是 **“PLC operating system: Cyclic Scanning Mode”**（PLC 操作系统：循环扫描模式）。
虽然幻灯片内容还没有展开，但标题已经点明了PLC运行的核心机制 —— **循环扫描（Cyclic Scanning）**。
这是PLC执行控制程序最基本、最典型的运行方式，几乎所有工业PLC系统都采用这种机制。

---

## 📘 详细解释

### 🧩 1. 什么是循环扫描模式（Cyclic Scanning Mode）

循环扫描模式是PLC的**工作逻辑结构**，它决定了PLC如何周期性地执行程序。
PLC并不像电脑那样同时处理多个任务，而是按照**固定的顺序循环**执行以下步骤：

1️⃣ **读取输入（Input Scan）**

* 从输入模块采集所有传感器、开关、按钮等输入信号；
* 并将这些信号的状态存储到输入映像区（PAE, Prozessabbild der Eingänge）；
* 这样CPU就有了“当前现场状态”的快照。

2️⃣ **执行程序（Program Execution）**

* CPU读取输入映像区的状态，执行用户编写的逻辑程序（如梯形图、功能块图等）；
* 在内部数据区中进行逻辑判断、计数、定时、数学计算等操作；
* 计算结果暂存在输出映像区（PAA, Prozessabbild der Ausgänge），并不会立刻作用到真实输出端口。

3️⃣ **更新输出（Output Scan）**

* CPU把输出映像区中的结果送到输出模块；
* 输出模块再驱动执行器（电机、阀门、灯等），实现控制动作。

4️⃣ **内部诊断与通信（Housekeeping & Communication）**

* 在每个循环的最后，PLC会进行系统自检、通信处理、错误记录等后台任务。

👉 整个过程形成一个完整的循环，称为 **Scan Cycle（扫描周期）**。
PLC从输入读取 → 程序计算 → 输出更新 → 系统维护，然后立即回到第一步，如此反复执行。

---

### 🔁 2. 循环扫描的特征

* **周期性（Cyclic）**：
每个扫描周期都严格按照相同顺序重复执行。

* **实时性（Real-time）**：
扫描周期通常在几毫秒到几十毫秒之间（例如10ms\~100ms），保证控制响应迅速。

* **确定性（Deterministic）**：
每次循环的执行顺序、逻辑运算、输出刷新都是固定的，使系统可预测、可靠。

* **延迟性（Response Delay）**：
由于PLC只有在下一次扫描时才更新输出，所以系统响应存在最多一个扫描周期的延迟。

---

### ⚙️ 3. 为什么PLC采用循环扫描

* 工业控制系统需要**稳定、可重复**的运行模式；
* 循环结构便于**周期性监控传感器状态**和**定时执行逻辑**；
* 可以确保每个输入都被处理，每个输出都被刷新；
* 工程师编程时可清晰预测系统的行为。

---

### 🧠 4. 示例说明

以“液位控制系统”为例：

1️⃣ 传感器检测水位（输入信号）；
2️⃣ PLC读取信号并执行逻辑：

* 如果液位过低 → 打开进水阀；
* 如果液位过高 → 关闭阀门；
3️⃣ 输出模块执行动作控制阀门；
4️⃣ PLC循环往复执行该过程，实时保持水位在安全范围内。

每次扫描就像PLC“眨一次眼”，看到环境、判断逻辑、做出反应。

---

### 💡 5. 总结关键词

| 概念                | 含义             |
| ----------------- | -------------- |
| Scan Cycle（扫描周期）  | PLC执行一次完整循环的时间 |
| Input Scan        | 读取输入信号         |
| Program Execution | 执行逻辑程序         |
| Output Update     | 更新输出信号         |
| Determinism       | 程序执行顺序固定，可预测   |
| Response Delay    | 响应延迟不超过一个扫描周期  |

---

## 🧩 总结要点

* **Cyclic Scanning Mode** 是PLC运行的基本模式；
* 每个周期包括输入采集、程序运算、输出更新；
* 该过程不断循环，使PLC能够实时监控和控制工业过程；
* 扫描时间越短，系统响应越快；
* 稳定、可预测、易维护是它的最大优势。

---

## \[口语化表达]

这页讲的是PLC的工作方式——循环扫描模式。PLC其实就是不停地在“做三件事”：先读取所有传感器的信号，然后根据程序做逻辑计算，最后把结果输出给设备去执行，比如开关电机或阀门。做完这一圈，它马上又从头开始，形成一个不断循环的过程。每次循环叫一个“扫描周期”，通常只有几毫秒。这个机制保证了PLC能实时响应变化，比如一旦传感器检测到液位过高，PLC在下一个循环就会立刻发出关闭阀门的指令。简单说，PLC就是在不停地“看→想→做”，一圈一圈地重复，用这种循环方式保持整个自动化系统稳定运行。


---

## 第 23 页

![第 23 页](Chapter 3 - Programmable Logic ___lers (slides with annotations)_assets/page-023.png)

这张幻灯片标题为 **“Programmable Logic Controllers (10)”（可编程逻辑控制器 第10部分）**，主题仍然是 **“PLC operating system: Cyclic Scanning Mode”**（PLC操作系统：循环扫描模式），不过这次图示清晰地说明了**PLC循环扫描（scan cycle）内部的各个阶段**，以及它是如何在每一轮循环中完成读取、计算与输出的。

---

## 📘 详细内容解析

### 🧩 1. 什么是“循环扫描周期”（Cycle）

PLC的运行模式是**周期性循环执行任务**，一次完整的循环称为一个**Cycle（周期）**。
每个周期中，PLC依次执行四个主要步骤：

---

### 🟨 **① 读取输入（Read Input / Buffer Values）**

* 这是PLC周期的起点。
* PLC从\*\*输入模块（Input Interface）\*\*采集外部传感器信号，比如温度、液位、开关状态等。
* 采集到的输入值会被暂时存放到输入缓冲区（Input Buffer 或 Process Image of Inputs, PAE）。
* 这样做的好处是CPU能在程序执行时读取“快照数据”，而不会被实时信号波动干扰。

👉 图中用 **黄色部分** 表示，标注为 **“read input (buffer values)”**。

---

### 🟦 **② 程序执行（Program Execution / Buffer Output）**

* 这是PLC的核心阶段。
* CPU根据存储在程序存储器（Program Memory）中的逻辑程序，
使用输入缓冲区的数据进行逻辑运算、判断、计数、定时或数学计算。
* 程序运行的结果会暂时存放到**输出缓冲区（Output Buffer 或 Process Image of Outputs, PAA）**，
但此时还不会立即作用到外部设备。

👉 图中蓝色的环形区域代表这一阶段，是PLC运行时间最长的部分。
也就是说，大部分时间PLC都在执行程序逻辑。

---

### 🟩 **③ 写入输出（Write Output）**

* 程序执行完成后，PLC将输出缓冲区中的结果写入**输出模块（Output Interface）**；
* 输出模块把逻辑结果转换成电信号，驱动\*\*执行器（Actuators）\*\*动作；
例如打开阀门、启动电机、点亮指示灯等。

👉 图中用 **绿色部分** 表示，标注为 **“write output”**。

---

### 🟥 **④ 内部检查（Internal Checks）**

* 每个循环结束前，PLC会进行一些系统级的维护和自检任务：

* 检查通信状态；
* 执行错误诊断与报警（例如模块失联、I/O故障）；
* 更新计时器与中间寄存器；
* 处理中断请求（如果有）。

👉 图中红色部分标注为 **“internal checks”**。
这部分虽然时间短，却是保证PLC系统稳定、可靠运行的关键。

---

### 🔁 **⑤ 完整循环（One Turn Around = Cycle）**

图下方文字说明了：

> **One turn around = cycle (≈ ms)**
> 也就是“一次完整的循环扫描约需几毫秒”。

这意味着PLC每隔几毫秒就会重新读取输入、运行程序、输出结果、再检查系统——
整个系统在不停地重复这一系列操作。

周期时间的长短取决于：

* 程序复杂度；
* CPU处理速度；
* I/O数量；
* 通信任务多少。

通常扫描周期在 **5ms – 50ms** 之间。
越短的周期意味着响应越快，但CPU负载也更高。

---

## 🧠 总结要点

* PLC以**循环扫描模式**工作，每个循环称为一个“Cycle”；
* 循环包括四个阶段：
1️⃣ 读取输入信号；
2️⃣ 执行逻辑程序；
3️⃣ 写入输出信号；
4️⃣ 进行内部检查；
* 这一过程不断重复，形成PLC的实时控制闭环；
* 每次循环只需几毫秒，因此PLC能对现场变化迅速响应。

---

## \[口语化表达]

这页图解释了PLC是怎么一圈一圈运行的。每一轮叫一个“扫描周期”，一般只需要几毫秒。PLC先从传感器那边把输入信号读进来（黄色那块），然后在蓝色阶段执行程序逻辑，比如判断温度高不高、该不该开阀门。接着是绿色部分，把计算结果写到输出端，让设备动作，比如电机启动。最后是红色那段，PLC会自检一下系统，比如通信、故障、计时器等。做完这一整圈后它又马上回到开头，再次读取输入、计算、输出，这个循环会一直持续。简单说，PLC就像一台“思考机器”，每几毫秒看一遍世界、想一遍逻辑、做一遍动作，永不停歇地让自动化系统运转下去。


---

## 第 24 页

![第 24 页](Chapter 3 - Programmable Logic ___lers (slides with annotations)_assets/page-024.png)

这张幻灯片标题为 **“Programmable Logic Controllers (11)”（可编程逻辑控制器 第11部分）**，内容主题是：
**“Execution of cyclic scans in the PLC architecture”** —— 即“在PLC体系结构中执行循环扫描的过程”。

它形象地说明了PLC如何按照“循环扫描模式（Cyclic Scanning Mode）”在内部完成一次完整的扫描周期：
从输入采集 → 程序执行 → 输出更新，再回到输入采集，形成一个连续的闭环控制流程。

---

## 📘 详细内容解释

### 🧩 1. 整体结构

左边灰框是PLC的内部结构，右边灰框是外部的**工业过程（process and monitor）**，例如传感器、执行器、机械系统等。
PLC的任务就是不断地和这些外部设备交换信息，以控制整个过程。

从右向左看，就是外界信号进入PLC（输入），经过程序逻辑处理后，再输出控制信号给外部设备。

---

### 🟨 2. 输入部分（Input Interface & Input Memory）

#### (1) **Input Interface（输入接口）**

* 接收来自外部\*\*传感器（sensors）\*\*的信号；
* 信号类型可能是数字量（on/off）或模拟量（温度、电压、流量等）；
* 将这些物理信号转换为PLC能识别的电信号格式。

#### (2) **Read Input（读取输入）**

* PLC的CPU从输入接口读取当前传感器状态；
* 并把这些数据复制到“输入映像区（Input Memory）”中；
* 这样做相当于给CPU提供一个输入信号的快照。

👉 输入映像区就是临时存储所有输入信号状态的缓冲区。

---

### 🟩 3. 程序执行阶段（Execute Program）

* 这是PLC循环扫描的核心部分。
* CPU读取“输入映像区”的数据，执行用户编写的逻辑程序。
* 程序运行中可能会用到：

* **内部数据存储区（Internal Data Memory）** —— 存放中间变量、计数器、定时器；
* **程序逻辑** —— 如条件判断（IF）、逻辑运算（AND/OR）、数学计算、比较指令等。
* 程序执行的结果不会立即影响实际设备，而是先存入输出映像区（Output Memory）。

💡 这保证了程序执行的稳定性——所有逻辑运算都基于“同一时刻”的输入状态。

---

### 🟦 4. 输出阶段（Write Output）

#### (1) **Output Memory（输出映像区）**

* 存储程序计算结果，例如“阀门=开”、“电机=启动”、“报警灯=关”等；
* 等程序执行完毕后，CPU将这些结果写入输出接口。

#### (2) **Output Interface（输出接口）**

* 把PLC输出信号转换为实际电信号；
* 驱动外部\*\*执行器（actuators）\*\*动作，比如电磁阀、马达、继电器等。

💡 在下一轮扫描开始前，PLC已经完成了对整个系统的控制动作。

---

### 🟥 5. 内部数据交换与循环关系

* 整个过程是**连续循环**的；
* 每次循环执行顺序为：
1️⃣ 读取输入 →
2️⃣ 执行程序 →
3️⃣ 写入输出；
* 然后PLC立即进入下一次扫描。

这就形成了**实时控制循环（real-time control loop）**：

> 外部状态 → 输入采集 → 程序计算 → 输出执行 → 外部状态变化

如此反复，PLC便能持续地对系统进行实时监控与自动控制。

---

### 🔁 6. 补充：循环扫描的时间特性

* 每次完整扫描称为 **“一个循环周期（scan cycle）”**；
* 时间通常在几毫秒级（例如5ms～50ms）；
* 越短的扫描周期意味着PLC响应越快，但CPU负载越高；
* PLC会持续不断地执行这样的循环，因此它能够迅速应对输入信号的变化。

---

## 🧠 总结要点

* **这张图展示的是PLC的循环扫描工作机制在体系结构中的具体实现。**
* 一次循环扫描包括：

* 从**输入接口**读取信号并更新到输入内存；
* CPU根据输入执行逻辑程序；
* 计算结果写入输出内存，再通过**输出接口**控制执行器；
* 该过程不断重复，形成PLC实时控制的闭环系统。

---

## \[口语化表达]

这页讲的是PLC内部在“循环扫描”模式下是怎么实际运作的。右边是外部的传感器和执行器，它们把信号送进PLC，PLC处理完再控制它们。整个过程分三步：第一步，PLC先从输入接口读取传感器的数据，比如温度、液位、按钮状态等，然后把这些值存到输入存储区；第二步，PLC的CPU开始执行程序，根据这些输入做逻辑判断或计算；第三步，PLC把运算结果写进输出存储区，然后通过输出接口让执行器动作，比如开阀门或启动马达。做完这一圈之后，它马上又开始下一圈，循环往复。简单来说，PLC就像一台不间断工作的“小脑袋”，不停地读输入、算逻辑、出命令，让整个系统实时、稳定地运行。


---

## 第 25 页

![第 25 页](Chapter 3 - Programmable Logic ___lers (slides with annotations)_assets/page-025.png)

这张幻灯片标题是 **“Programmable Logic Controllers (12)”（可编程逻辑控制器 第12部分）**，主题是解释**PLC的循环时间（Cycle Time）为什么会变化**，以及PLC在程序执行时与普通计算机的区别。

它重点说明：
➡️ **PLC的循环时间并不是固定的**，而是取决于程序中执行的指令数量和逻辑路径。
➡️ 同时用一个简单的变量自增（`i := i + 1`）的例子，说明PLC是“循环执行”的逻辑，而不是“只运行一次”的普通计算机逻辑。

---

## 📘 详细讲解

### 🧩 1. **循环时间（Cycle Time）会变化**

PLC每次扫描（scan cycle）都要完成：
1️⃣ 读取输入、
2️⃣ 执行程序、
3️⃣ 写出输出。

**循环时间 = 执行所有指令所需时间 + I/O刷新时间 + 内部检查时间**。

所以如果程序中有**条件判断（IF语句）或执行路径不同**，每个循环所花的时间就会不同。

---

### 🟨 2. **例子 1：条件语句（IF 语句）**

幻灯片中的示例：

```
IF input = TRUE THEN GOTO END
ELSE
.
. (many instructions)
.
END: END_IF
```

解释如下：

* 当输入信号 `input = TRUE` 时，程序会立刻跳到 `END`（也就是跳过很多指令），
→ 这样这一轮扫描会非常快。

* 当输入信号 `input = FALSE` 时，PLC就会执行中间的**许多指令**（many instructions），
→ 这样循环时间会变长。

👉 **结论：**
循环时间（cycle time）会因为逻辑路径不同而变化——即使程序没变，运行时间也不一定固定。

---

### 🟩 3. **例子 2：变量自增（i := i + 1）**

第二个例子展示了PLC和普通计算机在程序执行方式上的根本区别。

#### 🧠 在普通计算机中：

```
i := 0
i := i + 1
```

执行完这一句后，程序结束，i = 1。

#### ⚙️ 在PLC中：

* PLC是**循环执行**的；
* 每一次扫描周期都会重新执行这一句：`i := i + 1`；
* 所以：

* 第一次循环结束后，`i = 1`；
* 第二次循环结束后，`i = 2`；
* 第三次循环结束后，`i = 3`；
* 以此类推，`i`会不断增长。

这说明PLC的程序不是执行一次就结束，而是会**在每个扫描周期重复执行整个逻辑**。

---

### 🧠 4. **关键区别总结**

| 项目     | 普通计算机            | PLC                   |
| ------ | ---------------- | --------------------- |
| 程序执行方式 | 一次性执行，从头到尾运行完即停止 | 循环执行，每次扫描周期都重复        |
| 变量变化   | 执行完一次后固定         | 每个周期都可能被重新计算          |
| 运行时间   | 取决于算法执行一次的时间     | 每个周期的执行时间取决于当前输入和逻辑路径 |
| 响应特性   | 不能实时响应外部变化       | 实时读取输入并动态调整输出         |

---

### 💡 5. **PLC循环时间变化的实际影响**

在工业控制中，循环时间变化可能带来以下影响：

* 若循环时间过长，响应延迟会增加；
* 若循环时间过短，CPU负载可能过高；
* 工程师在设计程序时需要确保循环时间在系统允许范围内波动。

---

## 🧩 总结要点

* **循环时间（Cycle Time）不是恒定的**，取决于程序逻辑路径（如IF语句分支）。
* **PLC程序是周期性执行的**，不会“运行完就停”，每次扫描周期都会重新执行一遍。
* 在例子中，`i := i + 1` 表示每次循环变量 i 都会增加一次。
* 因此，PLC的运作方式更像是“实时监控与控制”，而不是“一次性运算”。

---

## \[口语化表达]

这页讲的是PLC每次循环所花的时间会根据程序的内容和执行路径而变化。举个例子，如果程序里有个IF判断，当输入为真时PLC直接跳过大段指令，那这一轮扫描就会很快；但如果输入为假，PLC要执行很多指令，循环时间就会变长。另外还举了一个简单的变量例子——`i := i + 1`。在普通电脑里这句只执行一次，结果就是i=1；但在PLC里，因为程序是不断循环的，所以每一轮都会再加一次，第一轮i=1，第二轮i=2，第三轮i=3……这样不停地加下去。简单说，PLC不像电脑那样“做完就停”，而是一直在“重复干活”，每一圈的速度还会因为程序逻辑不同而变快或变慢。


---

## 第 26 页

![第 26 页](Chapter 3 - Programmable Logic ___lers (slides with annotations)_assets/page-026.png)

这张幻灯片标题是 **“Programmable Logic Controllers (13)”（可编程逻辑控制器 第13部分）**，讲的是 **PLC的最大反应时间（Maximal Reaction Time）**，也就是当一个外部事件发生时，PLC最晚需要多久才能做出相应的控制反应。

---

## 📘 一、主要内容解析

### 🧩 1. 背景概念

PLC在循环扫描模式下工作（Cyclic Scanning Mode），每一轮循环包括三个主要阶段：

* **I（Input）**：读取输入信号（传感器状态）
* **P（Program）**：执行程序逻辑（计算控制结果）
* **O（Output）**：写出输出信号（控制执行器动作）

这个过程会不断重复。
因此，PLC并不是“实时立刻”响应输入变化，而是在下一个扫描周期内“看到”变化并“执行”动作。

---

### 🟨 2. 关键问题：最大反应时间

幻灯片上提出的问题是：

> **Maximal reaction time (delay between process event and corresponding control action)?**
> 也就是：
> **从外部事件发生（输入信号变化）到PLC作出反应（输出信号改变）之间，最久可能会延迟多久？**

---

### 🟥 3. 图示说明

横向的时间轴表示PLC的循环过程：

```
...  P  |  O  |  I  |  P  |  O  |  I  |  P  |  O  ...
```

其中：

* **I（Input）**：PLC读取输入信号；
* **P（Program）**：PLC执行程序逻辑；
* **O（Output）**：PLC写出控制信号。

红色箭头部分表示：

1️⃣ **Input change（输入变化 / 过程事件）**：
外部传感器信号发生变化，比如温度升高、按钮被按下。

2️⃣ **Change written in input memory（输入数据被写入PLC内存）**：
这个变化只有等到PLC在“下一次读取输入（I）阶段”时才会被更新。

3️⃣ **Output change（输出变化 / 控制反应）**：
程序执行完逻辑计算并写出输出信号后，控制结果才真正生效（例如阀门打开、电机启动）。

---

### 🧠 4. 反应延迟的原因

PLC不是“立即响应输入”，而是“在下一轮循环时才读取输入”。
这就导致了时间延迟。

**最坏情况下（Worst Case）**：
输入变化恰好发生在PLC刚读完输入、准备执行程序之后。
此时PLC必须等：

* 这一轮循环执行完；
* 再下一轮开始时重新读取输入；
* 执行逻辑；
* 输出新的控制信号。

所以延迟最多可能是 **两个循环周期的时间**。

---

### 🧩 5. 公式表示

> **Maximal Reaction Time = 2 × Max. Cycle Time**

举个例子：
如果PLC的最大扫描周期（Cycle Time）是 10ms，
那么在最坏情况下，PLC对输入变化的最大反应延迟就是 **2 × 10ms = 20ms**。

---

### 💡 6. 实际意义

* 对于快速变化的过程（如高频机械运动），工程师必须确保**PLC的循环时间足够短**；
* 对于反应慢的过程（如温度控制），几十毫秒的延迟一般没影响；
* 如果系统要求实时响应（如机器人控制），可能需要用专用实时控制器而非标准PLC。

---

## 🧾 小结

* PLC每次循环分为：**读取输入（I） → 执行程序（P） → 写出输出（O）**；
* 如果输入信号在某一轮刚被读取之后发生变化，PLC要等到下两轮才能响应；
* 因此最大反应时间 = **2 × 最大循环时间**；
* 这是PLC响应速度的理论上限。

---

## \[口语化表达]

这页讲的是PLC对外部事件反应的“最慢速度”，也就是当传感器信号变化后，PLC最久要多久才能作出反应。因为PLC是按循环扫描方式工作的——先读输入、再执行程序、最后写输出——所以它不可能立刻响应输入。如果信号刚好在PLC读完输入之后才变化，那PLC这一轮根本不会察觉，得等到下一轮才读到，然后再执行一次程序、再输出。这样算下来，从信号变化到控制动作生效，最坏的情况就是要经过两整个循环时间。所以结论就是：**最大反应时间 = 两倍的最大扫描周期**。比如PLC一圈要10毫秒，那最慢20毫秒才会有反应。简单说，就是PLC是“有节奏地看世界”的，不是随时都在盯着。


---

## 第 27 页

![第 27 页](Chapter 3 - Programmable Logic ___lers (slides with annotations)_assets/page-027.png)

这张幻灯片标题是 **“Programmable Logic Controllers (14)”（可编程逻辑控制器 第14部分）**，是上一页关于“PLC最大反应时间（Maximal Reaction Time）”的延续和总结。
它说明了三个重点内容：
1️⃣ 最大反应时间的公式；
2️⃣ 如何估算PLC的实时响应能力；
3️⃣ 如果反应太慢，该怎么改进。

---

## 📘 一、主要内容详解

### 🧩 1. 最大反应时间公式

> **Maximal reaction time = 2 × maximal cycle time**

这是对上一页内容的总结：

* 在最坏情况下，PLC需要\*\*两个完整的扫描周期（cycle）\*\*才能响应外部输入变化；
* 因此最大反应时间（Maximal Reaction Time）= 2 × 最大循环时间（Max Cycle Time）。

例如：
如果PLC最大扫描周期为 15ms，那么最差情况下PLC需要 30ms 才能做出反应。

---

### 🟩 2. 循环扫描模式（Cyclic Scanning Mode）与实时性能估算

幻灯片指出，**循环扫描模式其实有助于预测系统的实时性能（real-time behavior）**，
因为循环时间是可测量或可计算的。

具体方法如下：

#### ✅ Step 1：确定程序中最长的执行路径（Longest Execution Path）

* 不同的逻辑分支执行时间不同，例如：

* IF分支较短；
* ELSE分支有大量指令；
* 取程序中最“重”的那一条路径来计算最坏情况。

#### ✅ Step 2：测量或估计该路径的循环时间（Cycle Time）

* 可以用PLC系统的诊断工具测量实际扫描周期；
* 也可以用静态分析或经验估算。

#### ✅ Step 3：应用公式计算最大反应时间

> Reaction Time = 2 × Cycle Time

通过这些步骤，工程师就能在设计阶段预估系统的最大延迟，从而判断系统能否满足实时性要求。

---

### 🟥 3. 如果反应时间太长，怎么办？

当系统的反应时间超过工艺要求（比如机械或安全系统需要更快响应）时，可以采取以下三种改进措施：

#### 🧠 (1) **优化程序（Optimize Program）**

* 精简逻辑结构、减少不必要的计算；
* 避免冗余的嵌套或重复指令；
* 合理使用定时器与中间变量，提升执行效率。

#### ⚙️ (2) **使用更高性能的PLC（Choose more performant PLC）**

* 不同型号的PLC处理速度不同；
* 高端型号有更快的CPU、更大的内存、更短的扫描周期；
* 替换设备可以直接缩短反应时间。

#### 🔔 (3) **使用中断机制（Use Interrupts）**

* 中断是一种**打断循环扫描、立即执行特定任务**的机制；
* 当关键输入信号变化（例如紧急停止按钮）时，PLC能立刻响应，而不用等下一个循环；
* 这种方式非常适合对实时性要求极高的应用（如安全控制、机器人停止动作等）。

---

## 🧠 总结要点

* **最大反应时间 = 2 × 最大循环时间**，是PLC响应外部变化的最坏延迟；
* **循环扫描模式**使得反应时间可预测，因为每个循环周期固定且可测；
* 如果反应时间太长，可以通过：
1️⃣ 优化程序逻辑；
2️⃣ 更换性能更好的PLC；
3️⃣ 启用中断机制来提高即时响应能力。

---

## \[口语化表达]

这页其实是在总结上一页讲的“PLC最慢反应要多久”这件事。它先告诉我们一个公式：最大反应时间等于最大循环时间的两倍——也就是说，如果PLC一圈要15毫秒，那最慢可能30毫秒后才会反应。然后它解释怎么估算PLC的实时性能：你要先找出程序里执行时间最长的那条路径，比如IF语句的长分支，然后测量或估算这段逻辑执行需要多长时间，再用公式算出反应时间。最后，它告诉我们如果PLC反应太慢该怎么办。可以优化程序，让它执行得更快；或者换个处理速度更快的PLC；再不行，就用中断机制，让PLC在关键事件发生时立刻打断当前循环、马上响应。简单说，这页讲的就是——**如果PLC反应太慢，要么写得更聪明，要么换得更快，要么用中断直接插队。**


---

## 第 28 页

![第 28 页](Chapter 3 - Programmable Logic ___lers (slides with annotations)_assets/page-028.png)

这张幻灯片标题是 **“Content”（目录）**，是整个课程或章节的总纲页，列出了本部分（Part）将要讲解的主要主题。
从结构上看，这是“Introduction to Embedded Systems（嵌入式系统导论）”课程中 **第三部分：Programmable Logic Controllers（可编程逻辑控制器）** 的教学计划延续页。

这一页主要介绍了PLC课程接下来的内容安排，也就是在讲完“逻辑控制”和“PLC技术”之后，将要进入的**编程与设计部分**。

---

## 📘 一、详细内容解析

幻灯片中的目录分为五个主要模块，每一项都是PLC控制系统学习的关键知识点。

---

### 🟩 1️⃣ Logic Control（逻辑控制）

* 这是PLC课程的基础部分。
* 内容涉及如何使用逻辑条件（如与、或、非）控制设备运行。
* 之前的章节（例如Trip、Interlock、Sequence Controller）都属于这一部分内容。

➡️ 主要讲PLC控制的**原理性逻辑思想**，让学生理解控制系统是如何“按条件执行”的。

---

### 🟨 2️⃣ PLC Technology（PLC 技术）

* 这一部分介绍PLC的**硬件结构**与**工作原理**；
* 包括PLC组成部分（CPU、输入输出模块、内存）、循环扫描机制（Cyclic Scanning Mode）、反应时间、系统层级等。
* 目标是让学生理解PLC系统的内部机制与性能特征。

➡️ 简单说，就是学习PLC这台控制器“怎么造的、怎么工作的”。

---

### 🟦 3️⃣ Programming Languages（编程语言）

这是课程的重点模块之一，讲解如何用不同的PLC编程语言来实现控制逻辑。

PLC的编程语言遵循国际标准 **IEC 61131-3**，其中包括多种图形化与文本化语言。
在幻灯片中列出了三种主要语言：

#### ▪ Function Block Diagram (FBD)

* 功能块图，是一种图形化语言；
* 使用“函数块（Function Block）”之间的连接来表达信号流；
* 适合做连续控制或数据流逻辑。

#### ▪ Ladder Diagram (LD)

* 梯形图语言，是最早也是最常用的PLC语言；
* 结构看起来像电气控制电路图，用继电器逻辑符号表示控制关系；
* 对电气工程师非常直观。

#### ▪ Instruction List (IL)

* 指令表语言，类似汇编语言；
* 通过逐条执行指令实现逻辑操作；
* 现代PLC中逐渐被结构化文本（Structured Text）取代。

➡️ 这一章的重点是学习**不同的PLC编程方式及其应用场景**。

---

### 🟧 4️⃣ Model-based Design（基于模型的设计）

* 讲解如何用数学模型或仿真工具（如Simulink）来设计控制系统；
* 通过仿真先验证控制逻辑的正确性，再生成PLC代码；
* 是现代工业控制系统设计的趋势。

➡️ 这一部分偏向“现代工程设计方法”，从“手工编程”转向“自动化建模与验证”。

---

### 🟥 5️⃣ Sequential Controllers（顺序控制器）

* 顺序控制主要用于**按一定步骤执行的工艺过程**（如灌装、加热、冷却、排空等）；
* 对应的编程方式是 **Sequential Function Charts（顺序功能图，简称SFC）**；
* SFC通过状态（Step）和转换条件（Transition）来描述系统运行的步骤流程。

➡️ 这部分的重点是掌握“流程式控制逻辑”，即如何用SFC编写复杂的多步骤控制程序。

---

## 🧠 二、总结重点

* 这页内容是整个“PLC”章节的**学习路线图**；
* 逻辑控制与PLC技术部分打基础，
编程语言部分讲“怎么写”，
模型化设计和顺序控制则讲“怎么设计复杂系统”；
* 三种编程语言（FBD、LD、IL）是PLC编程的核心技能；
* 顺序功能图（SFC）是高层次流程控制的重要方法。

---

## \[口语化表达]

这页其实就是课程的“目录”或“路线图”。前面讲的“逻辑控制”和“PLC技术”是基础，让我们先搞清楚PLC是怎么工作的、它的硬件结构和扫描机制是什么。接下来要学的是PLC的编程语言，有三种主要的：功能块图（FBD）、梯形图（LD）和指令表（IL），也就是三种不同的写法。再往后是“基于模型的设计”，教我们怎么用建模工具来设计控制系统。最后一部分是“顺序控制”，也就是学怎么让系统按步骤执行，比如先加水、再加热、再排空，用的是顺序功能图（SFC）来实现。简单说，这页告诉我们——后面课程就是从“理解PLC”到“编程实现”，再到“自动化设计和流程控制”，一步步把PLC学透。


---

## 第 29 页

![第 29 页](Chapter 3 - Programmable Logic ___lers (slides with annotations)_assets/page-029.png)

internal server error


---

## 第 30 页

![第 30 页](Chapter 3 - Programmable Logic ___lers (slides with annotations)_assets/page-030.png)

Something went wrong while generating the response. If this issue persists please contact us through our help center at help.openai.com.


---

## 第 31 页

![第 31 页](Chapter 3 - Programmable Logic ___lers (slides with annotations)_assets/page-031.png)

这张幻灯片标题是 **“IEC 61131 languages: Function block language (FB)”（IEC 61131 标准语言之一：功能块语言）**，讲的是在国际标准 IEC 61131 中，PLC 编程语言的其中一种 —— **功能块图语言（Function Block Diagram，简称 FBD 或 FB）** 的基本逻辑操作符。

它重点介绍了 FBD 中最基础的逻辑运算：**与（AND）** 和 **或（OR）**，并用图形化方式表示逻辑关系。

---

## 📘 一、什么是 Function Block（功能块语言）

* **FBD（功能块图）** 是一种**图形化的PLC编程语言**。
* 它通过“方块”（Block）表示功能逻辑，通过“连线”表示信号流动。
* 这种编程方式非常直观，特别适合做逻辑控制、信号处理和连续过程控制。

👉 简单来说，功能块语言就像是用“电路图”的方式在写程序。

---

## 🟨 二、基本逻辑运算符（Basic Logic Operators）

幻灯片展示了两个最基本的逻辑操作：

### 🟩 1️⃣ AND（与运算）

* 数学表达式：
**z = x ∧ y**
* 含义：
当输入 **x** 和 **y** 都为 1 时，输出 **z = 1**；
只要有一个输入为 0，输出就是 0。
* 图形化表示：
一个带有两个输入端（x、y）和一个输出端（z）的方块，上面写着 **AND**。
* 在功能块语言中，AND 的符号也可以写作 **&**。

📊 真值表如下：

| x | y | z = x ∧ y |
| - | - | --------- |
| 0 | 0 | 0         |
| 0 | 1 | 0         |
| 1 | 0 | 0         |
| 1 | 1 | 1         |

➡️ 只有两个输入都为真时，输出才为真。

---

### 🟦 2️⃣ OR（或运算）

* 数学表达式：
**z = x ∨ y**
* 含义：
只要有一个输入为 1，输出就为 1。
* 图形化表示：
方块中写着 **OR**，输入依然是 x 和 y，输出为 z。
* 在 FBD 中，也可以用 **≥1** 这个逻辑符号来表示“至少有一个输入为真”。

📊 真值表如下（右上角手写部分）：

| x | y | z = x ∨ y |
| - | - | --------- |
| 0 | 0 | 0         |
| 0 | 1 | 1         |
| 1 | 0 | 1         |
| 1 | 1 | 1         |

➡️ 只要任意输入为真，输出就为真。

---

## 🧠 三、FBD 的优势

* 图形化逻辑表达方式清晰直观；
* 便于调试、教学和现场维护；
* 容易和电气图纸或信号流程图对照理解；
* 广泛应用于过程控制、自动化生产线、楼宇控制等领域。

---

## 🧾 四、总结要点

* **功能块语言（FB）** 是IEC 61131标准中的一种图形化PLC语言；
* 基本逻辑运算包括：

* **AND（与）** → 同时为真时输出真；
* **OR（或）** → 只要有一个为真输出真；
* 在FBD中，逻辑表达通常用符号（如 `&`、`≥1`）和方块图表示；
* 这种语言简单直观，是PLC编程入门最常见的方式之一。

---

## \[口语化表达]

这页讲的是PLC编程语言里的一种——功能块图语言（FBD）。它是用图形化的方式来写逻辑的，看起来就像画电路图一样。这里介绍了两个最基本的逻辑运算：AND（与）和 OR（或）。“与”的意思是两个输入都要为真，输出才为真；“或”的意思是只要有一个输入为真，输出就为真。幻灯片右边的手写符号 `&` 和 `≥1` 就分别代表这两种逻辑。功能块图最大的特点就是直观，比如你能清楚看到信号从x、y流进来，经过逻辑块再输出z。简单说，这页就是在告诉我们：PLC里也能像电路那样“画”出逻辑关系，用方块和线条就能表示程序的思维逻辑，非常形象直观。


---

## 第 32 页

![第 32 页](Chapter 3 - Programmable Logic ___lers (slides with annotations)_assets/page-032.png)

这张幻灯片标题是 **“IEC 61131 languages: Function block language (FB)”（IEC 61131 标准语言之一：功能块语言）**，展示了一个用 **功能块图（Function Block Diagram, FBD）** 表示的逻辑表达式示例。

---

## 📘 一、图示含义

幻灯片上的逻辑表达式是：

$$
f := a ∧ (b ∨ c)
$$

意思是：**f 等于 a 与 (b 或 c) 的逻辑与结果**。

换句话说，只有当：

* **a 为真（1）**，并且
* **b 或 c 至少有一个为真（1）**，
时，输出 **f 才为真（1）**。

---

## 🟩 二、逻辑图结构解释

图中共有两个功能块：

1️⃣ **OR 块（或门）**

* 输入信号：b、c
* 输出信号：b ∨ c（b 或 c）
* 含义：如果 b 或 c 有一个是 1，输出就是 1。

2️⃣ **AND 块（与门）**

* 输入信号：a、(b ∨ c)
* 输出信号：f
* 含义：只有当 a 和 (b ∨ c) 都为 1 时，f 才输出 1。

信号的流向是这样的：
→ b 和 c 先进入 OR 块 → 输出结果送到 AND 块 → 再与 a 一起计算 → 得到最终输出 f。

这是一种典型的 **逻辑运算嵌套（Nested Logic）** 实现方式。

---

## 🧩 三、逻辑运算过程举例

假设输入信号为布尔值（1 表示真，0 表示假）：

| a | b | c | b ∨ c | f = a ∧ (b ∨ c) |
| - | - | - | ----- | --------------- |
| 0 | 0 | 0 | 0     | 0               |
| 0 | 1 | 0 | 1     | 0               |
| 1 | 0 | 0 | 0     | 0               |
| 1 | 0 | 1 | 1     | 1               |
| 1 | 1 | 0 | 1     | 1               |
| 1 | 1 | 1 | 1     | 1               |

所以只有当 **a = 1 且 b 或 c 其中至少一个 = 1** 时，输出 f 才是 1。

---

## 🧠 四、FBD 编程逻辑理解

* 这种图形化编程的优势在于：你能一眼看出逻辑关系，而不用写复杂的代码。
* 每个“功能块（Block）”代表一个逻辑运算功能（如AND、OR、NOT）。
* 通过连线表示信号的流动。
* 逻辑嵌套（例如“a 与 (b 或 c)”）通过模块的层层连接自然表达出来。

这正是FBD在PLC中最常见的应用场景：**表达复杂的逻辑控制流程，同时保持可读性高、易于维护。**

---

## 🧾 五、总结要点

* 公式：**f := a ∧ (b ∨ c)** 表示“f 等于 a 与 (b 或 c)”的逻辑与结果；
* 图中使用了两个基本逻辑模块：**OR（或）** 和 **AND（与）**；
* 逻辑流动为：b、c 进入 OR → 结果与 a 进入 AND → 输出 f；
* 只有当 a 为真，并且 b 或 c 中至少一个为真时，f 才输出真；
* 该图展示了功能块图语言的结构化与可视化特性。

---

## \[口语化表达]

这页讲的是一个用功能块图（FBD）表示的逻辑运算例子。公式是 f = a 与 (b 或 c)，意思是 f 只有在 a 为真，而且 b 或 c 至少有一个为真时，才输出真。图上左边的 OR 块先把 b 和 c 做“或运算”，只要有一个是1，结果就是1；然后这个结果再跟 a 一起进入右边的 AND 块，做“与运算”。最终 f 就是 a 和 (b或c) 的逻辑与。简单说，就是：a要开，b或c至少有一个开，f才会开。这个例子让你直观看到FBD语言的逻辑结构——用方块和连线表示逻辑关系，看起来就像画电路图一样，非常直观、好理解。


---

## 第 33 页

![第 33 页](Chapter 3 - Programmable Logic ___lers (slides with annotations)_assets/page-033.png)

这张幻灯片标题是 **“IEC 61131 languages: Function block language (FB)”（IEC 61131标准语言之一：功能块语言）**，主要讲的是：
👉 **功能块（Function Block）不只是用于逻辑运算（AND、OR、NOT等），它还可以执行数学运算、计时、比较等更复杂的功能。**

---

## 📘 一、主要内容解释

幻灯片开头写着：

> **Blocks are not restricted to logic operators.**
> 意思是“功能块不仅仅局限于逻辑运算符”。

### 🧩 功能块可以包括：

* **NAND**：逻辑“非与”运算；
* **ADD**：加法运算；
* **MULT**：乘法运算；
* **TIMER**：定时器功能。

也就是说，功能块不仅可以判断“开或关”（true/false），还可以处理整数、时间等各种类型的数据。

---

## 🟨 二、左图——加法功能块（ADD Block）

左侧的图展示了一个**ADD 功能块**：

* 输入是两个整数（INT，代表整数类型）；
* 功能块中写着 **ADD**，表示加法；
* 输出是一个整数（INT），也就是两数相加的结果。

逻辑表达为：

$$
输出 = 输入1 + 输入2
$$

➡️ 例如输入 5 和 3，输出就是 8。

这种功能块常用于工业控制中，例如：

* 累加传感器信号；
* 计算总产量；
*


---

## 第 34 页

![第 34 页](Chapter 3 - Programmable Logic ___lers (slides with annotations)_assets/page-034.png)

这张幻灯片的标题是 **“IEC 61131 languages: Ladder Diagram (LD)”（IEC 61131标准语言之一：梯形图语言）**，主要讲解了 **梯形图（Ladder Diagram, 简称LD或Kontaktplan）** 的基本概念和工作原理。

---

## 📘 一、梯形图（Ladder Diagram, LD）的基本思想

幻灯片中写到：

> **Idea:**
>
> * Resembling switching circuit design by relays ("schematics")
> * “contacts” and “coils”

意思是：
梯形图是一种模仿**继电器控制电路**的PLC编程语言。它的原理和老式电气控制电路几乎一模一样，用“触点（contacts）”和“线圈（coils）”来表示逻辑控制。

也就是说，**LD语言的本质就是：把电气控制电路的逻辑用图形化的方式表达出来。**

---

## ⚙️ 二、图中的电路逻辑解释

图的下半部分展示了一个简单的梯形图逻辑：

```
|---[ ]---( )---|
var2   var1
```

这表示：

* **var2** 是一个“触点”（contact）；
* **var1** 是一个“线圈”（coil）。

这两个符号就像电路中的两个关键元件：

* **触点**：控制电流是否能通过（相当于一个开关）；
* **线圈**：当电流通过时会被“激励”，从而触发输出。

---

## 🔋 三、工作原理（从左到右）

1️⃣ **左侧是高电位（high potential）**，右侧是低电位（low potential）。电流从左流向右。

2️⃣ **如果 var2 = TRUE（真）**，则代表“触点闭合”，电流可以通过；
→ 图上写着：`if var2 = true, contact closed.`

3️⃣ **当电流流经右侧的线圈（coil）时**，该线圈就会“通电”；
→ 于是 **var1 被置为 TRUE（真）**。
→ 图上写着：`if current flows through the coil, var1 = true.`

这就形成了一个逻辑关系：

$$
var1 := var2
$$

即 **输出变量 var1 的值取决于输入变量 var2。**

---

## 🔄 四、与继电器控制的对应关系

右上角手绘的小电路图说明了：

* 在传统电气控制中，当“开关（触点）”闭合，电流就能流过“线圈”，线圈被激励，接着触发相应的动作（比如点亮灯、启动电机）。
* 在PLC的梯形图里，这种“电流流通”的概念被抽象成**逻辑为真（True）**。

换句话说：

> **电流通过 = 逻辑为真**
> **触点闭合 = 条件成立**
> **线圈通电 = 输出激活**

---

## 💡 五、总结要点

* 梯形图（LD）是基于**继电器电路原理**的PLC语言；
* 基本元素包括：

* **触点（Contact）**：代表条件；
* **线圈（Coil）**：代表输出动作；
* 电流从左流向右，电路通路表示逻辑为真；
* 示例逻辑：
**如果 var2 为真，则电流流动，使 var1 为真。**

---

## \[口语化表达]

这页讲的是梯形图语言（Ladder Diagram, LD），它其实就是把传统电气继电器电路“画”成编程逻辑。你可以把它想成：左边是电源，高电位；右边是输出，低电位；电流从左往右流。图里有一个开关（var2）和一个线圈（var1）。当开关闭合，也就是 var2 为真时，电流就能流过线圈，线圈被激活，于是 var1 就变成真。换句话说，这个程序的意思就是“如果 var2 为真，那么 var1 也为真”。它完全模拟了物理电路的原理——触点相当于开关，线圈相当于执行装置。这种语言的好处是：直观、图形化，对电气工程师来说非常自然，看起来就像一条“电路逻辑通路”。


---

## 第 35 页

![第 35 页](Chapter 3 - Programmable Logic ___lers (slides with annotations)_assets/page-035.png)

这张幻灯片仍然是关于 **IEC 61131标准语言之一：梯形图语言（Ladder Diagram, LD）**，它讲的是 **“常闭触点（Normally Closed Contact）”** 的工作逻辑，也就是和上一页相反的情况。

---

## 📘 一、核心思想

和上一页一样，这里仍然是用“**触点（contact）**”和“**线圈（coil）**”来表示逻辑关系。
但不同之处在于，这页讲的是——

> **当输入信号为真（True）时，触点打开（Open），电流中断，输出为假（False）。**

也就是说，这是一种\*\*反逻辑（反向触点）\*\*的情形。

---

## ⚙️ 二、图中逻辑详解

图上这条“梯形线”代表电流从左向右流动的过程：

```
|---[/]---( )---|
var2   var1
```

其中：

* **var2** 是一个“触点（contact）”，但它是**常闭触点（Normally Closed Contact）**；
* **var1** 是一个“线圈（coil）”，表示输出信号。

---

### 🧩 工作原理（反逻辑）

1️⃣ 当 **var2 = FALSE（假）** 时：

* 触点保持闭合状态（closed）；
* 电流可以流过；
* 线圈被激励，输出 **var1 = TRUE（真）**。

2️⃣ 当 **var2 = TRUE（真）** 时：

* 常闭触点打开（open）；
* 电流被切断；
* 线圈失去电流，输出 **var1 = FALSE（假）**。

这就是幻灯片上写的两句话：

> * “if var2 = true, then contact open.”
> * “if current flows through the coil, then var1 = false.”

换句话说：**当输入为真时，输出为假；当输入为假时，输出为真。**
这正是“逻辑反相（NOT）”的功能。

---

## 🔋 三、继电器对比理解

在传统继电器电路中，这个常闭触点就像一个“平时连通、通电断开”的开关。

* 没通电（输入假）→ 开关闭合 → 电流通过 → 输出真；
* 通电（输入真）→ 开关断开 → 电流中断 → 输出假。

所以它的作用其实就像一个**取反器（Inverter）**。

---

## 🧠 四、对应的逻辑表达式

可以用布尔代数表示为：

$$
var1 := ¬var2
$$

也就是：

> 输出 var1 的值是输入 var2 的逻辑取反。

---

## 💡 五、总结要点

* 这是一个 **常闭触点（Normally Closed Contact）** 示例；
* 当输入为真时，电流中断 → 输出假；
* 当输入为假时，电流流通 → 输出真；
* 实现的逻辑是 **NOT（取反）**；
* 电气意义上相当于一个“反向开关”；
* 逻辑意义上相当于“输出 = 非输入”。

---

## \[口语化表达]

这页讲的是常闭触点，也就是反逻辑的情况。你可以把它理解成一个“默认是通的开关”，只有当输入信号变成真时，它才会断开电路。比如这里的 var2 是输入、var1 是输出：当 var2 为假时，电路通了，电流能流过线圈，var1 就变成真；但当 var2 为真时，触点打开，电流断了，线圈失电，var1 变成假。用一句话总结就是：**输入真，输出假；输入假，输出真**。它相当于在逻辑上做了一个“取反”的功能，就像电气里的常闭开关一样。


---

## 第 36 页

![第 36 页](Chapter 3 - Programmable Logic ___lers (slides with annotations)_assets/page-036.png)

这张幻灯片的标题是 **“IEC 61131 languages: Ladder Diagram (LD)”（IEC 61131标准语言之一：梯形图语言）**，主要内容是讲解**梯形图中的基本逻辑运算符（Basic logic operators）**，也就是“与（AND）”和“或（OR）”的实现方式。

---

## 📘 一、基本逻辑运算符介绍

幻灯片展示了两种最基础的逻辑表达式在梯形图中的表示方式：

1️⃣ **上半部分：AND（与）逻辑**

$$
z = x \land y
$$

2️⃣ **下半部分：OR（或）逻辑**

$$
z = x \lor y
$$

这两种逻辑是PLC控制系统中最基本的逻辑运算结构，几乎所有控制程序的判断条件都由它们组合而成。

---

## ⚙️ 二、AND（与）逻辑的图形解释

上半图：

```
|---[ ]---[ ]---( )---|
x     y      z
```

### ✅ 含义：

* 两个触点（x 和 y）**串联**；
* 输出线圈为 **z**。

### 🔋 工作原理：

* 电流从左边的高电位流向右边的低电位；
* 只有当 **x = TRUE 且 y = TRUE** 时，两段触点都闭合；
* 电流才能流通到右边的线圈；
* 因此 **z = TRUE**；
* 如果任意一个输入为假（False），电路就被断开，输出 z 为假。

### ⚙️ 对应布尔逻辑：

$$
z = x \land y
$$

📘 类比现实生活：
就像你必须同时按下两个按钮，机器才会启动——这就是\*\*“与”逻辑\*\*。

---

## ⚙️ 三、OR（或）逻辑的图形解释

下半图：

```
|---[ ]---( )---|
|---[ ]---( )---|
x     y      z
```

### ✅ 含义：

* 两个触点（x 和 y）**并联**；
* 输出线圈为 **z**。

### 🔋 工作原理：

* 电流从左侧流入；
* 当 **x = TRUE** 或 **y = TRUE**（只要其中一个触点闭合）；
* 电流就能流到右边，激活线圈；
* 因此 **z = TRUE**；
* 只有当 **x 和 y 都为 FALSE** 时，电路才会断开，z = FALSE。

### ⚙️ 对应布尔逻辑：

$$
z = x \lor y
$$

📘 类比现实生活：
只要你按下任意一个开关，灯就会亮——这就是\*\*“或”逻辑\*\*。

---

## 🧠 四、总结与对比

| 逻辑类型   | 电路连接方式 | 条件        | 输出（z）为真时机  | 逻辑公式      |
| ------ | ------ | --------- | ---------- | --------- |
| AND（与） | 串联     | x 和 y 都为真 | 电流依次通过所有触点 | z = x ∧ y |
| OR（或）  | 并联     | x 或 y 为真  | 电流可通过任意支路  | z = x ∨ y |

---

## 💡 五、扩展理解

在PLC编程中：

* 这些逻辑运算可以与\*\*取反（NOT）\*\*结合形成复杂条件；
* 比如“x 与 非y” 或 “x 或（y 且 z）”；
* 梯形图（LD）的好处是：**形象直观、逻辑清晰、便于电气工程师理解**；
* 因为它直接模仿了继电器电路的接线方式。

---

## \[口语化表达]

这页主要讲


---

## 第 37 页

![第 37 页](Chapter 3 - Programmable Logic ___lers (slides with annotations)_assets/page-037.png)

这张幻灯片同样讲的是 **IEC 61131 标准语言之一：梯形图语言（Ladder Diagram, LD）**，主题是梯形图中的**基本逻辑运算符（Basic logic operators）**。这页重点在于引入\*\*“取反（NOT）”逻辑\*\*，也就是在“与（AND）”或“或（OR）”逻辑中，如何对某一个输入信号进行反向处理。

---

## 📘 一、总体内容

幻灯片展示了两种逻辑关系：
1️⃣ **上方：与（AND）逻辑**

$$
z = x \land y
$$

2️⃣ **下方：或+取反（OR with NOT）逻辑**

$$
z = x \lor \overline{y}
$$

---

## ⚙️ 二、上图：AND（与）逻辑解释

```
|---[ ]---[ ]---( )---|
x     y      z
```

### ✅ 含义：

* 触点 x 和 y 串联；
* 只有当 **x = TRUE 且 y = TRUE** 时，电流才能流过线圈 z；
* 因此 **z = TRUE**；
* 任意一个输入为假（False），电路断开，z = FALSE。

📘 对应逻辑表达式：

$$
z = x \land y
$$

也就是说，这个电路代表“两个条件同时满足时，输出为真”。

---

## ⚙️ 三、下图：OR + NOT（或加取反）逻辑解释

```
|---[ ]---( )---|
|---[/]---( )---|
x     y'     z
```

在图中：

* **x 是普通常开触点（contact）**；
* **y 是带斜杠的触点（/）**，代表 **常闭触点（Normally Closed Contact）**；
* 这表示 y 的逻辑是**取反**的。

### ✅ 工作原理：

* 电流有两条并联通路（OR逻辑）；
* 第一条：若 **x = TRUE** → 电流通过；
* 第二条：若 **y = FALSE** → 因为常闭触点默认导通，电流也能通过；
* 只要两条路中任意一条导通，电流就能流向线圈 **z**；
* 因此 **z = x ∨ ¬y**。

📘 对应布尔逻辑：

$$
z = x \lor \overline{y}
$$

换句话说：

> “只要 x 为真，或者 y 为假，输出 z 就为真。”

---

## 🔋 四、现实意义

这种“或加取反”的结构在工业控制中非常常见，比如：

* **安全联锁系统**
当某个安全传感器（y）检测到异常（True）时，就断开控制回路（¬y = False）；
但系统还有其他条件（x）可以维持部分操作。

* **备用触发逻辑**
如果主信号（x）有效，或者备用信号（y）无效时，设备仍然工作。

这种设计可以让系统具备**冗余与保护机制**。

---

## 🧠 五、逻辑比较总结

| 逻辑类型           | 图形结构     | 含义               | 输出条件（z = TRUE） | 逻辑表达式      |
| -------------- | -------- | ---------------- | -------------- | ---------- |
| AND（与）         | 串联       | 所有条件都为真          | x 和 y 都为真      | z = x ∧ y  |
| OR + NOT（或加取反） | 并联，带反向触点 | 任一条件满足（x 真或 y 假） | x 为真 或 y 为假    | z = x ∨ ¬y |

---

## 💡 六、要点总结

* **“与（AND）” → 串联，所有条件必须为真；**
* **“或（OR）” → 并联，任一条件为真即可；**
* **“非（NOT）” → 常闭触点（/），输入为假时通电。**
* 所以这页的第二个例子结合了“或”与“取反”逻辑，形成更灵活的控制逻辑。

---

## \[口语化表达]

这页讲的是在梯形图里怎么把“取反”逻辑加进来。上面的图是标准的“与”逻辑，也就是 x 和 y 都要为真，z 才会输出真。下面的图就有点意思了，它是“x 或非 y”。注意 y 那个触点有一条斜杠，代表它是常闭触点，也就是说，当 y 为假时，它才导通。整个电路相当于有两条并联通路：一条是 x，一条是 ¬y。只要 x 为真，或者 y 为假，电流就能流过去，z 就会被激活。简单说，这个逻辑就是“只要有一个条件满足（x 真或 y 假），输出就为真”。这页其实就是教你在梯形图里怎么用“或”和“取反”组合出更复杂的逻辑。


---

## 第 38 页

![第 38 页](Chapter 3 - Programmable Logic ___lers (slides with annotations)_assets/page-038.png)

这张幻灯片继续讲解 **IEC 61131 标准语言中的梯形图语言（Ladder Diagram, LD）**，主题是一个**综合示例**，用来展示如何把复杂的逻辑表达式转化成梯形图形式。

---

## 📘 一、核心内容概览

标题表达式是：

$$
f = a \land (b \lor \overline{c})
$$

这句话的意思是：

> 输出 **f** 只有在 **a 为真** 且 **(b 或 非 c)** 为真时才为真。

这属于一个“与 + 或 + 取反”的复合逻辑表达式。

---

## ⚙️ 二、逻辑结构拆解

表达式可以分为两部分：

1️⃣ **外层逻辑：**

$$
a \land (...)
$$

→ 表示 **a** 是主输入条件，它和整个括号部分进行“与（AND）”运算。
→ 在梯形图中体现为：
“**a 的触点与括号部分的输出串联连接。**”

2️⃣ **内层逻辑（括号部分）：**

$$
(b \lor \overline{c})
$$

→ 表示一个“或（OR）”逻辑：**b 为真 或 c 为假** 时输出为真。
→ 在梯形图中体现为：
“**b 的触点与 c 的常闭触点并联连接。**”

---

## 🧩 三、梯形图逻辑对应关系

上半部分图就是逻辑结构的可视化：

```
|---[b]---|
|          |
|---[/c]---|----[a]----(f)
```

解释如下：

* **\[b]** → 常开触点（当 b = TRUE 时导通）
* **\[/c]** → 常闭触点（当 c = FALSE 时导通）
* **\[a]** → 常开触点，与括号结果串联
* **(f)** → 输出线圈，表示输出变量 f

---

### 🔋 电路逻辑流程：

1️⃣ **并联部分**（左边红圈的部分）：

* b 为真 → 电流通过；
* c 为假（常闭） → 电流通过；
* 所以只要 **b 或 非 c** 为真，电流能通过这一段；

2️⃣ **串联部分**：

* 并联输出再与 a 串联；
* 只有 a 也为真时，电流才能继续流到输出线圈 f；

3️⃣ **最终结果**：

$$
f = a \land (b \lor \overline{c})
$$

---

## 🧠 四、逻辑理解举例

可以用一个现实控制场景来类比：

> 假设工厂中有一台设备，它的启动条件是：
>
> * 主开关 a 必须打开（a = TRUE）；
> * 同时，以下任一条件满足：
>
>   * 传感器 b 检测到工件存在；
>   * 或者，安全门 c 没有关闭（c = FALSE）。
>
> 那么控制信号 f = TRUE，机器启动。

这就是上图逻辑的实际意义。

---

## 📊 五、图中要点总结

| 逻辑符号    | 含义 | 电气对应 | 梯形图表现      |
| ------- | -- | ---- | ---------- |
| ∧ (AND) | 与  | 串联   | 元件顺序相连     |
| ∨ (OR)  | 或  | 并联   | 两条线路并列     |
| ¬ (NOT) | 非  | 常闭触点 | 斜线“/”表示反逻辑 |

在图中：

* **b 与 ¬c 并联 → 实现“或”逻辑；**
* **a 与上面并联部分串联 → 实现“与”逻辑。**

---

## 💡 六、总结要点

* 这页展示了一个**复杂逻辑组合在梯形图中的实现方式**；
* 表达式为 **f = a ∧ (b ∨ ¬c)**；
* 图形表现为：

* **a 与 (b 或 非 c)** 串联；
* **b 与 ¬c 并联；**
* 电流流动的路径完全对应逻辑表达式的运算顺序；
* 这是逻辑代数与电气控制图之间的直接映射。

---

## \[口语化表达]

这页其实是把一个稍复杂的逻辑公式画成梯形图。公式是 f = a ∧ (b ∨ ¬c)，意思就是：a 要为真，同时 b 或者“非 c”有一个为真，输出 f 才会为真。你可以这么理解：b 和 ¬c 这两个条件是“或”的关系，它们在电路上是并联的，只要其中一个能让电流通过就行；然后这部分又跟 a 串联，所以 a 必须也是真，电流才能继续流到线圈 f。换成生活比喻，这就像一台机器要启动，主电源 a 必须打开，然后要么传感器 b 检测到物料，要么安全门 c 处于打开状态（即 ¬c），机器才会启动。总结一句话：这页教你如何把逻辑公式里的“与、或、非”转成电气式的梯形图连接方式。


---

## 第 39 页

![第 39 页](Chapter 3 - Programmable Logic ___lers (slides with annotations)_assets/page-039.png)

这页标题是 **“IEC 61131 languages: Ladder Diagram (LD)”（梯形图）**，要表达的核心是：**在梯形图程序里可以直接嵌入功能块（Function Blocks）**，不仅能做逻辑，还能做算术等运算。

---

## 这页在讲什么？

* 上方公式：**`z := x + y`**，意思是用算术加法把变量 *x* 和 *y* 相加，把结果赋给 *z*。
* 梯形图中：

* 左侧两条并行的导线各有一个常开触点，分别标记为 **x** 和 **y**，表示这两个数值作为输入被“送进”功能块。
* 中间的大方块写着 **ADD**，代表**加法功能块**（功能块的一个例子，除了 ADD 还可以是乘法 MULT、定时器 TIMER、比较器等）。
* **ADD** 的输出接到右侧的线圈 **z**，表示把计算结果（x+y）写入变量 **z**。
* 含义：**梯形图（LD）不仅仅是串/并联触点做与/或逻辑**，还可以把 **FBD/FB 的功能块**嵌入到网络中完成**数值计算、定时、计数等非布尔运算**，结果再用线圈赋给目标变量。

---

## 为什么有用？

* 现场项目里经常需要**逻辑判断 + 数值计算**混合（如流量累计=上次累计+本次增量）。
* 把 **FB 功能块**放进 **LD**，既保留了电气工程师熟悉的“电路式”可读性，又能完成更复杂的功能，**提高可维护性与表达力**。

---

## 小结要点

* **LD 可嵌入功能块**：不仅能做 AND/OR，还能做 **ADD/MULT/TIMER** 等。
* 图中网络实现 **`z := x + y`**：x、y 输入 → ADD 计算 → 输出到线圈 z。
* 这体现了 **IEC 61131** 语言的互通性：**LD 的结构 + FB 的能力**。

---

\[口语化表达] 这页就是在说：梯形图也能“夹带私货”做计算，不光是开关逻辑。左边把 x 和 y 这两个数丢进中间的 ADD 方块里做加法，右边用线圈把结果写到 z。换句话说，就是在梯形图里直接算出 z = x + y。实际工程里，你可以像搭积木一样，把加法、乘法、定时器这些功能块塞到梯形图里，让程序既好读又能干活儿。


---

## 第 40 页

![第 40 页](Chapter 3 - Programmable Logic ___lers (slides with annotations)_assets/page-040.png)

这张幻灯片讲的是 **IEC 61131 标准中「函数（Function）」与「功能块（Function Block）」的区别**，重点在于两者在行为和数据记忆方式上的差异：
函数是**静态的（static）**，而功能块是**动态的（dynamic）**。

---

## 🧩 一、上半部分：Function（函数）

### 📘 图示解释

左边的框中输入有：

* heating on（加热状态）
* level > Imin（液位高于最低值）
* temperature sensor（温度传感器）

输出：danger（危险信号）

### 📖 含义

这个函数根据输入信号直接计算输出信号：

$$
danger = f(heating, level, temperature)
$$

也就是一个**无记忆的静态映射关系**。

* 输入变 → 输出立即跟着变；
* 函数**不会记忆以前的状态**；
* 每次执行都只依赖当前输入；
* 类似数学函数 `y = f(x)`。

📌 举例说明：
如果液位太高、加热器开启、温度过高 → danger = TRUE；否则 FALSE。
只要输入条件变了，输出会即时刷新。

---

## ⚙️ 二、下半部分：Function Block（功能块）

### 📘 图示解释

输入：On-button（按下按钮）
输出：Motor（电机启动）
右边有一条波形图，标明内部有记忆（Memory），并且是动态行为。

### 📖 含义

功能块（FB）与普通函数不同，它**内部有状态记忆**。
当输入触发时，它不仅根据当前输入，还会记住上一次执行的结果。

* 有**内部变量**或**内部状态**（例如一个“开关保持”机制）；
* 输出不仅取决于输入，还取决于**过去的历史状态**；
* 所以它是**动态的函数块**，有“记忆功能”。

📌 举例说明：
当按下启动按钮（短暂脉冲）时，FB 会将 motor 状态设为 ON；
即使按钮松开，motor 依旧保持 ON（因为块内部保存了状态）。
这在工业中非常常见，比如启动保持、定时器、计数器等逻辑。

---

## ⚖️ 三、对比总结

| 特性   | Function（函数）  | Function Block（功能块） |
| ---- | ------------- | ------------------- |
| 状态   | 静态（stateless） | 动态（stateful）        |
| 内存   | 无记忆           | 有内部存储（memory）       |
| 输出依赖 | 仅依赖当前输入       | 依赖输入 + 内部状态         |
| 行为类型 | 即时计算（组合逻辑）    | 带有记忆（时序逻辑）          |
| 示例   | 温度报警逻辑        | 电机启动保持、定时器          |

---

## 💡 四、核心结论

* **Function**：输入 → 输出，逻辑简单，无记忆。
* **Function Block**：输入 → 输出 + 内部状态，带记忆和动态行为。
* 在 PLC 编程中：

* Function 用来做逻辑或数学计算；
* Function Block 用来实现“带记忆的设备行为”（比如电机、计数器、定时器、PID 控制器等）。

---

## \[口语化表达]

这页主要是讲“函数”和“功能块”的区别。函数就像数学里的公式，输入是什么，输出马上就是什么，没有记忆，比如检测危险状态那种，一旦条件不满足就立刻变成安全。功能块不一样，它是有记忆的。比如一个电机启动按钮，你按一下，它记住这个状态，让电机一直转；就算你松开按钮，电机也不会马上停。这是因为功能块内部有“存储”或“记忆”机制。简单说，函数是一次性计算，而功能块是带状态的控制逻辑，会记住之前的操作。


---

## 第 41 页

![第 41 页](Chapter 3 - Programmable Logic ___lers (slides with annotations)_assets/page-041.png)

这页讲的是 **IEC 61131 标准功能块中的锁存器（Latches）**，也叫“自保持”逻辑。
重点是：如何用已经学过的基本逻辑元件（如 AND、OR、继电器触点）来实现一个“按下启动后能保持运行”的电机控制。

---

## 🧩 一、问题背景

题目开头问：

> How can the desired functionality be programmed using only the already known basic operators?
> （如何仅使用我们已经学过的基本逻辑运算符来实现所需功能？）

这里说的功能是“**Latch**（锁存、自保持）”——也就是**按一次启动按钮后，电机自己保持运行，不需要一直按着**。

---

## ⚙️ 二、上半部分：FB 实现尝试（Function Block）

图中左上方是：

```
On ─┬──> OR ───> motor
│
motor┘
```

意思是：

* 输入有两个信号：

* `On`（按下启动按钮）
* `motor`（电机输出反馈）
* 两者通过“OR”相连，也就是说：

* 只要按下按钮，或者电机已经在运行（自保持反馈），就能维持输出 motor = TRUE。

这本来是想实现一个“保持逻辑”，但图中用红叉标出“X”。
原因是：
**在 Function Block（FB）里不能这样直接自反馈连接输出端。**

* 因为在 FB 中，输出是计算结果，不能直接在同一个逻辑周期内反向作为输入；
* 这样会造成逻辑环路错误（loop error）。

所以，这种结构**不能直接在 FB 里实现**。

---

## 🔌 三、下半部分：LD 实现（Ladder Diagram 梯形图）

梯形图下方用标准继电器符号实现了相同的功能：

```
|—[ On ]—[ motor ]—( motor )—|
```

解释如下：

* 左边两个触点是“串联”的：

* `[On]` → 表示启动按钮；
* `[motor]` → 表示电机的自保持触点；
* 当 `On` 按下时，电机输出线圈 `(motor)` 通电；
* 电机线圈动作后，它的常开触点 `[motor]` 也闭合；
* 即使 `On` 按钮松开，电流仍能通过 `[motor]` 触点维持自身通电；
* 这就形成了\*\*“自保持”电路\*\*。

右侧红色部分是该逻辑的简写形式：

```
[On] —— (S motor)
```

其中：

* `S` 是 **Set（置位）** 的缩写；
* 表示一旦触发 On，motor 就被“置位”为真（保持运行状态）。

---

## 🧠 四、总结要点

| 实现方式                | 特征              | 是否能实现自保持      |
| ------------------- | --------------- | ------------- |
| Function Block (FB) | 纯逻辑运算（不能回馈自身输出） | ❌ 不行，会循环引用    |
| Ladder Diagram (LD) | 可通过触点自保持回路      | ✅ 可实现自锁功能     |
| 关键元件                | OR / S（Set）     | 用 Set 或触点保持实现 |

---

## 💡 五、核心理解

“锁存器（Latch）”的本质是让输出保持状态，即使输入信号消失。
在 PLC 编程中，

* FB 逻辑通常是**无记忆的（stateless）**，因此不能自保持；
* LD 则允许使用触点表示输出状态，因此可以自回馈实现“记忆”。

---

## \[口语化表达]

这页在讲“怎么让电机按一下启动键后自己保持运行”。
一开始用 FB（功能块）试图用 OR 把按钮和电机自己连起来，意思是“要么按钮按着，要么电机自己保持”，但这种写法在功能块里会出错，因为输出不能直接反向当输入。
换成梯形图（LD）就好办了：在电机线圈旁边再加一个自己的常开触点 `[motor]`，当按钮 `[On]` 按下后电机通电，然后这个触点闭合，就算松开按钮电机也能靠自己保持通电。
右边红色的 `(S)` 就是“置位”的简写。
一句话总结：**FB 不能直接自保持，但在梯形图里可以通过电机自己的触点形成记忆回路，让它按一次就一直运行。**


---

## 第 42 页

![第 42 页](Chapter 3 - Programmable Logic ___lers (slides with annotations)_assets/page-042.png)

这页题目是 **“IEC 61131 标准功能块：锁存器（2）”**，重点讨论：**已经做了电机自保持（Latch）以后，怎么“关掉”电机？**
它分别从 FB（功能块）和 LD（梯形图）两种写法说明“复位/停止”的实现方式，并引入 **Reset（R）/ Set（S）** 的标准记号。

---

## 一、FB 视角：仅靠基本门电路不好关机 → 用标准“RS/SR 锁存块”

上面两幅小图的意思：

* 右上角 “Off → ？ → motor” 提问：**关电机应该用什么？**
* 左上角把 **Off** 和 **motor** 反馈硬接进 **AND** 或做回路，这样的“自连”在 FB 里会造成**逻辑环路/语义不清**，是不推荐或不允许的（和上一页 OR 自保持同理）。

**正确做法（IEC 61131 标准）：用 RS/SR 锁存功能块**

* **S（Set）** 接 “On（启动）”；
* **R（Reset）** 接 “Off（停止）”；
* 块输出 Q 接 **motor**。
这样电机被 **S** 置位后保持运行，收到 **R** 即被复位停止。FB 用标准锁存块避免了不安全的自反馈回路。

---

## 二、LD 视角：用触点“切断自保持回路”或用“复位线圈”

底部两种梯形图等价写法：

### 1) 触点切断法（左下主图）

```
|--[ Off ]--[ motor ]----( motor )--|
```

* `[motor]` 为自保持触点（常开，线圈得电后闭合）；
* `[Off]` 作为“停止”触点（通常设计为**常闭**，Off=TRUE 时打开回路）；
* 当 **Off** 触发时，**\[Off]** 断开 → 线圈 `(motor)` 失电 → `[motor]` 自保持触点随之释放 → 电机停转。
这就是典型的 **切断自保持通路** 的停机方式。

> 注意：现场常把 **Off** 画成常闭触点（/），表示**默认导通**，按下停止后断开回路更安全（即“失电安全”）。

### 2) 复位线圈法（右下红色简写）

```
|--[ Off ]--------------( R motor )--|
```

* `(R motor)` 是 **复位线圈**，IEC 61131 的**缩写**：**R := Reset**；
* 当 **Off** 为 TRUE 时，对 **motor** 变量执行复位（清零/断电）。
* 与上一种等价，但更直观地表达“这是一次复位动作”。

---

## 三、整体逻辑闭环（结合上一页“置位/自保持”）

* **启动（Set）**：`[On]` 置位 `(S motor)`，或用自保持触点 `[motor]` 形成回路；
* **停止（Reset）**：`[Off]` 触发 `(R motor)`，或“切断”回路使 `(motor)` 失电。
* 在 FB 中，用 **RS/SR** 标准块最清晰；在 LD 中，两种画法都常用。

---

## 关键要点

* **FB** 里避免直接把输出回馈到输入形成环路；应使用 **RS/SR 锁存功能块**：`S=On, R=Off, Q=motor`。
* **LD** 里可：

1. 用 **Off 触点**“切断自保持通路”；
2. 用 **(R) 复位线圈**直接复位 motor。
* 图右侧红字 **R := Reset** 是复位的标准缩写，上一页的 **S := Set** 是置位的标准缩写。

---

\[口语化表达] 这页是在说：电机已经做了自保持，怎么把它关掉？在功能块里，别再用输出绕回输入那种土办法了，容易出环路，直接用标准的 RS/SR 锁存块：On 接 S，Off 接 R，输出就是 motor；按停止就复位，电机停。在梯形图里有两招：第一招，用一个“Off”触点把自保持那条回路掐断，电机线圈一掉电，自保持触点也松开，电机就停了；第二招，更干脆，给 motor 来个复位线圈 `(R)`，Off 一来就把 motor 清掉。简单说：**开用 S，停用 R；或者切断自保持那条线，电机就老老实实停了。**


---

## 第 43 页

![第 43 页](Chapter 3 - Programmable Logic ___lers (slides with annotations)_assets/page-043.png)

这页是 **IEC 61131 标准功能块：双稳态（Bistables，SR 锁存器）** 的第 1 部分。主题：**把“置位自保持（Set latch）”和“复位自保持（Reset latch）”组合，做出一个带记忆、能开也能关的标准双稳态块**，输入是 **On**（启动/置位）与 **Off**（停止/复位），输出是 **motor**。

---

## 这张图在说什么？

### 1) 什么是 Bistable（双稳态）

* 双稳态就是**有两个稳定状态**（0 或 1），只有在 **On/Off 脉冲**到来时才改变状态。
* 对应 PLC 里常见的 **SR（Set/Reset）锁存块** 或 **RS**（带优先级的变体）。

### 2) 左侧黑色框：从“两个自保持”组合成一个 SR

* 用 **OR** 做“自保持”（motor 反馈回 OR，保持输出为 1）；
* 用 **AND** 与 **Off** 形成复位通路（图上 AND 输入端的小空心点表示对 Off 取反/使能条件）；
* 这就是把“**置位保持回路**”与“**复位切断回路**”组合，得到**可置位、可复位**的结构。
* 思路对，但在 FB 里直接回馈往往不安全/不推荐（上一页的原因），所以通常使用**标准 SR 功能块**来避免环路歧义。

### 3) 右侧绿色框：等价的逻辑结构（推荐表达）

* **On → AND → OR → motor**，motor 再回馈至 OR，形成**保持**；
* **Off** 进入 AND 的反相端（带小圆圈），表示 **Off=1 时禁止置位**（或触发复位逻辑）；
* **效果**：

* 来一个 **On 脉冲**：`motor` 被置位为 1，并通过 OR 的反馈保持为 1；
* 来一个 **Off 脉冲**：复位通路生效，`motor` 变为 0，保持为 0。

### 4) 下方时序波形

* 第一段 **on** 脉冲到来 → `motor` 跳到高电平并保持；
* 后面 **off** 脉冲到来 → `motor` 拉低并保持；
* 黄色圈/红圈处标注了**电平翻转**的瞬间（由 On/Off 脉冲触发）。

### 5) 实际工程要点

* **优先级**：SR/RS 一般规定 **Off（Reset）优先** 更安全（防止 On 与 Off 同时为 1 时出现不确定）；
* **FB 用法**：优先用 **IEC 61131 的 SR/RS 标准功能块**，输入 `S=On, R=Off`，输出 `Q=motor`；
* **LD 用法**：可用 **(S motor)** 与 **(R motor)** 两个线圈，或用触点切断/保持回路实现。

---

## 小结

* **Bistable = SR（Set/Reset）锁存器**：两个稳定态，On 置位，Off 复位，中间靠反馈保持。
* 右图绿色结构直观地体现了：**On 通过 AND→OR 置位并由 OR 反馈保持；Off 通过反相端阻断/复位**。
* 时序图展示了：**On 脉冲使 motor=1 并保持；Off 脉冲使 motor=0 并保持**。
* 实践中推荐用 **IEC 标准的 SR/RS 功能块**，避免手工回路带来的环路/竞态。

---

\[口语化表达] 这页就是把“能自己保持的开”和“能自己保持的关”合在一起，做成一个**开关记忆块**。On 一来，电机被置位成开，并靠反馈自己保持不松手；Off 一来，就把它复位成关，也同样保持。下面的波形就是：On 脉冲让电机从 0 变 1 并保持，Off 脉冲让它从 1 变 0 并保持。实际写程序时别自己硬绕反馈，直接用 IEC 的 **SR/RS 功能块**（S 接 On，R 接 Off，Q 接 motor），既清晰又安全，通常还给 Off（复位）更高优先级，避免 On/Off 同时来的时候出问题。


---

## 第 44 页

![第 44 页](Chapter 3 - Programmable Logic ___lers (slides with annotations)_assets/page-044.png)

这页是上一页“双稳态（Bistables）”的延续，讲的是——
**在 IEC 61131 标准中，双稳态（Bistable）如何作为标准功能块（Function Block）来实现。**

---

## 一、Bistable 标准功能块（SR / RS）

上半部分图是一个标准功能块：

```
┌───────────┐
S →──│           │──→ Q
R →──│    SR     │
└───────────┘
```

* **S（Set）**：置位输入（让输出 Q = 1）
* **R（Reset）**：复位输入（让输出 Q = 0）
* **Q**：输出（保持状态）

这就是一个标准的“**双稳态锁存器（Bistable Latch）**”，它有两个稳定状态（ON / OFF）。
在 IEC 61131 中，它可以叫：

* **SR**（Set dominant）锁存器：当 S 和 R 同时为 1 时，**S 优先**，输出 Q = 1；
* **RS**（Reset dominant）锁存器：当 S 和 R 同时为 1 时，**R 优先**，输出 Q = 0。

👉 教材中标注 “RS = Reset dominant bistable”，说明这里讲的是**复位优先**的版本。
这是工业控制中最常见、最安全的设计方式（防止冲突时电机无法停下）。

---

## 二、LD（梯形图）表示方式

下半部分展示了这个 SR 块在梯形图（LD）中的使用：

```
|--[ On ]--------------------( S motor )--|
|--[ Off ]-------------------( R motor )--|
```

* `[On]` 信号接到置位线圈 `(S motor)`：触发后 motor 被“置位”为 ON。
* `[Off]` 信号接到复位线圈 `(R motor)`：触发后 motor 被“复位”为 OFF。
* `(S)` 与 `(R)` 分别对应功能块里的 **S** 与 **R** 输入端。
* motor 会保持当前状态，直到另一端被触发改变。

---

## 三、工作原理总结

| 状态    | S（置位） | R（复位） | Q（输出）               |
| ----- | ----- | ----- | ------------------- |
| 初始    | 0     | 0     | 保持原值                |
| 启动    | 1     | 0     | 1（ON）               |
| 停止    | 0     | 1     | 0（OFF）              |
| 同时为 1 | 1     | 1     | **根据类型决定（SR 或 RS）** |

* SR 型：S 优先，输出 = 1
* RS 型：R 优先，输出 = 0（本页就是这种）

---

## 四、应用场景

这种 SR/RS 块在 PLC 里经常用来：

* 控制“**按一下开，再按一下关**”的电机或泵；
* 做**记忆逻辑**（例如：某条件满足一次就触发，不会自动恢复）；
* 防止“**按钮抖动**”或“**重复输入干扰**”导致输出闪烁。

---

## \[口语化表达]

这页讲的就是：之前我们用逻辑门拼出来的“记忆开关”其实在 PLC 里已经有现成的功能块了，叫 **SR** 或 **RS**。
上面的方框图表示：S 是“置位”，R 是“复位”，Q 是输出。区别在于如果 S 和 R 同时为真，是哪个优先——SR 是 S 优先，RS 是 R 优先，这页讲的是 R 优先，也就是“安全起见，停机信号总是优先”。
下面的梯形图就是怎么在实际程序里用的：按下 `[On]` 就给 motor 一个 `(S)`，电机启动；按下 `[Off]` 就给 motor 一个 `(R)`，电机停下。motor 会自己记住状态，不会在中间乱闪。
一句话总结：**RS 功能块就是把“开关记忆”标准化了——按下 On 开，按下 Off 关，R 优先让系统更安全。**


---

## 第 45 页

![第 45 页](Chapter 3 - Programmable Logic ___lers (slides with annotations)_assets/page-045.png)

这页继续讲 **IEC 61131 标准功能块中的双稳态（Bistables）**，重点是说明在 **逻辑网络（Networks）** 中如何实现同样的“记忆型”开关效果。
图中展示了两个逻辑网络：**Network 1** 和 **Network 2**，它们分别负责“置位（开机）”和“复位（关机）”功能。

---

## 一、Network 1：置位逻辑（Set / 开启电机）

上方的电路图：

```
On ─┐
├─ OR ─→ Motor
Motor┘
```

意思是：

* 当按下 **On** 按钮时，OR 门输出变为 1（motor 启动）；
* 同时，motor 的输出又反馈回 OR 门的另一个输入端；
* 这样，即使 On 信号消失，motor 仍保持为 1（即“自保持”）；
* 所以，这个回路的作用是：**按一次 On，电机就启动并保持运转**。

👉 这是典型的 “**自保持启动逻辑**（Set latch）”。

---

## 二、Network 2：复位逻辑（Reset / 关闭电机）

下方的电路图：

```
Off ○──┐
├─ AND ─→ Motor
Motor──┘
```

说明如下：

* Off 信号前有一个小圆圈（○），表示**逻辑取反（NOT Off）**；
* AND 门只有在 **Off = 0（即没按停止）** 且 motor = 1 时才保持输出为 1；
* 一旦 **Off = 1（按下停止键）**，反相端变为 0，AND 输出被强制清零；
* 因此，motor 变为 0，电机停止运转。

👉 这部分是 **“复位逻辑”**，保证 **Off** 信号能打断自保持回路。

---

## 三、两者如何协同（Set + Reset → Bistable）

这两张图其实就是在不同的 **逻辑网络（Networks）** 中实现的 **SR 锁存逻辑**：

| Network   | 功能    | 逻辑结构                      | 说明          |
| --------- | ----- | ------------------------- | ----------- |
| Network 1 | Set   | On OR Motor → Motor       | 置位，保持 ON 状态 |
| Network 2 | Reset | NOT Off AND Motor → Motor | 复位，关闭电机     |

组合后效果：

* **按 On → 电机启动且保持运行；**
* **按 Off → 电机停止；**
* 这两个网络一起构成了一个双稳态逻辑（Bistable）。

在很多 PLC 编程语言（比如 Function Block Diagram）中，这种逻辑可以自动被编译成一个等价的 **RS 功能块**。

---

## 四、总结重点

1. **Network 1** 用 OR 门实现“置位自保持”；
2. **Network 2** 用 AND 门和 Off 取反实现“复位断开”；
3. 两者结合 = 一个 SR（Set/Reset）逻辑；
4. 对应现实中电机控制逻辑：“启动按钮”保持运行，“停止按钮”打断运行；
5. 工程中通常用 **SR 或 RS 功能块** 实现同样效果，更直观安全。

---

\[口语化表达]
这页其实就是把“开机逻辑”和“关机逻辑”分成两个网络来写。上面的 Network 1 用 OR 门做自保持，意思是：只要你按过一次 On，motor 就被点亮，而且它自己会反馈着保持不灭。下面的 Network 2 用 AND 门加一个取反的 Off 信号——当你按下 Off 时，这个信号变成 0，把 motor 输出给掐断。两个网络合起来，就形成了一个完整的双稳态逻辑：按 On 开机、按 Off 停机，motor 会记住状态。这就是最基本的“开关记忆”控制原理。


---

## 第 46 页

![第 46 页](Chapter 3 - Programmable Logic ___lers (slides with annotations)_assets/page-046.png)

这页讲的是 **IEC 61131 标准功能块中的“边沿触发器（Edge Triggers）”**，也就是 PLC 里专门用于\*\*检测信号变化瞬间（上升沿或下降沿）\*\*的功能模块。

---

## 一、问题背景（Problem）

在很多自动化逻辑里，我们**不想检测信号“持续为 1”**，而是只想在它**发生变化的瞬间**（例如“按钮刚刚被按下”）执行一次动作。
举个例子：

* 如果一个按钮一直被按着，灯不该一直闪，而是**只在按下那一刻亮一下**。
* 这就需要检测**信号的边沿（edge）**，也就是信号从 0→1 或 1→0 的那一瞬间。

这类检测就是通过 **edge trigger（边沿触发器）** 实现的。

---

## 二、示例（Example）

图中中间的方块：

```
button → [ edge trigger ] → light
```

意思是：

* 输入是一个按钮信号（button）；
* 输出是灯（light）；
* 当检测到 button 的\*\*上升沿（从 0 变成 1）\*\*时，edge trigger 会短暂输出一个“脉冲”，
让 light 闪一下，然后输出又回到 0。

这就实现了“检测变化，而不是检测状态”。

---

## 三、功能表现（Desired function）

下面的时序图展示了实际效果：

### 蓝色线：button（输入信号）

* 当按钮被按下时，button 从 0 变为 1；
* 松开时，又从 1 变回 0；
* 每次“按下”或“松开”都产生一个变化。

### 红色线：light（输出信号）

* 每次输入信号“变化瞬间”（上升沿）时，light 会**短暂跳为高电平**；
* 即 light 输出一个很窄的脉冲（Pulse）；
* 即使 button 一直保持 1，light 也不会一直亮，只会“闪一下”。

因此：

* **Edge Trigger** 检测的是“变化的边缘”，而非信号的持续状态；
* 它的输出只是一个**瞬间脉冲**；
* 在 PLC 程序中，用于触发一次性事件，比如计数、翻转、报警、数据记录等。

---

## 四、工程中的应用场景

| 应用场景 | 说明                       |
| ---- | ------------------------ |
| 按钮输入 | 防止长按重复触发，只在“按下瞬间”执行一次    |
| 计数器  | 每检测到一次脉冲（上升沿）就 +1        |
| 事件触发 | 在信号变化时执行某段逻辑（例如上报、采样、报警） |
| 状态监控 | 检测某状态的切换而不是维持状态          |

---

## 五、总结要点

* Edge Trigger 检测信号的“边沿”（0→1 或 1→0）；
* 输出是一个短暂的“脉冲”，而非持续信号；
* 常见类型：

* **R\_TRIG**：上升沿触发（rising edge）
* **F\_TRIG**：下降沿触发（falling edge）
* 实现了**事件检测**，而非**状态保持**；
* 广泛用于**按钮检测、计数、报警**等场景。

---

\[口语化表达]
这页讲的就是：在 PLC 里，有时候我们不想一直检测“开关是开着还是关着”，而是想知道“它刚刚变的时候”。比如按钮按下去的一瞬间触发灯亮一下，而不是按钮一直按着灯就一直亮。这个就是“边沿触发器（Edge Trigger）”干的事。它会盯着输入信号的变化——当 button 从 0 跳到 1（上升沿）的时候，它输出一个很短的脉冲（light 亮一下），然后马上回到 0。下次再变化时再输出一次。总结一下：**边沿触发器用来捕捉‘变化那一刻’，不是保持状态的，常用来防止重复触发或计数一次性事件。**


---

## 第 47 页

![第 47 页](Chapter 3 - Programmable Logic ___lers (slides with annotations)_assets/page-047.png)

这页讲的是 **“边沿触发器（Edge Trigger）”在 PLC 中是怎么实现的（Realization）**，
也就是如何通过逻辑电路或梯形图来“检测信号变化的瞬间”。

---

## 一、核心思想

边沿触发的关键在于**比较当前输入信号和上一次扫描周期的旧信号（旧状态）**。

* 如果当前按钮状态是 **1（被按下）**，
* 而上一次状态是 **0（未按下）**，
→ 就说明发生了“上升沿（Rising Edge）”。

反过来，如果是从 1 → 0，则是“下降沿（Falling Edge）”。

因此，只要我们保存一个变量 `button_old`（代表上一次扫描时的按钮状态），
并把它和当前的 `button` 做逻辑运算，就能检测到边沿。

---

## 二、FB（功能块）实现方式

图中上半部分是功能块（Function Block, FB）逻辑：

```
button →──┐
│
AND ───→ light
button_old ───┘（取反输入）
```

逻辑解释：

* `button` 是当前输入；
* `button_old` 是上次循环保存的输入值；
* 取反 `NOT button_old` 表示“上次没按下”；
* 当且仅当：

* 当前 `button = 1`
* 且上次 `button_old = 0`
* → AND 输出 1，light 亮（表示检测到上升沿）

之后程序会执行：
`button_old := button`
把当前状态存起来，供下次比较。

这就是一个最基本的“上升沿检测器（Rising Edge Trigger）”。

---

## 三、LD（梯形图）实现方式

图中中间部分是对应的梯形图（LD）逻辑：

### 第一行：

```
|----[button]----[/button_old]----(light)----|
```

含义：

* `button` 是当前状态；
* `/button_old` 表示“上次状态为假”（取反触点）；
* 同时成立时点亮 `(light)`；
* 只在“0→1”变化的那一刻输出有效信号。

### 第二行：

```
|----[button]----(button_old)----|
```

这行用来**更新旧状态变量**：

* 把当前按钮状态保存到 `button_old` 中；
* 下一次循环时就能与新的输入比较。

---

## 四、标准化块符号

底部是 PLC 的标准库符号：

```
R_TRIG
```

* **R\_TRIG（Rising Trigger）**：上升沿触发；
* 输入：`CLK`（要检测的信号）；
* 输出：`Q`（当检测到上升沿时输出一个短脉冲）；
* 在图中，`button` 接到 `CLK`，`light` 接到 `Q`；
* 当检测到 `button` 从 0→1 时，`light` 输出短暂为真。

有时也有 **F\_TRIG（Falling Trigger）**，是下降沿检测。

---

## 五、总结逻辑流程

1. 当前按钮输入为 `button`；
2. 程序读取上次循环的状态 `button_old`；
3. 判断是否 `button = 1` 且 `button_old = 0`；
4. 若成立 → 输出脉冲信号（light = 1）；
5. 更新 `button_old := button`；
6. 下次循环重新比较，实现“只在变化瞬间触发”。

---

## 六、工程应用场景

* 按钮触发一次执行一条命令（而不是一直重复）；
* 检测信号变化（传感器从 OFF 到 ON 的瞬间）；
* 控制事件触发（例如开始计数、启动过程、报警）；
* 在自动化系统中广泛用于“**防抖**”和“**事件检测**”。

---

\[口语化表达]
这页讲的是边沿触发器在 PLC 里到底怎么做出来的。原理特别简单：你得知道“现在”和“上一次”按钮的状态，如果这次是 1、上次是 0，那就说明按钮刚被按下，这就是上升沿。图里的 AND 门就是把 `button` 和“上次没按下”（`NOT button_old`）一起判断，这一瞬间 light 亮一下。然后程序会更新 `button_old := button`，记住当前状态，等下次循环再比较。梯形图版也是一样的逻辑，上面一行检测变化，下面一行更新旧值。最后那个 R\_TRIG 方块是 PLC 的标准版本——只要输入信号从 0 跳到 1，它的输出就闪一下。总结一句话：**边沿触发器的核心就是“记住上一次”，只在状态变化那一刻输出脉冲。**


---

## 第 48 页

![第 48 页](Chapter 3 - Programmable Logic ___lers (slides with annotations)_assets/page-048.png)

这页介绍 **IEC 61131 标准定时器功能块**（Timers），即 PLC 里最常用的三种定时器：

* **TON (Timer ON Delay)**：通电延时接通
* **TOF (Timer OFF Delay)**：断电延时断开
* **TP (Timer Pulse)**：单稳脉冲定时器

中间的通用端口示意告诉你**三种定时器的接口都一致**：

* **IN（BOOL）**：定时器使能/触发输入
* **PT（TIME）**：预置时间 *Preset Time*（例如 `PT := T#100ms`）
* **Q（BOOL）**：定时完成输出
* **ET（TIME）**：已用时间 *Elapsed Time*（从本次定时开始走到当前的计时值）

---

## 三种定时器的行为

### 1) TON（上电延时接通）

* 当 **IN 从 FALSE → TRUE**：开始计时，**ET 从 0 往上增**。
* **ET ≥ PT** 时，**Q 置 TRUE**。
* 当 **IN 变 FALSE**：定时终止，**Q 立即变 FALSE，ET 复零**。

**用途**：输入稳定性判断、去抖、上电延时启动等。

---

### 2) TOF（断电延时断开）

* 当 **IN 为 TRUE**：**Q 保持 TRUE**。
* 当 **IN 从 TRUE → FALSE**：开始计时，**ET 从 0 往上增**；在这段延时内 **Q 仍维持 TRUE**。
* **ET ≥ PT** 后，**Q 才变 FALSE**；若计时过程中 **IN 又回 TRUE**，计时取消，**Q 继续 TRUE**，**ET 复零**。

**用途**：信号撤销后延时关断（如风扇延时散热、阀门滞后关闭）。

---

### 3) TP（单次脉冲）

* 当 **IN 出现上升沿**：**Q 立即置 TRUE**，并保持 **恰好 PT** 的时长，同时 **ET 从 0 计到 PT**。
* 脉冲期间，后续上升沿通常被忽略（实现依实现而定，但标准语义为单脉冲）。
* 脉冲结束：**Q 变 FALSE，ET 复零**或保持到实现允许的状态。

**用途**：打点脉冲、定长激励、单次触发动作。

---

## 快速对照

| 定时器 | 触发点      | 计时期间 Q      | 计满后 Q | 复位条件        |
| --- | -------- | ----------- | ----- | ----------- |
| TON | IN 从 0→1 | FALSE       | TRUE  | IN 变 0      |
| TOF | IN 从 1→0 | TRUE        | FALSE | 计满 或 IN 回 1 |
| TP  | IN 上升沿   | TRUE（固定 PT） | FALSE | 脉冲结束（或外部复位） |

`PT` 是“要等多久”，`ET` 是“已经走了多久”，`Q` 告诉你“是否到点”。

---

## 使用小贴士

* 典型写法：`TON(IN:=Start, PT:=T#3s)；IF Timer.Q THEN ...`
* 需要了解任务周期：**ET 的步进与扫描周期相关**（每扫一次增长一次）。
* 若要防抖：可用 **R\_TRIG + TON** 或直接用 TON 去抖（`IN` 稳定保持 TRUE 达到 PT 才算有效）。

---

\[口语化表达]
这页是在说：PLC 里有三只“万能闹钟”。给它一个开关 **IN** 和一个倒计时长度 **PT**，它就按不同玩法给你一个结果 **Q**，还顺带报出已经走了多久 **ET**。

* **TON**：开了开关别急，等 **PT** 时间再把 **Q** 置真，关了就立刻清零；
* **TOF**：开着时 **Q** 就真，一旦关掉，会再“拖一会儿”到 **PT** 才把 **Q** 关掉；
* **TP**：来个上升沿就给你一个“定长脉冲”，**Q** 立即为真，正好持续 **PT**，时间到自动拉回去。
一句话：**PT 是你想等多久，ET 是已经等了多久，Q 则告诉你等没等到点**。这三个组合起来，能搞定大多数“延时开、延时关、打一枪就走”的定时需求。


---

## 第 49 页

![第 49 页](Chapter 3 - Programmable Logic ___lers (slides with annotations)_assets/page-049.png)

这页讲的是 **TON（Timer On Delay，上电延时定时器）** 的**时序图（Timing Diagram）**，也就是它在时间上的输入输出关系。图右上方的德语“**Einschaltverzögerung**”意思就是“上电延时”。

---

## 一、TON 定时器的工作原理回顾

TON 是“延时接通型”定时器：

* 当输入信号 `IN` 变为 TRUE（1）时，**不会立刻输出**。
* 而是等待预设时间 `PT`（Preset Time，比如 100ms）之后，输出 `Q` 才变为 TRUE。
* 如果在这段时间里 `IN` 又变回 FALSE，计时中断、清零，输出 `Q` 不会变化为 TRUE。

---

## 二、时序图详解

图中共有三条波形：

1. **IN（输入信号）**
表示外部触发信号，比如按钮按下。
当它从低变高时，TON 开始计时；当它变低时，计时终止。

2. **Q（输出信号）**
只有当 IN 连续保持为 TRUE 超过设定时间 `PT` 时，Q 才变为 TRUE。
一旦 IN 变回 FALSE，Q 立即变为 FALSE，不再延迟。
所以可以看到 Q 的变化比 IN **慢了一拍**，有“延时接通”的效果。

3. **ET（Elapsed Time，已用时间）**
当 IN=TRUE 时，ET 从 0 开始增加；
当 ET 达到 PT，Q 置为 TRUE。
如果 IN 提前变 FALSE，ET 会立刻清零（不会继续累积）。

在图里：

* 第一次 IN 上升后，ET 逐渐爬升到 PT，Q 才变真；
* 第二次 IN 信号持续时间太短，没等到 PT 就掉下来了 → ET 清零，Q 没反应；
* 后面一次持续足够长，ET 再次达到 PT → Q 变真。

---

## 三、总结要点

| 信号     | 行为描述                           |
| ------ | ------------------------------ |
| **IN** | 控制定时器是否启动                      |
| **ET** | 从 0 开始计时，最大不超过 PT              |
| **Q**  | 当 ET ≥ PT 且 IN 为 TRUE 时输出 TRUE |
| **复位** | 当 IN 变 FALSE 时，ET 清零，Q 变 FALSE |

**TON 实现了“延时接通”功能**：
输入信号持续时间要“撑过”预设时间 PT，输出才会激活。

---

## 四、应用场景举例

* 设备启动延时（例如启动泵时先等几百毫秒）
* 消抖滤波（只有信号稳定一段时间才算有效）
* 电机软启动逻辑
* 自动化中防止误触发或瞬时干扰

---

\[口语化表达]
这页图就是在讲“TON 定时器是怎么在时间上反应的”。
它的意思是：当输入信号刚变真时，它不会立刻输出，而是先默默数时间（比如 100ms），等时间到了才把输出 `Q` 打开。如果在这段等待期间输入又掉回去了，那它会直接清零，不算数。图里的 ET 曲线就是在数这个时间。当输入一直保持真到 PT，输出才变真；如果输入太短，输出就完全不会动作。
一句话总结：**TON 就像个“耐心检测器”——信号得稳稳持续够久，输出才响应。**


---

## 第 50 页

![第 50 页](Chapter 3 - Programmable Logic ___lers (slides with annotations)_assets/page-050.png)

这页讲的是 **TOF（Timer Off Delay）——断电延时定时器** 的**时序图（Timing Diagram）**。
标题右上角的德语“**Ausschaltverzögerung**”就是“**断电延时**”的意思。

---

## 一、TOF 定时器的功能概念

TOF 是 “延时断开型定时器”：

* 当输入信号 `IN = TRUE` 时，**输出 `Q` 立刻为 TRUE**（无延时）。
* 当输入 `IN` 从 TRUE → FALSE（信号关闭）时，定时器才开始计时。
* 在这段延时时间 `PT` 内，**输出 Q 依然保持 TRUE**。
* 等 `ET ≥ PT` 后，**Q 才变为 FALSE**。
* 如果计时期间 `IN` 又重新变为 TRUE，定时器立刻复位（停止计时，`Q` 继续为 TRUE）。

所以，TOF 的作用就是：
**输入信号消失后，输出还能延迟一会儿再关闭。**

---

## 二、图中信号解释

图里三条波形依次是：

### 1. IN（输入信号）

代表控制输入。
当它变高（TRUE）时，定时器输出立即打开；
当它变低（FALSE）时，TOF 开始计时。

---

### 2. Q（输出信号）

* 当 IN 变高时，Q 马上为 TRUE（没有延时）。
* 当 IN 变低时，Q **不会立刻关闭**，而是保持 TRUE 一段时间（PT）；
等计时结束后，Q 才变为 FALSE。
* 若在这段时间里 IN 又变高，Q 立即恢复稳定的 TRUE 状态（不继续倒计时）。

---

### 3. ET（Elapsed Time，已用时间）

* 只有当 IN 从 TRUE → FALSE 时，ET 才从 0 开始增加；
* 当 ET 达到预设时间 PT 时，Q 才变为 FALSE；
* 如果 IN 又变回 TRUE，ET 立刻清零，定时取消。

---

## 三、图形流程解释

* 第一次 IN 上升 → Q 立即变真。
* 当 IN 降为 FALSE 时，Q 暂时仍为 TRUE（延时关断），此时 ET 从 0 开始计时。
* 等到 ET 达到 PT，Q 才变 FALSE。
* 第二次 IN 脉冲太短，在计时未完成前又恢复 TRUE → 定时中断，Q 保持 TRUE。
* 整体过程反复说明：Q 会**在输入关闭后“拖一段时间”再灭**。

---

## 四、实际应用场景

TOF 通常用于**信号撤销后延迟关闭的控制逻辑**，例如：

* 电机停机后延时关闭冷却风扇。
* 传送带停下后延迟清空物料。
* 照明、报警延迟关闭。

---

## 五、总结要点

| 项目     | 行为                          |
| ------ | --------------------------- |
| **IN** | 控制输入信号                      |
| **Q**  | 输出信号，IN为TRUE时立即为真，IN变假后延时关闭 |
| **ET** | 在IN变假后计时，达到PT才让Q变假          |
| **复位** | 若IN在延时中再次变真，ET清零、Q继续保持真     |

TOF = **延时关闭（信号消失后“再撑一会儿”）**

---

\[口语化表达]
这页在讲 TOF 定时器，也就是“信号关了之后再等一会儿才真的关掉”。
图里你能看到：一旦输入 IN 打开，输出 Q 马上亮；可当 IN 一关，Q 还不立刻灭，而是再撑住一段时间 PT，这段时间里 ET 就在慢慢数数，等数够了才把 Q 关掉。
如果这时候 IN 又回来了，那计时马上清零，Q 继续保持亮着。
一句话总结：**TOF 就像个“迟钝的开关”——输入关了，它还会再坚持一下才松手。**


---

## 第 51 页

![第 51 页](Chapter 3 - Programmable Logic ___lers (slides with annotations)_assets/page-051.png)

这页讲的是 **TP（Timer Pulse）单稳脉冲定时器** 的**时序图（Timing Diagram）**。
TP 的全称是 *Timer Pulse*，即“脉冲定时器”或“单次定时器”。它的特点是：**输入有上升沿 → 输出产生一个固定长度的脉冲信号**。

---

## 一、TP 定时器的基本原理

TP 定时器只在\*\*输入信号的上升沿（从 0 → 1）\*\*时起作用：

* 当检测到上升沿时，**输出 Q 立即置 TRUE**。
* 同时开始计时，**ET 从 0 计数到预设时间 PT**。
* 当 **ET = PT** 时，**Q 自动复位为 FALSE**，计时结束。
* 如果在计时过程中输入 IN 又变为 TRUE 或 FALSE，都不影响当前脉冲（即“不会重触发”，除非定时周期结束）。

换句话说：
🔹 TP = “检测上升沿 → 输出一个固定长度的高电平信号”。

---

## 二、图中信号解释

图中三条曲线分别代表：

### 1. IN（输入信号）

表示外部触发信号，比如按钮脉冲或传感器触发。

* 当 IN 上升沿出现（从 0 → 1）时，定时器开始工作。
* 即使 IN 继续保持 1，定时器也只发出固定长度的输出脉冲。
* 如果 IN 频繁抖动，上升沿都会触发一个新脉冲（但每次脉冲都独立）。

---

### 2. Q（输出信号）

* 在检测到 IN 的上升沿时，Q 立刻变为 TRUE。
* Q 会保持 TRUE 一段固定的时间 PT，不受输入变化影响。
* 当 PT 到时，Q 自动变为 FALSE。
* 若输入在 Q=TRUE 期间又出现新的上升沿，大多数实现中是**忽略**的（即非可重触发型 TP）。

---

### 3. ET（Elapsed Time，已用时间）

* 从上升沿出现的瞬间开始计时。
* 计时过程持续 PT 时间。
* 达到 PT 后，ET 停止并清零（或等待下次触发）。

---

## 三、图形分析

在图里你能看到：

* 第一次 IN 上升沿 → Q 立刻跳高，并持续一个 PT 长度，然后归零。
* 之后每次 IN 又有新的上升沿 → 都触发一次新的“短脉冲”输出。
* ET 每次都从 0 开始爬升到 PT，然后掉回 0，准备下次。

**这说明 TP 只对“上升沿”有反应，并产生固定长度的输出脉冲。**

---

## 四、实际应用场景

TP 定时器通常用于：

* 产生固定长度的输出信号（例如“触发信号保持 1 秒”）
* 按钮去抖动或单次动作触发
* 自动复位、脉冲打点
* 延时触发报警、控制信号触发脉冲

---

## 五、总结要点

| 参数       | 含义                |
| -------- | ----------------- |
| **IN**   | 上升沿触发输入           |
| **Q**    | 输出脉冲信号（持续 PT 时间）  |
| **ET**   | 已经计时的时间（从 0 → PT） |
| **PT**   | 预设脉冲长度            |
| **触发条件** | IN 的上升沿           |

**TP 定时器实现的是“固定时间输出脉冲”功能。**

---

\[口语化表达]
这一页讲的是 TP 定时器，也就是“脉冲型定时器”。
它的意思是：当输入信号从 0 变成 1 的那一瞬间，TP 马上输出一个高电平脉冲，持续的时间刚好是预设的 PT。无论输入之后怎么变化，输出脉冲时间都不会被打断。
你可以把它想成一个“自动定时的开关”——有人按一下按钮，它就亮 1 秒（或者你设的时间），然后自己灭掉，不需要再控制。
一句话总结：**TP 定时器就是“按一下出一个固定时间的信号”——只管触发，不管维持。**


---

## 第 52 页

![第 52 页](Chapter 3 - Programmable Logic ___lers (slides with annotations)_assets/page-052.png)

这页讲的是 **IEC 61131 编程语言中的 Instruction List（指令表语言）**，也叫 **Anweisungsliste（AWL）**。
这是一种**文本型编程语言**，非常类似于**汇编语言（Assembly language）**，用一条一条的指令来描述 PLC 程序的逻辑。

---

## 一、Instruction List（指令表）的特点

* **文本形式（Textual）**：
与梯形图（LD）或功能块图（FBD）不同，Instruction List 是纯文字形式，用类似汇编的语句编程。

* **结构类似汇编语言**：
每一条语句（指令）都有三个部分：

```
(label:)   operator   operand
```

* **label（标签）**：可选，用于跳转或标识位置。
* **operator（操作码）**：例如 `AND`、`OR`、`LD`（load）等逻辑操作。
* **operand（操作数）**：被操作的变量或输入，例如 `sensor1`、`motor` 等。

---

## 二、示例解释

在图中给出的例子：

| label    | operator | operand |
| -------- | -------- | ------- |
| e.g. END | AND      | sensor1 |

意思是：

> 把当前累加器（Current Result）里的值与 `sensor1` 的输入信号进行逻辑与（AND）运算。

因此指令执行结果相当于：

```
CR := CR AND sensor1
```

CR（Current Result）表示当前逻辑运算的中间结果。
如果下一条语句是 `OR sensor2`，那就继续：

```
CR := (CR AND sensor1) OR sensor2
```

就像汇编一样，运算是一步一步在累加器里完成的。

---

## 三、体系结构特点

* **单寄存器结构（One-register or accumulator architecture）**
Instruction List 是基于“累加器”的结构，所有的运算结果都暂存在一个寄存器里。

* **累加器（Accumulator）= CR（Current Result）**
CR 表示“当前结果”，也就是上一步运算的输出。
在德语中叫 **Aktuelles Ergebnis (AE)**。
每次新指令都会基于当前 CR 继续计算。

---

## 四、优缺点

**优点：**

* 程序执行速度快，逻辑表达清晰。
* 适合对 PLC 内部逻辑进行底层控制。

**缺点：**

* 可读性较差，不直观。
* 难以维护，尤其对于非程序员或电气工程师。

---

## 五、小结

Instruction List（IL/AWL）是一种非常接近汇编的 PLC 编程语言，
每一条语句都明确指定“操作符 + 操作数”，
计算都通过一个累加器（CR）进行，逐步更新“当前结果（Current Result）”。

---

\[口语化表达]
这页讲的就是 PLC 里最像“汇编语言”的写法——指令表（Instruction List）。
它不是用图形画逻辑，而是写一行一行的指令，比如 “AND sensor1” 就是让当前的计算结果再跟传感器1做一次逻辑与。
所有的计算都存在一个叫 CR 的地方（就像 CPU 里的寄存器），每条指令都在这个基础上继续算。
所以整段逻辑其实就是：CR = CR AND sensor1 OR sensor2 这样不断更新的过程。
一句话总结：**Instruction List 就像 PLC 的汇编语言，用一条条文字指令操作一个“当前结果”寄存器来做逻辑计算。**


---

## 第 53 页

![第 53 页](Chapter 3 - Programmable Logic ___lers (slides with annotations)_assets/page-053.png)

这页是对上一页 **Instruction List（指令表语言）** 的进一步讲解，
主要介绍了它的**基本操作指令（Basic Operators）**，
即：`LD`、`AND`、`OR`（以及可选的 `XOR`）。

这些指令是 PLC 指令表（AWL / IL）里逻辑运算的最基础组成部分。

---

## 一、LD（Load）——载入

**语法：**

```
LD X
```

**意思：**
把操作数 `X` 的值载入当前结果寄存器 `CR` 中。

**表达式：**

```
CR := X
```

**作用：**
它是逻辑链的起点，代表“开始计算，把 X 的状态放进 CR”。
后续的 `AND`、`OR` 运算都基于这个初始值进行。

---

## 二、AND（逻辑与）

**语法：**

```
AND X
```

**意思：**
把当前结果 `CR` 与变量 `X` 进行逻辑与运算。

**表达式：**

```
CR := CR ∧ X
```

**解释：**

* 如果之前 `CR` 是 TRUE，且 `X` 也为 TRUE，结果仍为 TRUE；
* 否则为 FALSE。

这就相当于在梯形图中两个条件串联的逻辑。

---

## 三、OR（逻辑或）

**语法：**

```
OR X
```

**意思：**
把当前结果 `CR` 与变量 `X` 进行逻辑或运算。

**表达式：**

```
CR := CR ∨ X
```

**解释：**

* 如果 `CR` 或 `X` 任一为 TRUE，结果为 TRUE。
* 逻辑等价于梯形图中的“并联”连接。

---

## 四、XOR（异或）

在底部标注的 “Also: XOR (exclusive OR)” 表示还有一个**异或操作**。

**语法：**

```
XOR X
```

**意思：**
如果 `CR` 与 `X` 的值不同，则结果为 TRUE；
若相同（都 TRUE 或都 FALSE），则结果为 FALSE。

**表达式：**

```
CR := CR ⊕ X
```

---

## 五、逻辑结构总结

所有指令都基于一个“累加器寄存器”（CR = Current Result）。
每条指令都会更新 CR 的值，供下一条指令继续使用。
执行过程是顺序的：

```
LD A
AND B
OR C
```

最终结果相当于：

```
CR = (A ∧ B) ∨ C
```

---

## 六、图中逻辑关系说明

图右边用方框表示：

* 每个方框代表逻辑运算单元。
* 输入是 CR 与新变量 X，输出更新后的 CR。
所以整个执行链就像流水线一样，结果不断传递和更新。

---

## 七、总结要点

| 指令      | 含义 | 运算表达式        | 对应逻辑 |
| ------- | -- | ------------ | ---- |
| `LD X`  | 载入 | CR := X      | 起点   |
| `AND X` | 与  | CR := CR ∧ X | 串联逻辑 |
| `OR X`  | 或  | CR := CR ∨ X | 并联逻辑 |
| `XOR X` | 异或 | CR := CR ⊕ X | 不同为真 |

这些操作都是 PLC 中最基础的逻辑指令，
几乎所有复杂程序都由它们组合而成。

---

\[口语化表达]
这一页讲的是 PLC 指令表语言里的最基本逻辑操作。
它就像用文字写的“与、或、非”电路：
`LD` 就是把信号装进去当起点，
`AND` 就是把当前结果和新信号做“并且”，
`OR` 就是做“或者”，
`XOR` 就是“两个不一样才为真”。
所有这些运算都在一个寄存器里滚动进行，每条指令都会更新当前结果。
一句话总结：**这页教你怎么用最原始的指令写出“逻辑门”的效果，用文字实现梯形图的逻辑。**


---

## 第 54 页

![第 54 页](Chapter 3 - Programmable Logic ___lers (slides with annotations)_assets/page-054.png)

这页说明的是 **IEC 61131 指令表（Instruction List / AWL）里“带取反”的基本逻辑指令**，也就是把操作数取反后再参与运算。指令仍然围绕“当前结果寄存器” **CR (Current Result)** 逐步更新。

---

## 三条带取反的基础指令

1. **`LDN X`** — *Load Not*

* 含义：把 **X 取反** 后装载到 CR。
* 公式：**CR := ¬X**
* 作用：作为一段逻辑链的起点，但以 **X 的否定**作为初值。
* 类比：梯形图里的**常闭触点**（“X 为 0 才导通”）。

2. **`ANDN X`** — *AND Not*

* 含义：把 **CR 与 ¬X** 做与运算。
* 公式：**CR := CR ∧ ¬X**
* 用途：要求 X 为 **0** 时条件才成立（对 X 取反再串联）。

3. **`ORN X`** — *OR Not*

* 含义：把 **CR 与 ¬X** 做或运算。
* 公式：**CR := CR ∨ ¬X**
* 用途：只要 “当前已经真” 或 “X 为假” 其一满足，结果就为真。

> 注意：取反的是**操作数 X**，不是 CR。先有 `LD/LDN` 再接 `AND/ANDN/OR/ORN` 才有意义。

---

## 小示例：把逻辑表达式翻成指令表

目标：**(¬A ∧ B) ∨ ¬C**

```il
LDN A       ; CR := ¬A
AND  B      ; CR := (¬A) ∧ B
ORN  C      ; CR := [(¬A) ∧ B] ∨ (¬C)
```

等价的梯形图含义：A 用常闭，B 用常开，与后再与 “C 的常闭” 做并。

---

## 实战提示

* **顺序即优先级**：IL 从上到下更新 CR，没有括号，靠语句顺序体现组合逻辑。
* **易读性**：带 N（Not）的助记符与“常闭触点”思维一致，读图/调试更直观。
* 不同厂商可能存在细微命名差异（如 `AN`/`ONA` 等），但语义一致。

---

\[口语化表达]
这一页就是教你三招“带否定”的指令：`LDN` 把 **X 取反**后作为起点，`ANDN` 是跟 **非 X** 做“并且”，`ORN` 是跟 **非 X** 做“或者”。它们都在那个“当前结果 CR”上一步步叠加。想象成梯形图：带 N 的就像**常闭触点**。比如要算 `(非A 且 B) 或 非C`，就写：`LDN A`、`AND B`、`ORN C`。一句话：**把要否定的量写成带 N 的指令，就能直接在指令表里实现“常闭”的逻辑。**


---

## 第 55 页

![第 55 页](Chapter 3 - Programmable Logic ___lers (slides with annotations)_assets/page-055.png)

这页介绍的是 **IEC 61131 指令表（Instruction List / AWL）里的“数学/比较类基础指令”**，它们和逻辑指令一样，都围绕“当前结果寄存器” **CR（Current Result）** 工作，但这里的 CR 既可能当作**参与比较/运算的数值**，也可能被\*\*比较结果（布尔 1/0）\*\*覆盖。

---

## 1) 比较指令（把比较结果写回 CR，结果为 1 或 0）

> 先用 `LD/LDN/…` 把一个数值装进 CR，再用这些比较指令和操作数 `X` 比。

* **`GT X`**（Greater-Than，大于）
**语义：** 比较 `CR > X`
**结果：** 若成立，**CR := 1**；否则 **CR := 0**。
**用途：** 数值上阈判断，如温度是否超过上限。

* **`EQ X`**（Equal，等于）
**语义：** 比较 `CR = X`
**结果：** 成立→ **CR := 1**；不成立→ **CR := 0**。
**用途：** 计数到点、状态码匹配等。

> 幻灯底部还提到同类运算：
> **`LT`**（小于）、**`GE`**（≥）、**`LE`**（≤）、**`NE`**（≠）
> 它们的行为相同：比较后把 **1/0** 写回 CR。

---

## 2) 算术/取模指令（把数值运算结果写回 CR）

* **`MOD X`**（Modulo，取模）
**语义：** **CR := CR mod X**（余数）
**用途：** 周期计数、分组取余（如每 N 次触发一次）。

> 幻灯底部还列出常见算术：
> **`ADD X`**（加）、**`SUB X`**（减）、**`MUL X`**（乘）、**`DIV X`**（除）。
> 这些都会把**数值结果**写回 CR，供后续继续算或再比较。

---

## 典型用法小例

**需求：** 当计数值 `cnt` 大于 100 时置位报警。

```il
LD   cnt     ; CR := cnt
GT   100     ; CR := (cnt > 100) ? 1 : 0
; 此时 CR=1/0，可直接用于后续 AND/OR 或输出
```

**需求：** 每 5 次到达一次“对齐刻”。

```il
LD   cnt     ; CR := cnt
MOD  5       ; CR := cnt mod 5
EQ   0       ; CR := (CR == 0) ? 1 : 0   ; 每逢 5 的倍数为真
```

---

## 实战提示

* **流程是顺序的**：先 `LD` 值到 CR，再做算术或比较；比较会把 CR 变成布尔 1/0。
* **数值/布尔切换**：算术 → CR 为数值；比较 → CR 变布尔。后续指令要考虑类型语义。
* **与逻辑联动**：比较得到的 1/0 可直接接 `AND/OR/…` 组合复杂条件。

---

\[口语化表达]
这一页说的是“怎么在指令表里做数值比较和运算”。先把一个数装进 CR，然后用 `GT/EQ/LT/GE/LE/NE` 这些比较指令和 X 去比，大于/等于就把 CR 变成 1，否则变 0；想做算术就用 `ADD/SUB/MUL/DIV/MOD`，结果继续写回 CR。比如我先 `LD cnt`，再 `GT 100`，CR 就是“cnt 是否大于 100”的真假；或者 `MOD 5` 再 `EQ 0`，就能判断“是不是 5 的倍数”。一句话：**先把数值装进 CR，再比较或运算；比较得到 1/0，运算得到数值，后面随你接逻辑或继续算。**


---

## 第 56 页

![第 56 页](Chapter 3 - Programmable Logic ___lers (slides with annotations)_assets/page-056.png)

已思考


---

## 第 57 页

![第 57 页](Chapter 3 - Programmable Logic ___lers (slides with annotations)_assets/page-057.png)

这页讲的是 **IEC 61131 指令表（Instruction List, 简称 IL）中的“跳转（GOTO）指令”**，也就是控制程序执行流程的语句，用来改变执行顺序，不再按从上到下的顺序执行，而是跳到指定的标号（label）。

---

## 一、主要三种跳转指令

### 1️⃣ `JMP label` —— 无条件跳转（Jump）

* **含义**：程序直接跳转到 `label` 指定的行，不考虑任何条件。
* **作用**：相当于汇编语言中的 **GOTO**，用于循环、分支、提前退出等。
* **例子：**

```il
JMP  CHECK
...
CHECK: LD X
```

---

### 2️⃣ `JMPC label` —— 条件跳转（Jump Conditionally）

* **条件**：只有当 **CR = 1（当前结果为真）** 时才跳转。
* **公式理解**：如果逻辑条件成立（即 CR 为真），程序执行跳转，否则继续往下执行。
* **用途**：在条件判断、分支逻辑中使用，比如当某个传感器激活时执行某段代码。
* **例子：**

```il
LD  sensor1
JMPC  ALARM
```

---

### 3️⃣ `JMPCN label` —— 条件取反跳转（Jump Conditionally Negated）

* **条件**：只有当 **CR = 0（当前结果为假）** 时才跳转。
* **相当于** “如果条件不成立，就跳”。
* **用途**：做与 `JMPC` 相反的逻辑控制。
* **例子：**

```il
LD  button
JMPCN  WAIT
```

---

## 二、其他跳转相关指令

* **`RET` / `RETC` / `RETCN`**：
这些是\*\*返回（Return）\*\*类指令，意味着“跳转到程序结尾”或返回上一级（如子程序）。

* `RET`：无条件返回
* `RETC`：CR = 1 时返回
* `RETCN`：CR = 0 时返回

---

## 三、逻辑关系总结表

| 指令            | 条件     | 动作       |
| ------------- | ------ | -------- |
| `JMP label`   | 无条件    | 跳到 label |
| `JMPC label`  | CR = 1 | 跳到 label |
| `JMPCN label` | CR = 0 | 跳到 label |

---

## 四、应用举例

比如写一个有条件报警程序：

```il
LD   temperature
GT   80
JMPC ALARM
; 若温度<=80，跳转不会执行，继续正常运行
...
ALARM: ST alarm_output
```

这段意思是：如果温度大于 80（CR=1），就跳转到 ALARM 去执行报警；否则继续往下。

---

\[口语化表达]
这页讲的是“跳转指令”，就是程序怎么不按顺序走而跳到别的地方。`JMP` 是**直接跳**，不看条件；`JMPC` 是**当条件为真（CR=1）才跳**；`JMPCN` 则反过来，**当条件为假（CR=0）才跳**。另外还有 `RET` 一类是“跳到程序结尾”的返回指令。简单说：**`JMP` 是无脑跳，`JMPC` 是真才跳，`JMPCN` 是假才跳。**


---

## 第 58 页

![第 58 页](Chapter 3 - Programmable Logic ___lers (slides with annotations)_assets/page-058.png)

这页主要讲的是 **IEC 61131 中“指令表语言”（Instruction List, 简称 IL）里的逻辑操作与变量声明**，展示了逻辑语句如何在 IL 语法中表达，以及输入输出变量的定义方式。

---

## 一、IL中的逻辑运算表示方式

在 IEC 61131 的指令表语言（类似汇编语言）中，逻辑操作不是用 “∧”、“∨” 这种符号，而是通过一系列简单的**操作指令**来实现。

### 1️⃣ 与运算（AND）

公式：

$$
z := x ∧ y
$$

在 IL 中的写法：

```il
LD  X      ; 将 X 的值载入当前结果寄存器 CR
AND Y      ; CR := CR ∧ Y
ST  Z      ; 把结果 CR 存储到 Z
```

**含义：** 当 X 与 Y 都为 TRUE 时，Z 才为 TRUE。

---

### 2️⃣ 或运算（OR / ORN）

公式：

$$
z := x ∨ y
$$

在 IL 中的写法：

```il
LD  X
OR  Y
ST  Z
```

如果是取反或（例如 y 为非）：

```il
LD  X
ORN Y
ST  Z
```

**含义：** OR 表示“或”，ORN 表示“或上一个取反的输入”。
举例：`ORN Y` 相当于 “x 或 非y”。

---

### 3️⃣ 加法运算（ADD）

公式：

$$
z := x + y
$$

在 IL 中的写法：

```il
LD  X
ADD Y
ST  Z
```

**含义：** 先把 X 载入寄存器，再加上 Y，然后存到 Z。
这个结构不仅用于数字计算，也可以用于定时、计数等逻辑扩展。

---

## 二、变量声明（Variable Declaration）

PLC 程序的 IL 段需要明确定义输入、输出、和内部变量。
声明格式与结构化语言（ST）类似：

### ✅ 输入变量

```il
VAR_INPUT
X: BOOL;
END_VAR
```

→ 定义 X 为布尔输入（逻辑信号）。

---

### ✅ 输出变量

```il
VAR_OUTPUT
Y: BOOL := TRUE;
END_VAR
```

→ 定义输出 Y，类型为布尔型，并给一个初始值 TRUE。

---

### ✅ 内部变量

```il
VAR
Internal: BOOL := TRUE;
END_VAR
```

→ 定义程序块内部使用的变量 Internal（不与外界直接交互）。

---

## 三、综合逻辑示例

假设我们要实现：

$$
z = x ∧ (¬y)
$$

则对应的 IL 代码如下：

```il
LD   X
ANDN Y
ST   Z
```

意思是：

1. 载入 X；
2. 与 “非Y” 进行逻辑与；
3. 把结果存入 Z。

---

\[口语化表达]
这一页就是在教你怎么用“指令表”的写法来实现逻辑运算。比如 `LD X` 是把 X 读进来，`AND Y` 是跟 Y 做与运算，`ST Z` 就是把结果存到 Z。想做“或”就用 `OR`，“或非”用 `ORN`，想加数字就用 `ADD`。另外，程序里要先声明变量：输入的用 `VAR_INPUT`，输出的用 `VAR_OUTPUT`，中间用的临时变量放在 `VAR` 里。总结一句话：**IL 就像汇编一样，用简短指令一步步实现逻辑计算，先载入、再运算、最后存储。**


---

## 第 59 页

![第 59 页](Chapter 3 - Programmable Logic ___lers (slides with annotations)_assets/page-059.png)

这页给出一个 **IL（Instruction List，指令表）实现布尔表达式** 的示例：
目标公式：**$f := a \land (b \lor \lnot c)$**。

---

## 写法一（顺序式，利用 ORN 取反“或”）

```
LD   b        ; CR := b
ORN  c        ; CR := b OR (NOT c)
AND  a        ; CR := a AND (b OR NOT c)
ST   f        ; f  := CR
```

* **LD b**：把 `b` 装入当前结果寄存器 **CR**。
* **ORN c**：把 **CR 与 非 c** 做“或” → 实现 $b \lor \lnot c$。
* **AND a**：再与 `a` 相与 → 得到 $a \land (b \lor \lnot c)$。
* **ST f**：结果存到 `f`。

---

## 写法二（带括号的块式，与目标表达式更直观）

```
LD   a        ; CR := a
AND( b        ; CR := a AND ( ...  开始一个AND块
ORN  c        ;      (b OR NOT c)
)             ; ) 结束AND块，CR := a AND (b OR NOT c)
ST   f        ; f := CR
```

* 这里用 **`AND(` … `)`** 表示一次“与”运算的**分组**（括号内先算 `b OR NOT c`），最后与外面的 `a` 相与。
* 两种写法计算结果完全相同，选哪种主要看可读性与你所在平台对括号块的支持习惯。

---

### 关键点回顾

* **CR（Current Result）** 是 IL 连续运算的核心寄存器；每条指令都会读/写它。
* **ORN X** 表示“与 **NOT X** 做 OR”。
* **AND( … )** / **OR( … )** 这类块式写法用于**分组**，更贴近原始数学表达式。

---

\[口语化表达]
这页就是教你怎么把 **f = a 且 (b 或 非 c)** 用指令表写出来。最直接的写法是：先 `LD b`，再 `ORN c`（就是 b 或 非 c），然后 `AND a`，最后 `ST f` 存起来。也可以更直观地用括号块：先 `LD a`，开个 `AND(` 块，把 `b` 跟 `ORN c` 先算完，再用 `)` 收尾，最后 `ST f`。两种写法结果一样，一个顺着 CR 往下做，一个用括号让结构更清楚。


---

## 第 60 页

![第 60 页](Chapter 3 - Programmable Logic ___lers (slides with annotations)_assets/page-060.png)

这页是 **IEC 61131 指令表（IL）里调用“定时器功能块”的三个写法示例**。
功能块实例叫 **`Zeit1`**（德语 *Zeit* = 时间），用的是 **TON** 型定时器（“通电延时”）。它的典型端口是：

* **IN**：使能输入（布尔）
* **PT**：预置时间（`t#500ms` 这样的时间常量）
* **Q**：到时输出（布尔）
* **ET**：已计时间（实际经过时间）

表格分三列：**方法1 / 方法2 / 方法3**；又按三行组织：参数提供 → 调用 → 读取输出。

---

## 方法 1：在调用时用“具名关联”一次性传参

**参数 + 调用（合在一起）**

```il
CAL  Zeit1(
IN := Frei,        ; 使能信号 Frei
PT := t#500ms,     ; 预置 500ms
Q  => Aus,         ; 输出 Q 赋给变量 Aus
ET => Wert         ; 输出 ET 赋给变量 Wert
)
```

* `CAL Zeit1(...)`：调用功能块 `Zeit1`。
* `:=` 是**输入**赋值（把右侧喂给端口）。
* `=>` 是**输出**映射（把端口赋给右侧变量）。
* 这样写**最直观**，一条调用语句里把输入/输出都接好。

---

## 方法 2：先给实例的输入成员赋值，再调用，最后读出输出

**参数提供**

```il
LD  t#500ms
ST  Zeit1.PT     ; 设置预置时间

LD  Frei
ST  Zeit1.IN     ; 设置使能
```

**调用**

```il
CAL Zeit1        ; 执行定时器一次扫描
```

**读取输出**

```il
LD  Zeit1.Q
ST  Aus          ; Q -> Aus

LD  Zeit1.ET
ST  Wert         ; ET -> Wert
```

* 思路就是：**成员赋值 → 调用 → 读成员**。
* 这种写法更贴近“面向对象”：把 `Zeit1` 看作一个带字段（`IN/PT/Q/ET`）的实例。

---

## 方法 3：用“栈/累加器 + 端口指令”逐口传参

**参数提供（把值装载后，写入端口）**

```il
LD  t#500ms
PT  Zeit1        ; 把累加器的时间写到 Zeit1.PT

LD  Frei
IN  Zeit1        ; 把使能写到 Zeit1.IN，并触发本次执行
```

* 这里 `PT Zeit1` / `IN Zeit1` 这种写法，是某些 IL 方言提供的**端口专用指令**：
先 `LD` 值，再用端口名（`PT`、`IN`）把值送进对应的端口。
* 表里没有再展示读取，但与方法2一样，你可随后：

```il
LD  Zeit1.Q   ST Aus
LD  Zeit1.ET  ST Wert
```

---

## 什么时候用哪种？

* **方法1（具名调用）**：最清晰、易读、易审查，推荐做标准写法。
* **方法2（成员写读）**：当你已经在别处分步准备好信号，或需要在多处复用调用时，结构更灵活。
* **方法3（端口指令）**：IL 风格更“精简/底层”，在资源受限或遵循既有规范时常见（但可读性略差）。

---

### 截图中的德语词对照

* *Methode*：方法
* *Parameterversorgung*：参数提供
* *Aufruf*：调用
* *Auswertung der Ausgangsparameter*：输出参数的读取/评估
* *Frei*：一个布尔输入变量名（自由/空闲）
* *Aus*：输出变量名（关/输出）
* *Wert*：数值变量名（值）

---

\[口语化表达]
这页在说：**同一个 TON 定时器，IL 可以有三种“喂参数+调用+取结果”的写法**。最简单的是方法1，一句 `CAL Zeit1(...)` 把 `IN:=Frei`、`PT:=t#500ms`、`Q=>Aus`、`ET=>Wert` 都接好；方法2是先给 `Zeit1.PT`、`Zeit1.IN` 赋值，再 `CAL Zeit1`，最后读 `Zeit1.Q/ET` 存到 `Aus/Wert`；方法3则是先 `LD` 一个值，再用 `PT Zeit1`、`IN Zeit1` 这样的端口指令把值塞进对应端口（相当于一步把值写进去并触发），之后同样可以读 `Q/ET`。一句话：**方法1直观、方法2分步清晰、方法3最“IL味”，你按项目风格选就行**。


---

## 第 61 页

![第 61 页](Chapter 3 - Programmable Logic ___lers (slides with annotations)_assets/page-061.png)

这页讲的是：在 **IEC 61131 指令表（IL）语言**中，如何用指令实现**双稳态电路（Bistables）**，也就是常说的 **RS 触发器** 和 **SR 触发器**。

---

## 一、什么是 Bistable（双稳态）

双稳态（Bistable）是一种**有两个稳定状态**的逻辑结构：

* 可以被“设定（Set）”成 1；
* 也可以被“复位（Reset）”成 0；
除非再次触发，否则状态会保持不变。
这类逻辑在 PLC 控制中经常用于实现**开关保持**（比如按一下按钮灯亮，再按一次灯灭）。

---

## 二、RS 与 SR 的区别

在 IEC 61131 标准中，有两种常见的双稳态功能块：

* **RS（Reset-Set）**：复位优先；
* **SR（Set-Reset）**：置位优先。

也就是说，当“置位”和“复位”信号**同时为真**时：

* RS 型触发器 → **复位**优先（输出为 0）；
* SR 型触发器 → **置位**优先（输出为 1）。

---

## 三、RS 触发器在 IL 中的实现

图左的 RS 模块有输入：

* **S（Set）** ← X
* **R（Reset）** ← Y
输出 **Q → Z**

IL 指令实现如下：

```
LD X      ; 装载设置信号 X
S  Z      ; 如果 X=1，则置位输出 Z
LD Y      ; 装载复位信号 Y
R  Z      ; 如果 Y=1，则复位输出 Z
```

👉 执行顺序先 S 后 R，符合 RS（Reset dominates）逻辑。

---

## 四、SR 触发器在 IL 中的实现

SR 是置位优先（Set dominates）：

```
LD Y      ; 装载复位信号 Y
R  Z      ; 如果 Y=1，复位 Z
LD X      ; 装载设置信号 X
S  Z      ; 如果 X=1，置位 Z
```

👉 执行顺序相反，先复位、后置位，表示 **Set 优先**。

---

## 五、总结对比

| 类型     | 优先逻辑     | 指令执行顺序  | 特点               |
| ------ | -------- | ------- | ---------------- |
| **RS** | Reset 优先 | `S → R` | 常用于安全逻辑（优先关闭）    |
| **SR** | Set 优先   | `R → S` | 常用于保持或锁存逻辑（优先打开） |

---

\[口语化表达]
这页讲的就是**RS和SR这两种触发器在指令表里的写法**。RS 是“复位优先”，所以先 `S Z` 再 `R Z`；SR 是“置位优先”，所以先 `R Z` 再 `S Z`。当 X（设置信号）和 Y（复位信号）同时为真时，RS 会把输出清零，SR 会让输出保持为 1。简单说，RS更安全（遇到冲突先关），SR更激进（遇到冲突先开）。


---

## 第 62 页

![第 62 页](Chapter 3 - Programmable Logic ___lers (slides with annotations)_assets/page-062.png)

这页讲的是：**在 IEC 61131 的指令表 (IL) 中，如何调用 RS 功能块（即双稳态触发器）**。
主要展示了两种写法（Variant 1 和 Variant 2），目的相同，只是写法不同。

---

## 一、RS 功能块简介

左边的图是一个 RS 触发器（Reset-Set bistable）：

* **S (Set)** 输入 → 控制“置位”
* **R (Reset)** 输入 → 控制“复位”
* **Q** 输出 → 当前状态
这个功能块能记忆状态，也就是“保持”输出，除非输入改变。

在程序里声明这个功能块的实例：

```il
VAR
myBistable : RS;     // 声明一个名为 myBistable 的 RS 功能块实例
x, y, z : BOOL;      // 三个布尔变量
END_VAR
```

其中：

* `x` → 连接到 `S`（Set 输入）
* `y` → 连接到 `R`（Reset 输入）
* `z` → 最终接收输出 `Q`

---

## 二、Variant 1：传统“分步赋值 + 调用”

这一种写法把各个输入先单独赋给功能块的成员变量，再调用。

```il
LD  x
ST  myBistable.S      ; 把 x 的值赋给 myBistable 的 S 端
LD  y
ST  myBistable.R      ; 把 y 的值赋给 R 端
...
CAL myBistable        ; 调用功能块（执行 RS 逻辑）
LD  myBistable.Q
ST  z                 ; 把输出 Q 赋给 z
```

执行过程：

1. 载入 x → 写入 S；
2. 载入 y → 写入 R；
3. 调用 `myBistable` → 功能块根据输入更新内部状态；
4. 最后把输出 Q 存到 z。

这种方式的优点是清晰，适合多个信号分开处理、调试。

---

## 三、Variant 2：使用具名参数调用（更简洁）

这是更现代的写法，一次性传入参数。

```il
CAL myBistable(S:=x, R:=y)
LD  myBistable.Q
ST  z
```

解释：

* `CAL` 调用功能块；
* 括号里直接用具名参数：`S:=x` 表示把 x 传给 S 端，`R:=y` 表示把 y 传给 R 端；
* 然后读取输出 Q，赋给 z。

这种写法相当于**方法1的简化版**，功能完全一样，但代码更短、更易读。

---

## 四、总结对比

| 写法            | 特点       | 优点       | 缺点            |
| ------------- | -------- | -------- | ------------- |
| **Variant 1** | 逐步赋值、再调用 | 清晰、可分步调试 | 稍繁琐           |
| **Variant 2** | 一次性具名传参  | 简洁、直观    | 可读性略低于结构化语言调用 |

---

\[口语化表达]
这一页是在讲怎么在指令表（IL）里用 RS 功能块。我们先定义一个叫 `myBistable` 的 RS，然后有两种用法。第一种（Variant 1）是分步写：先把 `x` 送到 `myBistable.S`，再把 `y` 送到 `myBistable.R`，然后 `CAL myBistable` 调用它，最后把 `myBistable.Q` 存到 `z`。第二种（Variant 2）更简单，直接一行 `CAL myBistable(S:=x, R:=y)`，意思是把 x 连接到 S，y 连接到 R。最后一样从 `myBistable.Q` 取输出给 z。两种写法结果完全一样，一个更“传统”、一个更“现代”，主要看你喜欢哪种风格。


---

## 第 63 页

![第 63 页](Chapter 3 - Programmable Logic ___lers (slides with annotations)_assets/page-063.png)

这页讲的是：在 **IEC 61131 的指令表（IL）语言**中，**如何调用定时器功能块（以 TON 为例）**。
TON（Timer On Delay）是一个常见的定时器功能块，用于“延时通电”操作。

---

## 一、功能块结构介绍

左上角画的方框表示 TON 定时器的接口：

| 名称     | 类型   | 含义                  |
| ------ | ---- | ------------------- |
| **IN** | BOOL | 输入信号（触发信号）          |
| **PT** | TIME | 预置时间（定时时长）          |
| **Q**  | BOOL | 输出信号（到时为 TRUE）      |
| **ET** | TIME | 已经过时间（Elapsed Time） |

例子中声明：

```il
VAR
myTimer : TON;         // 定时器实例
start, motor : BOOL;   // 两个布尔变量
END_VAR
```

* `myTimer` 就是一个 TON 定时器的实例。
* `start` 是定时器启动信号。
* `motor` 是需要被控制的输出（例如电机）。

---

## 二、IL 程序逻辑解释

### (1) 载入启动信号并写入定时器输入端：

```il
LD  start
ST  myTimer.IN
```

意思是：

* 从 `start` 变量加载逻辑值；
* 存储到 `myTimer.IN`，即把启动信号送进定时器输入端。

---

### (2) 调用定时器功能块并设置预置时间：

```il
CAL myTimer(PT := T#1min30s)
```

解释：

* `CAL` 调用功能块；
* `PT := T#1min30s` 代表设定预置时间为 **1 分 30 秒**；
* 定时器开始计时：当输入 `IN` = TRUE 时，定时器开始计时；经过设定时间后，`Q` 会变为 TRUE。

---

### (3) 读取定时器输出并控制电机：

```il
LD  myTimer.Q
S   motor
```

意思是：

* 当定时器输出 `Q` 为 TRUE（即定时完成）；
* 执行 `S motor`（Set），把 `motor` 输出信号置为 TRUE → 电机启动。

---

## 三、完整逻辑流程

1. **检测启动信号（start）**；
2. **触发定时器（myTimer）并设置时间 1 分 30 秒**；
3. **当时间到达后，定时器输出 Q = TRUE**；
4. **Q 驱动 motor 输出为 TRUE（电机启动）**。

整个逻辑就是一个**延时启动电机**的过程。

---

## 四、语法结构解读

* `LD`（Load） → 把变量载入累加器。
* `ST`（Store） → 把累加器的值存入变量。
* `CAL`（Call） → 调用功能块。
* `S`（Set） → 把输出变量置位（即设为 TRUE）。
* `T#1min30s` → 是 IEC 61131 的时间常量格式（T = Time），表示 1 分 30 秒。

---

## 五、运行时的行为描述

* 当 `start = FALSE` → 定时器停止，`Q = FALSE`。
* 当 `start = TRUE` → 定时器开始计时。
* 经过 1 分 30 秒后 → `Q` 输出变成 TRUE。
* 结果：`motor` 被置位（启动）。

---

\[口语化表达]
这页讲的是在指令表里怎么调用一个 **延时定时器（TON）**。
我们先定义一个定时器 `myTimer`，输入信号是 `start`，输出是 `motor`。程序先 `LD start`，再 `ST myTimer.IN`，意思就是把启动信号送进定时器。接着 `CAL myTimer(PT:=T#1min30s)`，设置定时 1 分 30 秒。当时间到了，`myTimer.Q` 就会变成 TRUE，最后 `LD myTimer.Q` 再 `S motor`，让电机启动。
简单说，这段程序实现的是——**按下 start 后，延时 90 秒再开电机。**


---

## 第 64 页

![第 64 页](Chapter 3 - Programmable Logic ___lers (slides with annotations)_assets/page-064.png)

202510220029

后台姓名：--
用户ID：--
用户1V1昵称：Ishmerai
学生需求类型：全学期辅导（知识点+作业+考前）
学生基础：一般
期望上课时间：北京时间，商量
学生DUE时间：暂无
用户类型：1v1新用户
院校：昆山杜克
年级：大一
专业：应用数学或计算机
科目代码：COMSCI 101
科目名称：Introduction to Computer  Science
备注：匹配老师，全学期辅导  有需要时约课


---

## 第 65 页

![第 65 页](Chapter 3 - Programmable Logic ___lers (slides with annotations)_assets/page-065.png)

这页讲的是：**逻辑控制程序的模型化开发流程（Model-based development of logic control programs）**。
它解释了在工业自动化设计中，如何通过“建模—生成代码”的方式高效地开发 PLC 控制系统。

---

## 一、总体思路

标题的关键词是 “Model-based development”，意思是 **基于模型的开发**。
这是一种现代的控制系统设计理念：

> 先建立一个逻辑模型（在软件中模拟控制器的行为），再从模型自动生成 PLC 程序代码。

这样做的好处是：

* 提高开发效率；
* 减少人工编程错误；
* 可以在实现前进行仿真与验证；
* 模型与实际控制器保持一致。

---

## 二、图中的流程结构说明

图中展示了传统和模型化开发结合的流程：

### 1️⃣ Desired behavior of control system

意思是“控制系统的期望行为”——
也就是我们想让系统实现的逻辑功能，比如：

* 电机启动条件；
* 安全互锁逻辑；
* 顺序执行动作。

这是设计的**起点**，代表“控制目标”。

---

### 2️⃣ Specs of controllers（控制器规格）

接下来要把“想法”变成**控制器的具体功能说明**（specification）。
在这一步，我们：

* 定义输入输出信号；
* 描述控制逻辑；
* 制定状态转换规则；
* 确定时序、报警、互锁条件等。

→ 图中箭头标注“**specifying**”，意思是“从期望行为到规格说明的过程”。

---

### 3️⃣ PLC Code（PLC 程序代码）

这是最终可在控制器上运行的程序。
通常包括：

* 用梯形图、功能块图或指令表编写的逻辑；
* 通过编译下载到实际的 PLC 中。

图中箭头“**implementing**”表示“从设计规格到实际代码的实现”。

---

### 4️⃣ Model of controller（控制器模型）

这是“模型化设计”的关键部分。
它相当于一个虚拟控制器，能在计算机上模拟实际 PLC 的逻辑行为。

流程中两条橙色箭头：

* “**modeling**”：从控制器规格（specs）创建模型；
* “**generating**”：从模型自动生成可运行的 PLC 代码。

👉 也就是说，传统上我们是“先写规格 → 再人工写代码”，
而现在的模型化方法是“先建模型 → 自动生成代码”，更加高效和可靠。

---

## 三、总结整个过程

完整流程可以理解为：

| 阶段         | 目标           | 方法                           |
| ---------- | ------------ | ---------------------------- |
| 1️⃣ 定义系统行为 | 明确系统要做什么     | 功能描述、需求分析                    |
| 2️⃣ 制定控制规格 | 把需求转化为控制逻辑   | 定义输入/输出/状态                   |
| 3️⃣ 建立控制模型 | 模拟控制逻辑       | 在工具中（如 Simulink、Stateflow）建模 |
| 4️⃣ 自动生成代码 | 生成并部署 PLC 程序 | 从模型导出可执行代码                   |

---

\[口语化表达]
这页讲的是怎么用“模型化”的方式去做控制系统。
以前我们写 PLC 程序是先想好逻辑，然后手动写代码。现在更聪明了，先在电脑上把控制逻辑画成一个模型（就是模拟控制器的行为），再让工具自动帮你生成 PLC 代码。
图上那三个椭圆代表三个阶段：上面是“想要的控制行为”，中间是“控制器规格说明”，下面是“PLC 程序代码”。
传统流程是从上往下写，而模型化方法是在中间建个“模型”，可以自动生成下面的 PLC 代码。
简单说就是——**先画模型，再出程序，省时又准，不容易出错。**


---

## 第 66 页

![第 66 页](Chapter 3 - Programmable Logic ___lers (slides with annotations)_assets/page-066.png)

这页讲的是：**传统逻辑控制系统开发方式的问题**，以及为什么**要使用模型化开发（Model-based development）**。
它延续了前一页内容，对比了传统“规格说明（specification）→实现（implementation）”的方式和“先建模型”的方式。

---

## 一、传统方法存在的问题（Problems with this approach）

传统的开发流程是：

1. 先写**控制器规格（specification）**；
2. 再人工把它翻译成 PLC 代码。

这种做法虽然直观，但有很多潜在风险。幻灯片列出了三个主要问题：

### ① 规格是否真正表达了想要的系统行为？

> Does the specification represent the originally desired behavior?

意思是：
你写下来的规格说明，真的能准确表达“我们想要控制系统如何工作”吗？
—— 很多时候开发者的理解和需求方不一致，导致逻辑偏差。
例如，原本想“启动时延时5秒”，结果规格里写成“延时5分钟”。

这就是\*\*语义偏差（requirement mismatch）\*\*的问题。

---

### ② 规格是否完整且一致？

> Is the specification complete and consistent?

规格说明可能会：

* **不完整**（有漏项，比如忘记写“出错时要关闭电机”）；
* **不一致**（同一个信号在不同地方定义矛盾）。

这在复杂系统中非常常见。
手写的规格文档通常靠人工审查，很容易出错。

---

### ③ 规格应如何实现？

> How to implement the specification?

即使规格没问题，也还要考虑**如何将其转化为 PLC 代码**。
人工实现过程耗时、容易引入新错误。
而且一旦修改需求，代码就得重写或手动修改，很不灵活。

---

## 二、改进方法：先建立控制器模型（Build a model of the controller first）

幻灯片提出的解决方案是：

> “Instead: Build a model of the controller first.”
> 换句话说：不要先写规格、再写代码，而是**先搭建一个可执行模型（Model）**。

这样做的优势如下👇

---

### ① 有助于讨论与澄清需求

> It helps discussing/clarifying the specification.

模型是“可以看到、可以运行”的逻辑表示，
不同部门（控制、软件、机械）可以直观看到行为效果。
—— 这样更容易确认需求是否正确、是否理解一致。

---

### ② 模型可以用算法分析

> It can be analyzed algorithmically.

建立模型后，可以：

* 自动检测逻辑冲突；
* 检查状态覆盖；
* 分析时间顺序或安全约束。

也就是说，它能被“形式化分析”（formal verification），比人工审查更可靠。

---

### ③ 支持自动代码生成

> Automatic code generation becomes possible.

一旦模型经过验证，就能直接通过工具生成 PLC 代码（例如 Simulink 的代码生成器）。
这样既节省人工时间，又保证实现与模型一致，避免人为实现错误。

---

## 三、总结对比

| 传统方式        | 模型化开发          |
| ----------- | -------------- |
| 文字规格 + 手写代码 | 可执行模型 + 自动生成代码 |
| 易产生理解偏差     | 模型直观、易沟通       |
| 人工检查一致性     | 工具可自动验证逻辑      |
| 修改困难        | 模型更新即可重新生成代码   |

---

\[口语化表达]
这页讲的就是：为什么我们不再用老式那种“先写规格再写代码”的办法。
传统做法有三个坑：
① 写的规格不一定真能反映想要的系统行为；
② 规格经常不完整、还会自相矛盾；
③ 实现起来麻烦，还容易写错。
所以现在更聪明的做法是——先搭一个“控制器模型”。
这样大家能直观看到系统行为、方便讨论，模型还能让电脑自动帮我们检查逻辑、甚至直接生成 PLC 代码。
一句话总结：**别光写文字描述，先建个能跑的模型，省事、省错、还能自动出程序。**


---

## 第 67 页

![第 67 页](Chapter 3 - Programmable Logic ___lers (slides with annotations)_assets/page-067.png)

这页讲的是：在**模型化逻辑控制开发（Model-based development）**中，
如何用**自动机（Automata）模型**来表示控制器的行为，
其中重点是两种常见的有限状态机（FSM）模型：**Moore 自动机**和 **Mealy 自动机**。

---

## 一、自动机模型的基本思想

在控制系统中，我们通常需要描述：

* 系统有哪些“状态”（state）；
* 输入（input）会让状态怎么变化；
* 每个状态或状态变化对应什么输出（output）。

为了系统化描述这些逻辑关系，我们使用\*\*状态机（state machine）**或**自动机（automaton）\*\*模型。
它是逻辑控制中非常核心的概念，比如在 PLC 的顺序功能图（SFC）里，本质就是自动机的一种表现形式。

---

## 二、公式解释：

幻灯片中的公式定义了一个自动机：

$$
A = (X, U, Y, f, g, x_0)
$$

这是一个数学模型，用来完整描述一个自动机的行为。
下面是每个符号的含义：

| 符号     | 含义                                | 解释                                    |
| ------ | --------------------------------- | ------------------------------------- |
| **X**  | 状态集合（Set of discrete states）      | 比如 “电机停止”、“电机运行”、“报警中”等。              |
| **U**  | 输入字母集（input alphabet）             | 控制输入，如“按钮按下”、“传感器触发”。                 |
| **Y**  | 输出字母集（output alphabet）            | 控制输出，如“灯亮”、“电机转动”。                    |
| **f**  | 状态转移函数（state transition function） | 决定系统在当前状态和输入下转到哪个新状态：  $x' = f(x, u)$ |
| **g**  | 输出函数（output function）             | 决定在给定状态（或状态+输入）下，系统的输出。               |
| **x₀** | 初始状态（initial state）               | 系统刚启动时的起点状态。                          |

---

## 三、Moore 自动机（Moore Automaton）

右上角的图说明了 Moore 自动机的特点：

* 输出 **只依赖当前状态**；
即：

$$
y = g(x)
$$
* 输入 **只影响下一个状态**；
即：

$$
x' = f(x, u)
$$
* 在图里，每个状态圆圈标注为 `x/y`，表示在状态 `x` 时，输出 `y`。

👉 例如：

* 当系统处于“运行状态”时，灯亮；
* 当系统处于“停止状态”时，灯灭。
不管输入是什么，输出只由状态决定。

---

## 四、Mealy 自动机（Mealy Automaton）

右下角的图展示了 Mealy 自动机的区别：

* 输出 **依赖状态和输入**；
即：

$$
y = g(x, u)
$$
* 也就是说，输出可以“即时反应”输入变化，不用等状态切换。
* 图中用 `u/y` 表示“在输入 u 时输出 y”。

👉 举例：

* 如果按下按钮（输入变化），立即点亮灯（输出变化）；
* 不需要进入新的状态才能改变输出。

---

## 五、两者对比总结

| 特征       | **Moore 自动机**  | **Mealy 自动机**      |
| -------- | -------------- | ------------------ |
| 输出依赖     | 仅依赖状态 $y=g(x)$ | 依赖状态和输入 $y=g(x,u)$ |
| 响应时间     | 慢一拍（等状态更新）     | 立即响应输入             |
| 电路/实现复杂度 | 简单、稳定          | 更高效但复杂             |
| PLC中应用   | 常用于定时、稳定逻辑     | 常用于实时响应逻辑          |

---

\[口语化表达]
这页讲的是用“自动机”这种数学模型来描述控制系统的逻辑。
你可以把它想成“系统在不同状态之间跳来跳去，每个状态对应不同的输出”。
公式那一串其实就是定义了：状态、输入、输出、状态转移规则，还有系统从哪儿开始。
然后分成两种模型：

* **Moore 型**：输出只看状态，比如“灯在运行状态时亮”；
* **Mealy 型**：输出不仅看状态，还看输入，比如“只要按钮一按，灯马上亮”。
简单说，Moore 比较稳，Mealy 反应快。
这就是在逻辑控制中，我们用数学模型（自动机）来描述控制器逻辑的核心思想。


---

## 第 68 页

![第 68 页](Chapter 3 - Programmable Logic ___lers (slides with annotations)_assets/page-068.png)

这页讲的是：**一个用于报警处理（alarm handling）的功能块（Function Block）建模示例**。
也就是说，这里举了一个具体的例子，说明如何把一个报警控制逻辑用**模型化方法**来设计出来。

---

## 一、主题概览

幻灯片标题是

> “Our example for model-based design: A function block for alarm handling”
> 意思是：
> 我们将以“报警处理功能块”为例，来展示**基于模型的设计方法**。

这个例子将贯穿后面几页，用来一步步展示如何：

1. 写出需求规格（Specification）；
2. 转化为状态模型（State Machine）；
3. 最终生成可执行控制逻辑（PLC 程序）。

---

## 二、功能块结构说明

中间的方框代表一个**报警处理功能块（Function Block）**，
它有 **三个输入信号** 和 **两个输出信号**：

| 类型 | 名称             | 说明                |
| -- | -------------- | ----------------- |
| 输入 | `danger`       | 危险信号（检测危险状态）      |
| 输入 | `receipt`      | 接受（确认）信号，操作员确认报警  |
| 输入 | `reset`        | 复位信号              |
| 输出 | `red light`    | 红灯，表示“有危险”        |
| 输出 | `yellow light` | 黄灯，表示“危险已确认但仍未解除” |

---

## 三、行为逻辑（Specification）

这部分是整个功能的**行为需求说明**，即控制逻辑的“文字版”：

### ① 当危险出现时（DANGER = TRUE）：

> “The RED light must be switched on as soon as DANGER becomes TRUE.”

意思是：

* 一旦检测到危险信号（`danger` 变为真），
* 红灯（`red light`）立即点亮。

📌 逻辑解释：危险→立刻亮红灯（警示状态）。

---

### ② 当操作员按下“确认”按钮（RECEIPT）：

> “When the operator presses the RECEIPT button, the RED light is switched off and the YELLOW light is switched on.”

意思是：

* 操作员确认已看到报警；
* 红灯熄灭；
* 黄灯亮起。

📌 逻辑解释：收到确认→红灯灭、黄灯亮（已确认但仍需处理）。

---

### ③ 当危险解除并按下“复位”按钮（RESET）：

> “When the danger is over, the YELLOW light can be switched off by pressing the RESET button.”

意思是：

* 当危险信号变为假（系统安全了），
* 操作员可以通过按下复位键来关闭黄灯，
* 回到初始状态。

📌 逻辑解释：危险解除→复位→黄灯灭（系统恢复正常）。

---

## 四、功能总结与系统状态推断

根据这三个条件，可以推断系统有**三个主要状态**：

| 状态        | 红灯  | 黄灯  | 说明             |
| --------- | --- | --- | -------------- |
| **正常状态**  | OFF | OFF | 无危险            |
| **报警状态**  | ON  | OFF | 检测到危险          |
| **已确认状态** | OFF | ON  | 危险仍存在，但已被操作员确认 |

---

## 五、这一页的重点

这一页的作用是：

* 提供一个**从自然语言需求到控制逻辑建模的起点**；
* 定义系统的输入、输出、行为规则；
* 为接下来使用自动机模型（Moore/Mealy）建模打下基础。

下一步，就是把这段文字规格转化为一个**状态机模型（state diagram）**。

---

\[口语化表达]
这页其实是在举个很实际的例子——怎么用“模型化设计”的方法去实现一个报警控制系统。
系统有三个输入：危险信号、确认按钮、复位按钮；
两个输出：红灯和黄灯。
规则很简单：
① 一有危险，红灯马上亮；
② 操作员确认后，红灯灭、黄灯亮；
③ 危险解除后，按复位键，黄灯也灭，系统回到正常状态。
所以这个小系统能表现出“报警→确认→复位”三个阶段。
这页的意思就是：**先把逻辑需求写清楚，用它来做模型设计的基础。**


---

## 第 69 页

![第 69 页](Chapter 3 - Programmable Logic ___lers (slides with annotations)_assets/page-069.png)

这页讲的是：**一个用于报警处理（alarm handling）的功能块（Function Block）建模示例**。
也就是说，这里举了一个具体的例子，说明如何把一个报警控制逻辑用**模型化方法**来设计出来。

---

## 一、主题概览

幻灯片标题是

> “Our example for model-based design: A function block for alarm handling”
> 意思是：
> 我们将以“报警处理功能块”为例，来展示**基于模型的设计方法**。

这个例子将贯穿后面几页，用来一步步展示如何：

1. 写出需求规格（Specification）；
2. 转化为状态模型（State Machine）；
3. 最终生成可执行控制逻辑（PLC 程序）。

---

## 二、功能块结构说明

中间的方框代表一个**报警处理功能块（Function Block）**，
它有 **三个输入信号** 和 **两个输出信号**：

| 类型 | 名称             | 说明                |
| -- | -------------- | ----------------- |
| 输入 | `danger`       | 危险信号（检测危险状态）      |
| 输入 | `receipt`      | 接受（确认）信号，操作员确认报警  |
| 输入 | `reset`        | 复位信号              |
| 输出 | `red light`    | 红灯，表示“有危险”        |
| 输出 | `yellow light` | 黄灯，表示“危险已确认但仍未解除” |

---

## 三、行为逻辑（Specification）

这部分是整个功能的**行为需求说明**，即控制逻辑的“文字版”：

### ① 当危险出现时（DANGER = TRUE）：

> “The RED light must be switched on as soon as DANGER becomes TRUE.”

意思是：

* 一旦检测到危险信号（`danger` 变为真），
* 红灯（`red light`）立即点亮。

📌 逻辑解释：危险→立刻亮红灯（警示状态）。

---

### ② 当操作员按下“确认”按钮（RECEIPT）：

> “When the operator presses the RECEIPT button, the RED light is switched off and the YELLOW light is switched on.”

意思是：

* 操作员确认已看到报警；
* 红灯熄灭；
* 黄灯亮起。

📌 逻辑解释：收到确认→红灯灭、黄灯亮（已确认但仍需处理）。

---

### ③ 当危险解除并按下“复位”按钮（RESET）：

> “When the danger is over, the YELLOW light can be switched off by pressing the RESET button.”

意思是：

* 当危险信号变为假（系统安全了），
* 操作员可以通过按下复位键来关闭黄灯，
* 回到初始状态。

📌 逻辑解释：危险解除→复位→黄灯灭（系统恢复正常）。

---

## 四、功能总结与系统状态推断

根据这三个条件，可以推断系统有**三个主要状态**：

| 状态        | 红灯  | 黄灯  | 说明             |
| --------- | --- | --- | -------------- |
| **正常状态**  | OFF | OFF | 无危险            |
| **报警状态**  | ON  | OFF | 检测到危险          |
| **已确认状态** | OFF | ON  | 危险仍存在，但已被操作员确认 |

---

## 五、这一页的重点

这一页的作用是：

* 提供一个**从自然语言需求到控制逻辑建模的起点**；
* 定义系统的输入、输出、行为规则；
* 为接下来使用自动机模型（Moore/Mealy）建模打下基础。

下一步，就是把这段文字规格转化为一个**状态机模型（state diagram）**。

---

\[口语化表达]
这页其实是在举个很实际的例子——怎么用“模型化设计”的方法去实现一个报警控制系统。
系统有三个输入：危险信号、确认按钮、复位按钮；
两个输出：红灯和黄灯。
规则很简单：
① 一有危险，红灯马上亮；
② 操作员确认后，红灯灭、黄灯亮；
③ 危险解除后，按复位键，黄灯也灭，系统回到正常状态。
所以这个小系统能表现出“报警→确认→复位”三个阶段。
这页的意思就是：**先把逻辑需求写清楚，用它来做模型设计的基础。**


---

## 第 70 页

![第 70 页](Chapter 3 - Programmable Logic ___lers (slides with annotations)_assets/page-070.png)

这页是在把“报警处理功能块”的\*\*状态转移图（Transition diagram）\*\*画出来：用三个离散状态 $x_0,x_1,x_2$ 和带条件的有向边，描述当输入变化时系统如何在状态之间切换。
输入向量 $u=(danger,\,receipt,\,reset)$，其中 “$-$” 表示“不关心/任意”。
状态与含义（同上一页）：

* **$x_0=(0,0)$**：两灯都灭（正常）
* **$x_1=(1,0)$**：红灯亮（危险）
* **$x_2=(0,1)$**：黄灯亮（已接警，待复位）

### 关键状态转移（读箭头旁的标签）

* **$x_0 \rightarrow x_1$**：当 **danger 触发**
标签：$u=(1,-,-)$
解释：出现危险 → 进入报警，红灯亮。
* **$x_1 \rightarrow x_2$**：当 **receipt(确认) 按下**
标签：$u=(-,1,-)$
解释：操作员确认 → 红灯灭、黄灯亮（表示“已知晓”）。
* **$x_2 \rightarrow x_0$**：当 **危险消除且 reset(复位) 按下**
标签：$u=(0,-,1)$
解释：危险结束并复位 → 黄灯灭，回到正常。
* **自循环（保持当前状态）**

* 在 **$x_0$**：若无危险持续 **$u=(0,-,-)$**，一直停留在正常态。
* 在 **$x_1$**：若还**未按确认** **$u=(-,0,-)$**，继续保持红灯亮。
* 在 **$x_2$**：若**未按复位** **$u=(-,-,0)$**，继续保持黄灯亮。

> 图中红色手写圈注在右侧强调了从 **$x_2$** 回到 **$x_0$** 的必要条件是 **危险=0 且 reset=1（$u=(0,-,1)$）**；旁边关于 $u=(1,-,-)$ / $u=(-,-,0)$ 的批注是提示：若危险仍在或未复位，就不要返回正常态，而是继续停在 $x_1$/$x_2$。

### 小结

这张图把**自然语言规格**形式化为**有限状态机**：

* 危险一来（danger=1）→ 进 **红灯态**；
* 操作员确认（receipt=1）→ 转 **黄灯态**；
* 危险结束并复位（danger=0 且 reset=1）→ 回 **正常态**；
* 其余情况下各态**自保持**。

\[口语化表达]
这页就是把报警灯的逻辑用“状态机图”画出来：平时待在 **x₀(两灯灭)**；一旦 **danger=1** 就跳到 **x₁(红灯亮)**；按下 **receipt** 就到 **x₂(黄灯亮)**；等危险真的没了再按 **reset**，从 **x₂** 回到 **x₀**。如果中途没按确认/复位，或者危险还在，就在当前状态打转不变。


---

## 第 71 页

![第 71 页](Chapter 3 - Programmable Logic ___lers (slides with annotations)_assets/page-071.png)

这页讲的是上一页“报警灯逻辑”的**状态转移图（Transition Diagram）**，
用自动机的形式（state machine）明确描述系统**在不同输入条件下如何从一个状态转移到另一个状态**。

---

## 一、主题：报警控制系统的状态转移关系

标题是：

> “Model-based development of logic control programs (ctd.) — Modeling the example: Transition diagram”

也就是说，这是对“报警功能块”例子的**第二步：建立状态转移图**。
它是在前一页的数学建模基础上（定义了状态 x₀, x₁, x₂ 和输入 u），
通过一个图形化的自动机展示各状态之间的转移逻辑。

---

## 二、状态与含义

每个圆圈代表一个系统状态（state）：

| 状态             | 红灯 | 黄灯 | 含义               |
| -------------- | -- | -- | ---------------- |
| **x₀ = (0,0)** | 关  | 关  | 正常状态（无危险）        |
| **x₁ = (1,0)** | 开  | 关  | 报警状态（危险中）        |
| **x₂ = (0,1)** | 关  | 开  | 已确认状态（报警已确认但未复位） |

---

## 三、输入变量定义

输入 $u = (danger, receipt, reset)$，
即：

* `danger` 表示危险信号（1=有危险）
* `receipt` 表示确认按钮（1=操作员确认）
* `reset` 表示复位按钮（1=操作员复位）
* “−” 表示该输入在此转移中不影响结果（即“don't care”）

---

## 四、状态转移逻辑（看箭头方向与标签）

图中每个箭头旁的 `u=(...)` 表示在什么输入条件下会发生转移。

1️⃣ **从正常状态 x₀ → 报警状态 x₁**
条件：`u=(1,-,-)`

* 当危险出现（danger=1）时，红灯点亮（x₁），进入报警状态。

2️⃣ **从报警状态 x₁ → 已确认状态 x₂**
条件：`u=(-,1,-)`

* 当操作员按下确认按钮（receipt=1）时，系统认为报警已被接收，
红灯熄灭、黄灯亮。

3️⃣ **从已确认状态 x₂ → 正常状态 x₀**
条件：`u=(0,-,1)`

* 当危险解除（danger=0）并按下复位（reset=1）时，系统回到初始状态。

---

## 五、保持状态（自循环）

每个状态都有一个“自环箭头”，表示在某些条件下保持不变：

* 在 **x₀**：`u=(0,-,-)` → 无危险时保持正常。
* 在 **x₁**：`u=(-,0,-)` → 危险未确认时持续报警。
* 在 **x₂**：`u=(-,-,0)` → 未复位时继续保持已确认状态。

---

## 六、手写批注说明

红色标注的圆圈与箭头表示：

* $u=(0,-,1)$ 是从 x₂ → x₀ 的关键条件；
* “u=(1,-,-) 或 u=(-,-,0)” 是辅助说明：若危险还在或没复位，系统就不要返回正常态；
* $u=(0,-,0)$ 表示没有危险也没复位 → 维持当前状态。

---

## 七、总结

这个图完整地描述了报警系统的**状态行为逻辑**：

* 初始状态正常（x₀）；
* 一旦有危险 → 进入报警（x₁）；
* 操作员确认后 → 转到已确认状态（x₂）；
* 当危险解除且按复位 → 回到正常（x₀）；
* 其他情况下保持当前状态。

它对应的数学函数是：

$$
x' = f(x, u)
$$

也就是：**下一个状态取决于当前状态和输入信号。**

---

\[口语化表达]
这页画的其实是“报警灯控制”的整个状态切换流程。
平时在 x₀（两灯都灭）时，危险信号一来（danger=1）→ 跳到 x₁（红灯亮报警）；
然后操作员按下确认键（receipt=1）→ 转到 x₂（红灯灭黄灯亮，表示“我知道了”）；
最后等危险解除并按复位（reset=1）→ 又回到 x₀（两灯灭，恢复正常）。
如果中途没按确认或复位，系统就一直停在当前状态。
这一页其实就是用状态机图，把整个报警逻辑清清楚楚地画了出来。


---

## 第 72 页

![第 72 页](Chapter 3 - Programmable Logic ___lers (slides with annotations)_assets/page-072.png)

这页讲的是上一页“报警灯逻辑”的**状态转移图（Transition Diagram）**，
用自动机的形式（state machine）明确描述系统**在不同输入条件下如何从一个状态转移到另一个状态**。

---

## 一、主题：报警控制系统的状态转移关系

标题是：

> “Model-based development of logic control programs (ctd.) — Modeling the example: Transition diagram”

也就是说，这是对“报警功能块”例子的**第二步：建立状态转移图**。
它是在前一页的数学建模基础上（定义了状态 x₀, x₁, x₂ 和输入 u），
通过一个图形化的自动机展示各状态之间的转移逻辑。

---

## 二、状态与含义

每个圆圈代表一个系统状态（state）：

| 状态             | 红灯 | 黄灯 | 含义               |
| -------------- | -- | -- | ---------------- |
| **x₀ = (0,0)** | 关  | 关  | 正常状态（无危险）        |
| **x₁ = (1,0)** | 开  | 关  | 报警状态（危险中）        |
| **x₂ = (0,1)** | 关  | 开  | 已确认状态（报警已确认但未复位） |

---

## 三、输入变量定义

输入 $u = (danger, receipt, reset)$，
即：

* `danger` 表示危险信号（1=有危险）
* `receipt` 表示确认按钮（1=操作员确认）
* `reset` 表示复位按钮（1=操作员复位）
* “−” 表示该输入在此转移中不影响结果（即“don't care”）

---

## 四、状态转移逻辑（看箭头方向与标签）

图中每个箭头旁的 `u=(...)` 表示在什么输入条件下会发生转移。

1️⃣ **从正常状态 x₀ → 报警状态 x₁**
条件：`u=(1,-,-)`

* 当危险出现（danger=1）时，红灯点亮（x₁），进入报警状态。

2️⃣ **从报警状态 x₁ → 已确认状态 x₂**
条件：`u=(-,1,-)`

* 当操作员按下确认按钮（receipt=1）时，系统认为报警已被接收，
红灯熄灭、黄灯亮。

3️⃣ **从已确认状态 x₂ → 正常状态 x₀**
条件：`u=(0,-,1)`

* 当危险解除（danger=0）并按下复位（reset=1）时，系统回到初始状态。

---

## 五、保持状态（自循环）

每个状态都有一个“自环箭头”，表示在某些条件下保持不变：

* 在 **x₀**：`u=(0,-,-)` → 无危险时保持正常。
* 在 **x₁**：`u=(-,0,-)` → 危险未确认时持续报警。
* 在 **x₂**：`u=(-,-,0)` → 未复位时继续保持已确认状态。

---

## 六、手写批注说明

红色标注的圆圈与箭头表示：

* $u=(0,-,1)$ 是从 x₂ → x₀ 的关键条件；
* “u=(1,-,-) 或 u=(-,-,0)” 是辅助说明：若危险还在或没复位，系统就不要返回正常态；
* $u=(0,-,0)$ 表示没有危险也没复位 → 维持当前状态。

---

## 七、总结

这个图完整地描述了报警系统的**状态行为逻辑**：

* 初始状态正常（x₀）；
* 一旦有危险 → 进入报警（x₁）；
* 操作员确认后 → 转到已确认状态（x₂）；
* 当危险解除且按复位 → 回到正常（x₀）；
* 其他情况下保持当前状态。

它对应的数学函数是：

$$
x' = f(x, u)
$$

也就是：**下一个状态取决于当前状态和输入信号。**

---

\[口语化表达]
这页画的其实是“报警灯控制”的整个状态切换流程。
平时在 x₀（两灯都灭）时，危险信号一来（danger=1）→ 跳到 x₁（红灯亮报警）；
然后操作员按下确认键（receipt=1）→ 转到 x₂（红灯灭黄灯亮，表示“我知道了”）；
最后等危险解除并按复位（reset=1）→ 又回到 x₀（两灯灭，恢复正常）。
如果中途没按确认或复位，系统就一直停在当前状态。
这一页其实就是用状态机图，把整个报警逻辑清清楚楚地画了出来。


---

## 第 73 页

![第 73 页](Chapter 3 - Programmable Logic ___lers (slides with annotations)_assets/page-073.png)

这页的主题是讲 **在模型基础上生成代码（Code Generation）** 时，
如何进行 **变量声明（Variable Declarations）**。
也就是说，把之前状态机（危险、确认、复位、红灯、黄灯、状态 x₀/x₁/x₂）的逻辑，
转化为 **PLC 程序的输入、输出和内部变量声明部分**。

---

## 一、整体逻辑

在 PLC 编程（特别是 IEC 61131 标准）里，
每个程序或功能块（Function Block）都会分成三类变量区块：

1. **VAR\_INPUT** —— 输入变量（外部信号）
2. **VAR\_OUTPUT** —— 输出变量（控制信号）
3. **VAR** —— 内部变量（程序内部状态）

这页展示的代码块正是报警灯控制系统的三类变量声明。

---

## 二、逐行详细说明

### 1️⃣ 输入变量声明（`VAR_INPUT`）

```plaintext
VAR_INPUT
danger, receipt, reset : BOOL;
END_VAR
```

意思是：

* 系统有三个输入信号：

* `danger`（危险信号）
* `receipt`（确认按钮）
* `reset`（复位按钮）
* 类型都是 `BOOL`（布尔类型，TRUE/FALSE）

它们对应现实世界的外部输入，比如传感器或按钮。

---

### 2️⃣ 输出变量声明（`VAR_OUTPUT`）

```plaintext
VAR_OUTPUT
red, yellow : BOOL;
END_VAR
```

意思是：

* 输出有两个灯：

* `red`（红灯）
* `yellow`（黄灯）
* 这两个信号控制报警灯的亮灭状态。

---

### 3️⃣ 内部变量声明（`VAR`）

```plaintext
VAR
X0 : BOOL := TRUE;
X1, X2 : BOOL := FALSE;
END_VAR
```

意思是：

* 系统内部有三个状态变量：

* `X0` 表示状态 0（正常）
* `X1` 表示状态 1（红灯报警）
* `X2` 表示状态 2（黄灯确认）
* 这三个变量用于记录当前系统处于哪个状态。
它们都是布尔类型，但互斥（同一时刻只有一个为 TRUE）。

初始值：

* 系统一开始运行时，`X0 = TRUE`（处于正常状态）
* `X1 = FALSE`、`X2 = FALSE`（报警与确认状态均未激活）

这与状态转移图完全一致（x₀ 是初始状态）。

---

## 三、总结逻辑结构

| 变量类型     | 名称                     | 类型   | 含义             | 初始值                |
| -------- | ---------------------- | ---- | -------------- | ------------------ |
| **输入**   | danger, receipt, reset | BOOL | 外部信号（危险、确认、复位） | N/A                |
| **输出**   | red, yellow            | BOOL | 输出信号（红灯、黄灯）    | FALSE              |
| **内部状态** | X0, X1, X2             | BOOL | 三个系统状态         | X0=TRUE, 其余为 FALSE |

这部分定义就是整个控制逻辑的基础骨架。

---

\[口语化表达]
这页讲的就是在把“报警灯控制”的状态机写进程序前，先把程序要用到的变量都定义好。
输入有三个：危险信号、确认按钮、复位按钮；
输出有两个：红灯和黄灯；
然后程序里还有三个内部状态变量 X0、X1、X2，分别代表“正常”“报警”“已确认”。
刚启动时默认在 X0，也就是正常状态。
这其实就是把前面画的状态图和输入输出关系，用代码的形式先搭起框架。


---

## 第 74 页

![第 74 页](Chapter 3 - Programmable Logic ___lers (slides with annotations)_assets/page-074.png)

这页讲的是——在模型生成的 PLC 代码中，如何检测并执行状态转移（Check and perform transitions）。
也就是说，把前面状态机图中的状态变化逻辑（x₀、x₁、x₂ 之间的转换）用 Instruction List (IL) 程序语言来实现。
一、核心思想
在状态机逻辑中，每次循环程序都要：
检查当前状态（x₀/x₁/x₂ 是否为 TRUE）；
检查相应的输入条件（danger、receipt、reset）；
当条件满足时，从当前状态清除（Reset），并把目标状态置位（Set）。
这页展示的代码正是对这些转移条件的实现。
二、代码详解
（1）从 x₀ → x₁
plaintext
复制
编辑
LD   x0
AND  danger
R    x0
S    x1
解释：
LD x0：载入当前状态是否为 x₀（正常状态）。
AND danger：判断危险信号是否为 TRUE。
当两者都为 TRUE 时：
R x0：复位当前状态（退出正常状态）。
S x1：进入报警状态（红灯亮）。
逻辑含义：
如果当前在正常状态且检测到危险 → 切换到报警状态。
（2）从 x₁ → x₂
plaintext
复制
编辑
LD   x1
AND  receipt
R    x1
S    x2
解释：
LD x1：系统当前是否在报警状态。
AND receipt：检查操作员是否按下确认按钮。
若成立：
R x1：关闭报警状态。
S x2：转到“已确认”状态（黄灯亮）。
逻辑含义：
如果当前在报警状态且已被确认 → 转到已确认状态。
（3）从 x₂ → x₀
plaintext
复制
编辑
LD   x2
ANDN danger
AND  reset
R    x2
S    x0
解释：
LD x2：系统当前是否在“已确认”状态。
ANDN danger：检测危险信号是否已解除（ANDN 表示与“非 danger”相与）。
AND reset：检查复位按钮是否按下。
若成立：
R x2：清除已确认状态。
S x0：恢复到正常状态。
逻辑含义：
如果危险解除并且按下复位 → 回到正常状态。
三、程序执行顺序
PLC 在每次扫描周期中都会执行这些语句：
检查每个状态的条件；
如果条件成立，就执行状态切换；
这样保证系统随输入信号动态变化而更新状态。
图中红笔标注如 “S→S” 和 “R→S” 是教授手写提示：
S 表示“置位 (Set)”；
R 表示“复位 (Reset)”；
JPM(C) output 被划掉，是因为那部分是跳转或输出语句，不影响状态逻辑核心。
四、总结：状态转移逻辑总览
当前状态 输入条件 下一状态 动作说明
x₀ (正常) danger=1 x₁ (报警) 红灯亮
x₁ (报警) receipt=1 x₂ (已确认) 红灯灭、黄灯亮
x₂ (已确认) danger=0 且 reset=1 x₀ (正常) 全部灯灭，回归初始
[口语化表达]
这一页其实就是把之前画的状态机图写成了真正能跑的 PLC 指令代码。
它做的事很简单：
如果现在是正常状态（x₀）并且有危险信号，就把 x₀ 清掉、把 x₁ 设为真，也就是红灯亮；
如果在报警状态（x₁）并且操作员按了确认键 receipt，就关掉 x₁、打开 x₂，变成黄灯亮；
最后，如果危险解除且按了 reset，就关掉 x₂、重新设回 x₀，也就是灯全灭回正常。
整段代码其实就是让 PLC 不断地检查这些条件，然后根据情况切换状态。


---

## 第 75 页

![第 75 页](Chapter 3 - Programmable Logic ___lers (slides with annotations)_assets/page-075.png)

这页的主题是：
**如何在自动机（状态机）模型生成的 PLC 程序中，设置或复位输出信号（Set/Reset Outputs）**。
也就是在上一页“状态转移完成”之后，系统根据当前状态去点亮或熄灭相应的指示灯（红灯和黄灯）。

---

## 一、背景回顾

前几页的逻辑：

* 程序通过状态变量 `x0`, `x1`, `x2` 记录系统所处状态：

* `x0`：正常状态（两灯都灭）
* `x1`：报警状态（红灯亮）
* `x2`：已确认状态（黄灯亮）
* 输入有 `danger`, `receipt`, `reset`
* 上一页讲了状态之间怎么“切换”；
* **这一页讲的则是**：切换后不同状态要怎么控制输出灯的亮灭。

---

## 二、代码结构与含义

代码块如下：

```plaintext
output: LD x0
R yellow
R red

LD x1
S red
R yellow

LD x2
R red
S yellow
```

逐段解释如下 👇

---

### （1）正常状态 x₀

```plaintext
LD x0
R yellow
R red
```

**解释：**

* `LD x0`：检查当前状态是否为“正常状态”；
* 如果是：

* `R yellow`：关掉黄灯；
* `R red`：关掉红灯。

👉 对应现实逻辑：系统处于正常状态时，两灯都应熄灭。

---

### （2）报警状态 x₁

```plaintext
LD x1
S red
R yellow
```

**解释：**

* `LD x1`：检查是否在“报警状态”；
* 如果是：

* `S red`：点亮红灯；
* `R yellow`：关掉黄灯。

👉 对应逻辑：出现危险（danger=1）时 → 红灯亮，黄灯灭。

---

### （3）已确认状态 x₂

```plaintext
LD x2
R red
S yellow
```

**解释：**

* `LD x2`：检查是否在“已确认状态”；
* 如果是：

* `R red`：关掉红灯；
* `S yellow`：点亮黄灯。

👉 对应逻辑：操作员确认后，红灯熄灭，黄灯亮起（表示“危险已确认，但尚未复位”）。

---

## 三、总体逻辑关系

| 当前状态     | 红灯 (red) | 黄灯 (yellow) | 含义        |
| -------- | -------- | ----------- | --------- |
| x₀ (正常)  | 关        | 关           | 系统无危险     |
| x₁ (报警)  | 开        | 关           | 处于危险中     |
| x₂ (已确认) | 关        | 开           | 报警已确认，待复位 |

---

## 四、程序执行方式

PLC 在每个扫描周期都会：

1. 先执行状态检查（上页）；
2. 然后执行这一页的输出更新；
3. 这样就能保证灯光状态实时反映系统状态。

---

\[口语化表达]
这页就是在讲：系统根据当前状态去控制灯怎么亮。
如果在正常状态（x₀），那两个灯都关；
如果在报警状态（x₁），红灯亮、黄灯灭；
如果在确认状态（x₂），红灯关、黄灯亮。
整段代码的作用就是“根据当前状态决定灯光输出”，
它让 PLC 在每个循环里自动更新红黄灯的状态。


---

## 第 76 页

![第 76 页](Chapter 3 - Programmable Logic ___lers (slides with annotations)_assets/page-076.png)

这页是**课程的目录页（Content）**，总结了整个章节的学习框架。主要讲的是在工业自动化与 PLC（可编程逻辑控制器）中使用的不同编程方法与设计理念。红色的手写标注是对其中术语的德语解释和补充说明。下面我们逐项详细解释。

---

## 一、主要内容结构

这一页列出了 5 个主要学习模块：

1. **Logic Control（逻辑控制）**
→ 学习基本的逻辑控制概念，比如开关逻辑、真值表、逻辑门（AND、OR、NOT）等。
它是所有自动化程序的基础。

2. **PLC Technology（PLC 技术）**
→ 介绍 PLC 的硬件结构、工作原理、扫描周期、输入输出模块（I/O）等。
这是理解程序怎么在控制器上运行的基础知识。

3. **Programming Languages（编程语言）**
→ 重点讲 IEC 61131 标准下的三种主要 PLC 编程语言：

* **Function Block Diagram (FBD)**：功能块图，图形化语言。
* **Ladder Diagram (LD)**：梯形图，仿电气继电器逻辑，常见于传统控制系统。
* **Instruction List (IL)**：指令表，类似汇编语言，用文本方式描述逻辑。

红色手写标注“**Verknüpfungssprache（逻辑连接语言）**”表示这些语言都是描述逻辑连接关系的编程方式，也就是“逻辑控制语言”。

4. **Model-based Design（基于模型的设计）**
→ 讲如何先建立系统的行为模型，再由模型自动生成 PLC 控制代码。
这种方法常用于复杂系统的自动控制与验证（例如使用 MATLAB/Simulink）。

5. **Sequential Controllers（顺序控制器）**
→ 这一部分介绍控制系统中“有顺序的动作流程”，也就是程序不是一次性执行，而是按“步骤—条件—转换”来运行。
红字注释中写的：

* “**Ablaufsteuerungen（顺序控制）**”：就是“Sequential Control”的德语解释；
* “**Ablaufsprache（顺序语言）**”：表示用于描述这种顺序逻辑的编程语言；
* “**SFC（Sequential Function Chart）**”：是具体的实现方式，也叫“顺序功能图”，IEC 61131 中定义的一种标准顺序控制语言。

---

## 二、总结结构逻辑

| 部分                         | 内容             | 重点        |
| -------------------------- | -------------- | --------- |
| 1️⃣ Logic Control          | 基础逻辑概念         | 学逻辑门和控制逻辑 |
| 2️⃣ PLC Technology         | PLC 硬件与运行机制    | 硬件基础      |
| 3️⃣ Programming Languages  | FBD、LD、IL 三种语言 | 逻辑编程方法    |
| 4️⃣ Model-based Design     | 建模与自动代码生成      | 模型驱动自动化   |
| 5️⃣ Sequential Controllers | 顺序控制系统（SFC）    | 动作序列控制语言  |

---

\[口语化表达]
这一页其实是整个课程的目录说明。前面几部分讲逻辑控制和 PLC 的基本原理，然后讲三种最常见的编程语言：功能块图、梯形图和指令表。接着讲一种更高级的设计方式——模型驱动设计（用模型自动生成 PLC 程序）。最后一部分是顺序控制器，也就是控制系统按步骤一步步执行的逻辑。红色的笔记是在说明这些部分的德语含义，比如“Verknüpfungssprache”是逻辑连接语言，“Ablaufsteuerung”和“SFC”就是顺序控制的部分。


---

## 第 77 页

![第 77 页](Chapter 3 - Programmable Logic ___lers (slides with annotations)_assets/page-077.png)

这页展示了一个顺序控制（Sequential Control）系统的实际例子：
👉 **一个带加料和加热功能的装置（A dosing and heating unit）**。
这是在讲解如何**对一个具有多个操作步骤的工业过程**（比如加料、加热、排放）进行顺序控制。

---

## 一、总体概念

这个例子是一个典型的**顺序过程控制系统（Sequential Process Control System）**，它有：

* 两个储罐（Tank）；
* 若干阀门（Valve）；
* 传感器（Sensor）；
* 顺序执行的操作逻辑（比如：先加料 → 再转移 → 再加热 → 再排放）。

顺序控制的重点就是：
**不同的步骤必须按照既定次序执行，并且每一步需要等待前一步完成后才能开始。**

---

## 二、设备组成及符号解释

图中有两个主要的罐体和四个阀门：

### 1️⃣ **上方罐：dosing tank T1（加料罐）**

* 负责**接收原料（feed）**。
* 顶部入口有一个进料阀 **V1**；
* 底部出口连接下一个加热罐，通过阀 **V2** 控制。

#### 传感器：

* **LIS⁺ (1)**：高液位传感器（Level Indicator Switch，High Level）
→ 表示罐液体已加满。
* **LIS. (2)**：低液位传感器（Low Level）
→ 表示罐液体已排空。

---

### 2️⃣ **下方罐：heating tank T2（加热罐）**

* 从上罐接收液体，通过**V2 打开**流入。
* 内部带有加热装置。
* 液体加热完成后可以通过**V4 排放**。

#### 传感器：

* **TIS⁺ (3)**：温度传感器（Temperature Indicator Switch）
→ 表示加热罐内温度已达到目标温度（例如加热完成）。

---

### 3️⃣ **阀门说明**

| 阀门     | 位置/功能 | 控制逻辑              |
| ------ | ----- | ----------------- |
| **V1** | 进料阀   | 控制加料开始或停止         |
| **V2** | 罐间阀   | 控制从 T1 到 T2 的液体传输 |
| **V3** | 加热介质阀 | 控制加热系统的流体进入（如蒸汽）  |
| **V4** | 排放阀   | 控制排出加热后的液体        |

---

## 三、控制逻辑大致流程（后续章节会展开）

1. **打开 V1** → 向 T1 加料；
当 **LIS⁺** 触发（液位达到满罐） → 关闭 V1。

2. **打开 V2** → 液体从 T1 流入 T2；
当 **LIS.** 触发（T1 空罐） → 关闭 V2。

3. **打开 V3** → 启动加热；
当 **TIS⁺** 触发（温度达到目标） → 关闭 V3。

4. **打开 V4** → 排出加热后的液体；
当排放结束后 → 整个循环完成。

---

## 四、这页图的核心意义

这页图是“**顺序控制（Sequential Control）**”的真实场景建模起点。
接下来的幻灯片会用 SFC（顺序功能图，Sequential Function Chart）来描述它的控制流程。
换句话说，这页相当于**系统结构图 + 控制对象说明**，为后续的程序逻辑设计打下基础。

---

\[口语化表达]
这页就是在举个现实的例子说明什么是顺序控制系统。这里有两个罐子：上面的罐子用来加料（T1），下面的罐子用来加热（T2）。四个阀门控制加料、传输、加热和排放；三个传感器分别检测液位高、液位低和温度。控制逻辑就是一步接一步地执行：先加料，加满了就停；再把料放进下罐；加热到温度够了再排出。整个过程的顺序是固定的，这正是顺序控制器（Sequential Controller）要做的事。


---

## 第 78 页

![第 78 页](Chapter 3 - Programmable Logic ___lers (slides with annotations)_assets/page-078.png)

这页是对上一页“加料与加热装置（dosing and heating unit）”的**顺序控制流程说明（Process specification）**。
它用表格形式定义了每个操作步骤、控制动作和转换条件（Transition Conditions）。
这就是在正式设计 SFC（顺序功能图）之前，**写清楚工艺逻辑顺序的“过程规范（Process Specification）”**。

---

## 一、表格结构说明

表格有三列：

| 列名                              | 含义                     |
| ------------------------------- | ---------------------- |
| **Steps（步骤）**                   | 表示工艺过程中的每个阶段，依次执行。     |
| **Control Actions（控制动作）**       | 这一阶段控制器要做的操作，比如打开某个阀门。 |
| **Transition Conditions（转移条件）** | 当前步骤结束、进入下一步的条件。       |

---

## 二、详细步骤解析

### **1️⃣ Step 1 – Fill T1（填充罐 T1）**

* **控制动作（Control Action）**：打开阀门 V1（by opening V1）开始加料。
* **转移条件（Transition Condition）**：直到液位传感器 **LIS1（高液位）** 被触发。
→ 表示罐 T1 加满。
* **动作逻辑**：加料 → 液位升高 → 传感器触发 → 关闭阀门 → 转下一步。

---

### **2️⃣ Step 2 – Fill T2（填充罐 T2）**

* **控制动作**：打开阀门 V2，让 T1 的液体流入 T2。
* **转移条件**：直到 **LIS2（低液位传感器）** 被触发。
→ 表示 T1 已排空，T2 接收完成。
* **动作逻辑**：开启下流 → 等待上罐排空 → 转到下一步。

---

### **3️⃣ Step 3 – Heat T2（加热罐 T2）**

* **控制动作**：打开阀门 V3（by opening V3），开启加热介质进入加热罐。
* **转移条件**：直到温度传感器 **TIS3** 被触发。
→ 表示液体温度达到目标值。
* **动作逻辑**：开始加热 → 温度上升 → 达到目标温度 → 进入下一步。

---

### **4️⃣ Step 4 – Empty T2（排空加热罐 T2）**

* **控制动作**：打开阀门 V4（by opening V4）。
* **转移条件**：直到罐 T2 被排空（Until T2 is empty）。
* **动作逻辑**：液体流出 → 罐空 → 关闭阀门 → 准备重启循环。

---

### **5️⃣ Step 5 – Go back to step 1（返回步骤 1）**

* 当排空完成后，系统重新回到第 1 步，开始新一轮加料。
* 这说明整个过程是**循环控制（Cyclic Process）**。

---

## 三、流程总体说明

这五个步骤形成一个完整的顺序控制循环：

```
Fill T1 → Fill T2 → Heat T2 → Empty T2 → (Back to Fill T1)
```

箭头旁边标注的“sequence（顺序）”表示这个控制是严格线性的，
即每个步骤必须等待前一个完成后才执行下一个。

这种设计是典型的 **SFC 顺序功能图（Sequential Function Chart）** 的前置逻辑说明。

---

## 四、教学意义

这页是将“物理系统图”（上一页的装置）转换为“逻辑控制规范”的关键环节。
在工程中，这种规范是编程和验证 PLC 顺序程序的基础，
可被后续自动转化为 SFC 图或程序代码。

---

\[口语化表达]
这页其实是在把上一个加料加热装置的运行过程写成“步骤说明书”。
系统要一环接一环地工作：
先往 T1 罐里加料（加满为止），然后打开阀门把液体放进 T2；
接着加热到一定温度，再把加热后的液体排空；
最后整个流程又回到最开始重新循环。
左边的箭头写着“sequence”，意思就是所有操作是有顺序的、不能乱跳。
这张表相当于是在告诉 PLC：每一步干什么、什么时候该进入下一步。


---

## 第 79 页

![第 79 页](Chapter 3 - Programmable Logic ___lers (slides with annotations)_assets/page-079.png)

Something went wrong while generating the response. If this issue persists please contact us through our help center at help.openai.com.


---

## 第 80 页

![第 80 页](Chapter 3 - Programmable Logic ___lers (slides with annotations)_assets/page-080.png)

这页讲的是 **SFC（Sequential Function Chart，顺序功能图）** 的第一个基本组成部分 ——
👉 **Step（步骤）**。

---

## 一、Step 的概念

在 SFC 中，一个“Step（步骤）”代表控制过程中的**一个状态或阶段**。
比如：

* “加料中（Fill Tank）”
* “加热中（Heat Tank）”
* “排空中（Empty Tank）”

每个 Step 都是整个控制流程中的一个独立环节，用矩形框表示。

在图中，这个矩形框里面包含：

* **Name（名称）**：这个步骤的名字，用来说明当前在做什么。
* **No.（编号）**：步骤的编号或标识，方便引用与跳转。

---

## 二、Step 的状态：Active 与 Inactive

每个 Step 都可以处于两种状态之一：

1. **Active（激活）**：
表示系统当前正处于这个步骤中。

* 这个状态下，对应的控制动作会被执行（例如打开阀门、加热等）。
2. **Inactive（未激活）**：
表示该步骤当前没有在执行。

* 控制动作处于等待状态，直到系统流转到此步骤。

SFC 控制逻辑会根据“转换条件（Transition）”在不同 Step 之间切换。
例如：

* 当某个传感器信号触发时，当前 Step 变为 inactive，
* 下一步 Step 被激活，系统动作随之改变。

---

## 三、Step 的功能与意义

Step 起到以下作用：

1. **定义系统的状态**（例如“正在加料”）。
2. **执行对应动作**（例如“打开阀门 V1”）。
3. **等待转换条件**（例如“液位传感器触发”）。
4. **管理顺序执行**：保证过程逻辑按照预定顺序执行，不会混乱。

在整个 SFC 图中，Step 形成一条有序的控制流程。
程序会从一个 Step 激活 → 执行动作 → 条件满足 → 跳转到下一个 Step，
如此循环下去。

---

## 四、图形解释

幻灯片中显示的方框：

```
─────────
|  Name   |
|   No.   |
─────────
```

代表一个步骤（Step）。
竖线表示控制流程的方向。
右边写着 “Can be active or inactive”（可以处于激活或未激活状态），
说明这是一个动态变化的状态节点。

---

\[口语化表达]
这一页就是说：SFC 图里的方框就是“步骤（Step）”，每个步骤代表系统运行的一个阶段，比如“加料”“加热”“排空”等。每个步骤都有名字和编号，用来标识它是谁。步骤有两种状态——激活的（active）表示系统正在执行这个阶段的动作，未激活的（inactive）表示暂时没轮到它。等满足某个条件后，当前步骤结束，下一个步骤被激活。简单讲，这个方框就是流程的一个“阶段节点”，PLC 就是靠这些步骤一个个接力来执行整个控制过程的。


---

## 第 81 页

![第 81 页](Chapter 3 - Programmable Logic ___lers (slides with annotations)_assets/page-081.png)

这页讲的是 **SFC（顺序功能图，Sequential Function Chart）** 的第二个基本元素：
👉 **Actions（动作）**。

---

## 一、什么是 Action（动作）

在 SFC 中，每一个 **Step（步骤）** 都可以附带一个或多个 **Action（动作）**。
这些动作定义了在该步骤“激活”时，系统应该执行什么操作。
简单说：

> **Step = 状态（表示在哪一阶段）**
> **Action = 动作（在这一阶段要干什么）**

例如：

* 在“加料步骤”中，Action 就可能是“打开阀门 V1”；
* 在“加热步骤”中，Action 就可能是“启动加热器”；
* 在“排放步骤”中，Action 可能是“打开排水阀 V4”。

---

## 二、图中各部分说明

### （1）上半部分图解

左边的方框代表一个 **Step（步骤）**，右边连接的矩形框写着 **Action description（动作描述）**，
表示该步骤对应的控制行为。

图中标注的例子：

* “S V1” 的意思是 **Set（置位）阀门 V1**，即让阀门 V1 打开。
* 红色注释 “open V1” 表示该动作的实际含义是“打开阀门 V1”。
* 这个动作只在对应的 Step 处于 **Active（激活）** 状态时执行。

---

### （2）CoDeSys 实现方式

CoDeSys 是一个常用的 PLC 编程环境。
在 CoDeSys 中，SFC 的“动作”也以图形方式连接到步骤。
右侧例子：

```
LD True
S V1
```

表示：

* “LD True” 表示加载常真条件（动作始终执行），
* “S V1” 表示置位输出信号 V1（例如打开阀门）。

也就是说，在 CoDeSys 里，当这个 Step 被激活时，会自动执行 “S V1” 这条指令。

---

## 三、Action 的作用

1. **执行控制命令**（例如打开/关闭阀门、启动加热器）。
2. **连接物理设备与逻辑状态**（Step 代表逻辑阶段，Action 代表实际动作）。
3. **与 Step 的状态绑定**（Step 激活时执行，Step 结束时停止）。

通过这种结构，SFC 不仅能描述“系统在哪一步”，
还明确告诉 PLC“这一步要干什么”。

---

## 四、整体理解

整个图其实展示了 SFC 中“Step → Action”的关系。
Step 表示控制流程的一个阶段，Action 表示该阶段执行的操作。
当 Step 变为 active 时，它触发对应的 Action（例如打开阀门 V1）。
而在 CoDeSys 编程中，这种对应关系会被翻译成具体的指令（如“LD True; S V1”）。

---

\[口语化表达]
这页讲的其实很直白：在 SFC 图里，步骤（Step）只是表示“系统现在在哪个阶段”，但真正要执行的动作——比如“打开阀门”“启动加热器”——是由 Action 来定义的。每个 Step 可以连着一个或多个 Action，当这个 Step 被激活时，这些动作就会被执行。图上那个 “S V1” 就是“打开阀门 V1”的意思。在 CoDeSys 软件里，你会看到它写成“LD True; S V1”，表示这个动作在步骤激活时始终执行。所以简单说，**Step 负责控制流程，Action 负责实际干活。**


---

## 第 82 页

![第 82 页](Chapter 3 - Programmable Logic ___lers (slides with annotations)_assets/page-082.png)

这页讲的是 **SFC（顺序功能图，Sequential Function Chart）** 的第三个核心组成部分：
👉 **Transitions（转换条件）**。

---

## 一、什么是 Transition（转换）

在 SFC 中，**Transition（转换）** 用来连接两个 **Step（步骤）**，
表示“从上一个步骤切换到下一个步骤的条件”。

换句话说：

> Transition 是决定流程何时从当前 Step 跳到下一个 Step 的“触发条件”。

例如：

* 从“加料步骤（Fill Tank）”跳到“加热步骤（Heat Tank）”的条件，可能是“液位传感器 LIS1 = TRUE”；
* 从“加热步骤”跳到“排空步骤（Empty Tank）”的条件，可能是“温度传感器 TIS3 = TRUE”。

---

## 二、图中内容说明

### （1）上半部分（通用 SFC 符号）

图中那条横线代表一个 **Transition bar（转换线）**，
旁边写着 “condition（条件）”，说明只有当这个条件满足时，
控制流程才能从上一个 Step 转换到下一个 Step。

红色标注写着：

```
sensor1 ∧ sensor2
```

意思是：

> 转换条件是 “传感器1 和 传感器2 都为真（True）”。
> 即只有当两个传感器信号都激活时，系统才会从当前步骤跳转到下一个步骤。

---

### （2）下半部分（在 CoDeSys 中的实现）

在 CoDeSys 软件里，Transition 条件用逻辑表达式来写。
例如：

```
LD sensor1
AND sensor2
```

解释如下：

* **LD sensor1**：载入传感器1的状态。
* **AND sensor2**：同时判断传感器2的状态。

这等价于逻辑表达式：

> Transition = sensor1 AND sensor2

也就是说，只有当两个信号都为真时，转换才发生。

---

## 三、Transition 的功能总结

在 SFC 的运行中：

1. 当前 Step 激活时，它会持续执行它的 Action；
2. 系统同时监测 Transition 的逻辑条件；
3. 一旦条件满足，当前 Step 被“去激活”，下一个 Step 被“激活”；
4. 控制流程因此前进到新的阶段。

因此，**Transition 是控制流程的关键“判断点”**，
它确保系统只有在符合条件时才会继续执行下一个动作。

---

## 四、图形理解

可以把这页的图理解为：

```
[Step 1] →───[条件栏（Transition）]───→ [Step 2]
```

上一个 Step 结束，下一个 Step 开始，
取决于条件栏（红线那一条）中的逻辑是否满足。

---

\[口语化表达]
这一页讲的是：SFC 图里那条横线就是“转换条件”（Transition）。它负责决定什么时候从一个步骤跳到下一个步骤。比如我们要从“加料”切换到“加热”，那就得等液位传感器检测到水满，这时候条件才满足。图上写的“sensor1 ∧ sensor2”意思是两个传感器都得为真才能跳过去。在 CoDeSys 软件里，它就写成“LD sensor1; AND sensor2”，代表逻辑与判断。简单讲，Transition 就像流程里的“关卡”，只有条件通过，流程才能继续往下走。


---

## 第 83 页

![第 83 页](Chapter 3 - Programmable Logic ___lers (slides with annotations)_assets/page-083.png)

这页讲的是 **SFC（顺序功能图，Sequential Function Chart）** 的第四个组成部分：
👉 **Connections（连接）**。

---

## 一、什么是 Connections（连接）

在 SFC 中，**连接线（Connections）** 用来**把各个元素（Step、Transition）串联起来**，
形成一个完整的流程逻辑。

可以理解为：

> 连接线决定了控制逻辑的“执行路径”，
> 也就是系统从哪一步开始、怎么过渡到下一步、何时回到起点。

---

## 二、图中结构解析

这张图展示了一个最典型的 SFC 连接结构：
它包含了 **两个 Step（步骤）** 和 **两个 Transition（转换条件）**，并形成一个循环回路。

让我们分段看：

### （1）上方方框

这是第一个 **Step（步骤）**，
表示流程的第一个阶段（比如“加料”）。
这个步骤执行某个动作（例如“打开阀门 V1”）。

### （2）中间的横线

这条横线代表 **Transition（转换条件）**。
表示只有当特定条件满足（比如“液位传感器检测到满”），
系统才会从当前 Step 转移到下一个 Step。

### （3）第二个方框

这是第二个 **Step**，
表示下一个阶段（例如“加热”）。
当系统进入此 Step，它执行对应的动作（例如“打开加热器”）。

### （4）最下面的横线 + 回路箭头

最下面那条横线又是一个 **Transition 条件**，
右侧的箭头说明系统在满足该条件后，
会**回到第一个 Step（上方方框）**，
从而形成一个**循环控制过程**。

也就是说，这个结构表示一个**重复运行的顺序控制逻辑**。

---

## 三、连接线的作用总结

SFC 的连接线（Connections）不仅仅是图形上的连线，
它还隐含了控制系统的运行逻辑。
它的作用包括：

1. **确定执行顺序**：
让 PLC 知道该先执行哪个 Step、再执行哪个。

2. **定义流程方向**：
通过箭头指示数据或逻辑的流向（从上往下或回到上一步）。

3. **形成循环或分支结构**：
通过不同连接方式可以创建循环控制（如加料→加热→排空→再加料）或并行控制。

---

## 四、图示对应的实际意义

这个图实际上代表了一个“循环过程控制”的例子，例如：

1️⃣ **Step 1：加料**
→ 当“液位满”时（Transition 触发）

2️⃣ **Step 2：加热**
→ 当“温度达标”时（Transition 触发）

3️⃣ **返回 Step 1**
→ 再次开始新一轮加料

整个系统就形成一个持续循环的自动控制过程。

---

\[口语化表达]
这一页讲的是：SFC 图里的“连接线”就是把各个步骤和条件串起来的线条。它让整个流程能连成一个闭环，决定了系统怎么从一个状态切换到下一个状态。图上这根线连着两个方框（两个步骤）和两条横线（两个条件），最后又绕回来，意思是这个过程是循环的。比如“加料→加热→再回到加料”，就靠这些连接线来定义顺序和方向。简单说，这页就是告诉我们：**连接线让SFC从静态图变成真正的“流程控制图”。**


---

## 第 84 页

![第 84 页](Chapter 3 - Programmable Logic ___lers (slides with annotations)_assets/page-084.png)

这页讲的是 **SFC（顺序功能图，Sequential Function Chart）** 的第五个组成部分：
👉 **Branching and Joining（分支与合并）**。

这是在顺序控制中用来实现**不同路径的控制逻辑**的关键概念。
它主要分为两种类型：**Alternative（选择分支）** 和 **Parallel（并行分支）**。

---

## 一、Alternative（选择分支）

### （1）概念说明

Alternative 分支表示：

> 系统在某一时刻只能选择**一条路径**来继续执行。

简单说，就是 “要么走 A 路，要么走 B 路”，
不能同时执行两条路径。

### （2）图中结构

上半部分图展示了这种“选择结构”：

* 进入分支前有一个水平线（Transition 条件）；
* 然后分成两条（或多条）支路；
* 每条支路上都有各自的 **Transition 条件**（如 a 或 b）；
* 满足其中之一（a 或 b）时，对应路径被执行。

右边的圆形图也说明了这一点：
一个状态（圆形）可以分出多个选择，但最终只会选择其中一条继续执行。

### （3）实际例子

比如在生产过程中：

* 如果温度过高（a），则执行“冷却”步骤；
* 如果温度正常（b），则执行“继续加热”步骤。

此时程序会根据条件判断走其中一条路径。

---

## 二、Parallel（并行分支）

### （1）概念说明

Parallel 分支表示：

> 系统在某一时刻会**同时执行多条路径**。

简单说，就是“一次启动多个任务并行进行”。

这种结构常用于需要多个设备或过程同时进行的控制逻辑。

### （2）图中结构

下半部分图展示了 Parallel 分支的样子：

* 上方横线是分支起点（同时启动多个 Step）；
* 每个分支路径下都有自己的 Step（动作）；
* 最后在下方又有一条汇合线（joining line），
表示这些并行任务完成后再汇合到主流程。

右边的圆形图形象地表示：
一个状态可以同时分出多条路径，每条路径都被激活执行。

### （3）实际例子

例如在自动化系统中：

* 一个分支控制“阀门打开”；
* 另一个分支控制“温度加热”；
* 还有一个分支记录数据。
这些都可以同时进行，而不用等待上一个结束。

---

## 三、Alternative 与 Parallel 的区别对比

| 类型                    | 执行特点     | 控制逻辑         | 典型用途             |
| --------------------- | -------- | ------------ | ---------------- |
| **Alternative（选择分支）** | 只执行一条路径  | 条件判断 (a 或 b) | 逻辑决策（不同状态选择不同动作） |
| **Parallel（并行分支）**    | 多条路径同时执行 | 同时激活多个 Step  | 并行任务控制（多设备同时运行）  |

---

## 四、总结

分支（Branching）和合并（Joining）让 SFC 从单一路径的顺序控制，
变成可以根据条件选择或并行执行的复杂逻辑结构。
这使得 SFC 不仅能表示简单的“线性控制流程”，
还能表达**条件判断、并发控制和同步操作**等高级行为。

---

\[口语化表达]
这一页讲的是：SFC 图里不仅可以直来直去地控制流程，还能像程序一样做“分支”和“并行”。
如果是 **Alternative（选择分支）**，就相当于“要么走这条，要么走那条”，比如温度高就降温，温度正常就继续加热，只能选一个；
而 **Parallel（并行分支）** 就是“同时干几件事”，比如一个阀门在加料，另一个在加热，两个动作一起进行。
等这些分支都执行完了，再汇合回主流程。
所以简单来说，这页教的就是——**SFC 不光能排队执行，还能根据条件选择路径或多任务并行，让控制逻辑更聪明、更灵活。**


---

## 第 85 页

![第 85 页](Chapter 3 - Programmable Logic ___lers (slides with annotations)_assets/page-085.png)

这页讲的是 **SFC（顺序功能图，Sequential Function Chart）** 的一个非常重要的运行机制：
👉 **Firing Rule（触发规则）**。

也就是说，它解释了 **什么时候 SFC 的转换（Transition）会“触发”**，
以及触发之后会发生什么。

---

## 一、什么是 “Firing Rule（触发规则）”

在 SFC 中，控制流程是由 **Step（步骤）** 和 **Transition（转换条件）** 组成的。
系统运行时，会在某个 Step 处等待，直到对应的 Transition 条件满足，
这时 Transition 会“触发”（fire），流程跳到下一个 Step。

所以 “Firing Rule” 的意思就是：

> 判断一个 Transition 是否可以被激活（触发）并执行跳转的规则。

---

## 二、触发的条件（When a transition fires）

一个 Transition 会触发（fire），必须同时满足以下三个条件：

1️⃣ **前面的所有步骤（preceding steps）都是激活状态（active）**

* 意思是：当前逻辑的上一个 Step 必须处于执行中。
* 如果上一步还没完成（inactive），Transition 不能触发。

2️⃣ **后续的所有步骤（succeeding steps）都是未激活状态（inactive）**

* 说明：新的 Step 还没被激活。
* 因为如果下一个 Step 已经在运行，就不能再次触发。

3️⃣ **转换条件（transition condition）为真（True）**

* 即逻辑判断成立，例如“传感器检测到液位满”或“温度达到设定值”。

只有当这三个条件都同时满足时，Transition 才会触发。

---

## 三、触发之后的动作

一旦 Transition 被触发（fires）：

* 所有前面的 Step（preceding steps）会 **变为未激活（inactive）**，
* 所有后续的 Step（succeeding steps）会 **被激活（active）**。

也就是说，流程正式从上一个阶段切换到下一个阶段。

这就像“开关转换”：
前一个动作结束，下一个动作开始。

---

## 四、Strong vs Weak Firing Rule（强触发规则 vs 弱触发规则）

在不同的系统或软件（例如 CoDeSys、PLC 编程标准）中，
Firing Rule 又可以细分为两种：

| 类型                            | 含义                                             | 特点                |
| ----------------------------- | ---------------------------------------------- | ----------------- |
| **Strong firing rule（强触发规则）** | 要求上一个 Step 彻底完成并失效（inactive）后，Transition 才能触发。 | 更安全、更严格，防止逻辑混乱。   |
| **Weak firing rule（弱触发规则）**   | Transition 只要条件成立即可触发，即使上一个 Step 尚未完全失效。       | 更灵活、更快，但可能带来同步问题。 |

---

## 五、例子理解

比如一个自动化灌装系统：

* **Step 1：** 打开阀门加料；
* **Transition 条件：** 液位传感器 = 满；
* **Step 2：** 关闭阀门。

在这时：

* 当 Step 1 正在运行（active）；
* Step 2 还没启动（inactive）；
* 并且传感器检测到“满”（条件为真）；
→ 这个 Transition 就触发（fire）。

接着系统会：

* 停止 Step 1（关闭加料动作）；
* 启动 Step 2（关闭阀门）。

---

## 六、总结一句话

Firing Rule 是 SFC 的“运行节拍器”，
它决定什么时候从一个状态跳到下一个状态，
确保流程逻辑既连贯又安全。

---

\[口语化表达]
这一页讲的是：SFC 里面的“触发规则”，也就是判断什么时候从一个步骤跳到下一个步骤。
要跳转必须满足三个条件：前面的步骤正在运行，后面的步骤还没开始，而且中间的条件（比如传感器信号）是真的。
一旦满足，这个转换就会触发，前面的步骤结束，后面的步骤开始。
它有两种版本：强规则（等前一步完全结束再跳）和弱规则（只要条件真就能跳）。
简单说，这页就是在告诉我们——**SFC 是靠这些触发规则一步步往前“推进”的，像一台节奏精准的自动机器。**


---

## 第 86 页

![第 86 页](Chapter 3 - Programmable Logic ___lers (slides with annotations)_assets/page-086.png)

这页讲的是 **SFC（顺序功能图，Sequential Function Chart）** 的“触发规则（Firing rule）”的**补充说明（ctd. = continued）**，
重点是当系统中 **有多个转换（Transitions）可以同时触发** 时，该怎么处理 —— 也就是 **“优先级规则（Priority rules）”** 的概念。

---

## 一、核心内容：当多个转换可以同时触发时怎么办？

在一个复杂的 SFC 系统中，可能会出现这种情况：
同一时间有两个或多个转换的条件同时成立。

例如：

* 有两个分支从同一个步骤出发；
* 或者并行的子流程中，都具备触发条件；
* 又或者一个循环结构中，多个路径都满足“可跳转”的逻辑。

这时候系统必须决定：

> 哪一个转换（Transition）**先执行**，
> 哪一个要**等待**或者**被忽略**。

这就需要\*\*优先级规则（Priority Rules）\*\*来规定触发顺序。

---

## 二、Priority Rules（优先级规则）

在 SFC 中，**每一个转换都有一个隐含的优先级顺序**。
当多个转换同时满足条件时，系统按照这些规则依次检查：

1️⃣ **优先级高的转换先触发**。
2️⃣ 如果高优先级转换已经执行，则其他并行可触发的转换不会执行。
3️⃣ 优先级通常由 **图形结构位置** 或 **程序定义顺序** 决定。

例如：

* 在同一级的多条分支中，**从上到下** 或 **从左到右** 的顺序决定优先级；
* 也可以在某些 PLC 软件（如 CoDeSys）中手动设置哪个 Transition 的优先级更高。

---

## 三、举个例子（Example）

虽然这页幻灯片没有画图，但我们可以举个典型例子帮助理解：

假设系统有一个步骤 Step1，后面有两个可能的分支：

* **Transition A：** 条件 = “温度 > 100°C”
* **Transition B：** 条件 = “压力 > 5 bar”

现在，如果温度和压力条件在同一时刻都满足，
系统就要根据“优先级”判断谁先执行。

例如：

* 如果程序定义中 Transition A 的优先级高于 B，
那么系统只会触发 A（执行与温度相关的动作），
而 B 会被暂时忽略，直到下一周期再评估。

---

## 四、为什么需要优先级规则？

优先级规则的存在是为了保证：

* 系统行为是**确定性的（deterministic）**，不会出现不稳定的随机触发；
* 在多个可能路径之间，控制器能按照设计者的意图运行；
* 防止“并发冲突”（多个状态同时被激活导致逻辑错误）。

---

## 五、总结

这一页的重点是强调：

> 在 SFC 的运行中，如果多个 Transition 同时满足触发条件，
> 系统不会乱跳，而是会根据预设的“优先级规则”来选择触发顺序。

换句话说，SFC 的“Firing Rule”不仅规定了**何时**触发，
还规定了**当多个同时能触发时，谁先触发**。

---

\[口语化表达]
这页讲的是：如果一个 SFC 图里有好几条“转换线”同时都满足条件，系统不会傻傻地全都触发，而是会按优先级来决定谁先执行。
比如两个条件同时成立——一个是“温度太高”，一个是“压力太大”——那就要看谁的优先级高，高的那个先执行，另一个等下一次再说。
这样做是为了让流程有条理，不会乱套，也能保证每次运行的结果都一样。
简单说，这页就是在提醒我们：**SFC 在多个路径都能动的情况下，会先挑优先级高的那条路走，保证系统按计划执行。**


---

## 第 87 页

![第 87 页](Chapter 3 - Programmable Logic ___lers (slides with annotations)_assets/page-087.png)

这张图展示的是 **SFC（Sequential Function Chart，顺序功能图）** 的一个完整执行流程示例，用来说明前一页提到的 “**优先级触发规则（Priority Rules）**” 在实际图形中的表现方式。
它体现了 **步骤（Steps）**、**转换条件（Transitions）**、**循环（Loop）** 和 **并行分支（Parallel Branch）** 的逻辑关系。

---

## 一、图的总体结构说明

这幅图从上到下展示了一个典型的 SFC 控制流程：

* 顶部是初始步骤（**Initial Step: A**），
* 接下来系统会根据不同条件（f, g, h, i, j）触发不同的转换，
* 不同路径对应不同控制逻辑，最后形成一个循环控制结构。

---

## 二、详细流程解析

### 1️⃣ 初始步骤 A

* 这是整个流程的起点（用双框表示）。
* 当程序启动时，Step A 自动被激活（Active）。
* 它表示当前系统处于初始状态。

---

### 2️⃣ 从 A 到 B 或 D 的分支

从 A 出发有两个可能的路径：

* **路径 1：A → B（条件 f）**
当条件 **f 为真（true）** 时，Transition f 触发，流程进入 Step B。

* **路径 2：A → D（条件 g）**
当条件 **g 为真（true）** 时，Transition g 触发，流程进入 Step D。

这两个路径之间就涉及到**优先级规则（priority rules）**。
也就是说，如果 f 和 g 同时为真，系统不会同时执行 B 和 D，而是执行优先级高的那一个。
通常优先级取决于图中**位置**（如从上到下或从左到右）或**预先定义的规则**。

---

### 3️⃣ B 分支：B → C

* 如果流程进入 Step B，则下一个 Transition 是 **h**。
* 当 **h 条件满足**时，B 被关闭（inactive），C 被激活。
* 表示流程从 B 过渡到 C 的逻辑。

---

### 4️⃣ D 分支：D → E

* 如果系统选择走右边路径（A→D），则继续检查条件 **i**。
* 当 i 为真时，Transition 触发，D 结束，E 被激活。

---

### 5️⃣ C/E 汇合：返回初始步骤 A

* 无论系统从左侧（C）还是右侧（E）执行完，最后都会通过 **Transition j** 返回到初始步骤 A。
* 这就形成了一个完整的 **循环逻辑（Loop）**。

流程完成后，系统又会从 A 开始，重新进入下一轮逻辑判断。

---

## 三、要点总结

* **f, g, h, i, j** 分别是触发转换的条件。
* **A, B, C, D, E** 是不同的状态（步骤）。
* 整个图展示了 **并行分支**、**条件跳转** 和 **循环回到起点** 的完整过程。
* 当多个转换（如 f 与 g）同时满足时，会依据 **优先级规则** 决定哪个先执行，确保系统运行的确定性。
* 最终结构形成了一个“闭环控制”，即完成一轮动作后回到初始状态。

---

## 四、举个生活例子帮助理解

想象一个自动饮料混合设备：

* Step A：等待开始；
* 如果检测到“果汁”按钮被按下（f），进入 B（果汁模式）；
* 如果检测到“牛奶”按钮被按下（g），进入 D（牛奶模式）；
* 果汁模式（B→C）执行完一轮后回到等待；
* 牛奶模式（D→E）执行完也回到等待；
* j 就是“回到待机”这个条件。

---

\[口语化表达]
这一页画的是一个完整的 SFC 流程图，说明系统怎么从初始状态一步步执行、分支、再循环回来。
比如开始时在 A 状态，如果条件 f 成立就去 B，如果条件 g 成立就去 D，哪个先执行由优先级决定。
左边那条路（A→B→C）和右边那条路（A→D→E）是两条不同的任务线，最后都通过 j 回到 A，重新开始。
所以这张图的意思就是：**系统从起点出发，根据不同条件分成不同路径执行任务，最后再回到起点形成循环，同时用优先级规则来保证不会乱跳。**


---

## 第 88 页

![第 88 页](Chapter 3 - Programmable Logic ___lers (slides with annotations)_assets/page-088.png)

这页讲的是：**SFC（顺序功能图）如何嵌入到 PLC 的扫描周期（scanning cycle）中执行**。
也就是说，当 PLC 控制器运行时，SFC 的每个步骤是如何被周期性执行、更新和输出的。
右边的例子和时序图帮助我们理解每一步在循环中的变化。

---

## 一、PLC 扫描周期中的 SFC 执行流程

PLC（可编程逻辑控制器）运行时是周期性循环执行的，每个扫描周期都依次完成以下五个阶段：

### 1️⃣ 读取输入（Read inputs）

PLC 首先读取所有输入信号的状态，例如按钮、传感器、开关等。
→ 这一步是“感知外界”。

### 2️⃣ 执行动作（Execute actions for active steps）

然后对当前\*\*处于激活状态（active）\*\*的 SFC 步骤执行对应的动作。
例如：打开阀门、加热器启动、马达运转等。

### 3️⃣ 判断可以触发的转换（Determine transitions which can fire）

系统检查当前有哪些转换条件（transition conditions）为真（True），
也就是哪些步骤**符合跳转条件**。

### 4️⃣ 触发转换（Fire transitions）

当满足触发条件时，对应的转换执行：

* 前一个步骤（Step）变为未激活（inactive），
* 下一个步骤变为激活（active）。
这就实现了**逻辑状态的切换**。

### 5️⃣ 写出输出（Write outputs）

最后，PLC 把本周期产生的输出（例如阀门信号、电机信号等）发送到外部设备。
→ 这是“对外执行”的阶段。

然后，PLC 马上进入下一轮扫描周期，重复以上 1\~5 步。

---

## 二、图示例解析（Example）

左边的 SFC 图包含 4 个步骤（1 → 2 → 3 → 4），每个步骤控制不同的动作：

* **Step 1：** 初始状态
* **Step 2：** 条件 “start” 为真时进入，执行 `V1 := true`（打开阀门1）
* **Step 3：** 当条件 “true” 成立时，执行 `V1 := false, V2 := true`（关闭阀门1，打开阀门2）
* **Step 4：** 当条件 “stop” 为真时，执行 `V2 := false`（关闭阀门2，停止系统）

右侧的时序图显示了随时间（横轴）信号的变化：

* “start” 信号触发后，进入 Step 2，V1 打开；
* 再经过转换，进入 Step 3，V1 关闭、V2 打开；
* 当“stop” 信号为真时，进入 Step 4，V2 关闭；
* 系统完成一轮循环。

红色箭头表示扫描周期的进展，每次扫描执行一遍上述五个步骤。
这保证了系统能稳定、周期性地更新状态。

---

## 三、要点总结

* PLC 每个扫描周期都按固定顺序执行：
输入 → 动作 → 判断转换 → 执行转换 → 输出
* 每个 SFC 步骤的执行都在这个循环中完成，保证逻辑连续。
* 示例展示了阀门控制的典型切换逻辑：
起动（V1 开）→ 切换（V2 开）→ 停止（全关）。
* 这种机制让 PLC 的反应速度稳定、可预测。

---

\[口语化表达]
这一页讲的是：SFC 的每一步其实是被嵌在 PLC 的循环里运行的。PLC 每次循环都会先读输入信号，然后执行当前步骤的动作，再判断哪些转换条件满足，触发相应的跳转，最后把新的输出写出去。
右边那个图举的例子就是控制两个阀门的过程：按下 start 时打开 V1，再切换到下一个步骤关闭 V1 打开 V2，最后按 stop 全部关掉。
简单说，这页就是在告诉我们：**SFC 是跟着 PLC 一圈圈扫描执行的，每一轮都按“读输入 → 执行动作 → 判断跳转 → 执行切换 → 写输出”来走，所以整个系统能稳定、有节奏地运行。**


---

## 第 89 页

![第 89 页](Chapter 3 - Programmable Logic ___lers (slides with annotations)_assets/page-089.png)

这页图展示的是一个典型的 **加料与加热罐系统（Dosing and Heating Tank）** 的工艺示意图，它是工业自动化和过程控制中非常常见的模型，用来说明如何通过 **阀门（Valves）和传感器（Sensors）** 控制物料的流动、加热与排放。

---

## 一、系统组成与结构说明

整个系统由 **两个罐（T1 和 T2）** 以及若干 **阀门（V1–V4）** 和 **传感器（LIS、TIS）** 组成：

### 1️⃣ Dosing tank T1（加料罐）

* **功能**：用于储存和初步计量（dosing）原料。
* **进料阀 V1**：控制原料的进入。
* **出料阀 V2**：控制物料流向下一个罐（T2）。
* **液位传感器 LIS⁺ (1)**：检测液位是否达到上限。
* **液位传感器 LIS. (2)**：检测液位是否达到下限或特定高度。

这两个传感器帮助系统判断什么时候停止进料、什么时候允许出料。

---

### 2️⃣ Heating tank T2（加热罐）

* **功能**：接收来自 T1 的液体，并加热到目标温度。
* **进料阀 V2**：与上罐共享，用于进入加热罐。
* **加热阀 V3**：控制加热过程（通常控制热水或蒸汽进入加热盘管）。
* **出料阀 V4**：在加热完成后打开，用于排空或输送到下一个工序。
* **温度传感器 TIS⁺ (3)**：检测温度是否达到设定上限（或目标加热温度）。

---

## 二、系统工作流程（逻辑顺序）

1️⃣ **填充加料罐 T1**

* 打开 V1 → 液体从 feed 进入 T1；
* 当液位传感器 **LIS⁺** 检测到液面到达上限时，关闭 V1，停止进料。

2️⃣ **将液体转移到加热罐 T2**

* 打开 V2 → 物料从 T1 流向 T2；
* 当 T1 的下液位传感器 **LIS.** 检测到液位下降到最低点时，关闭 V2。

3️⃣ **加热过程**

* 打开 V3 → 开启加热；
* 当温度传感器 **TIS⁺** 检测到液体达到设定温度时，关闭 V3，停止加热。

4️⃣ **排空加热罐**

* 打开 V4 → 液体排出或流向下一个流程；
* 当 T2 排空后，关闭 V4；
* 整个循环重新开始。

---

## 三、控制逻辑特点

这个系统的设计非常适合使用 **顺序功能图（SFC）** 来描述，因为它是一个典型的 **分步式顺序控制过程**：
每个步骤（Step）都有明确的起始条件、执行动作（开阀/关阀）、结束条件（传感器信号）和下一个转换。

同时，它还具备：

* **条件触发性**（基于传感器信号触发）
* **动作互锁性**（防止多个阀同时开启导致事故）
* **周期性运行**（完成后自动回到初始状态）

---

## 四、对应的 SFC 元素关系

| SFC 步骤 | 控制动作        | 转换条件        |
| ------ | ----------- | ----------- |
| Step 1 | 打开 V1（进料）   | LIS⁺ = True |
| Step 2 | 打开 V2（转移液体） | LIS. = True |
| Step 3 | 打开 V3（加热）   | TIS⁺ = True |
| Step 4 | 打开 V4（排液）   | 液位传感器检测到空罐  |

最后系统返回 Step 1，形成循环。

---

## 五、总结

这页主要说明一个“**加料 + 加热 + 排放**”的工艺设备结构，为后面顺序控制逻辑（SFC 程序设计）做准备。
它展示了信号（传感器）如何与控制元件（阀门）协同工作，形成自动化控制循环。

---

\[口语化表达]
这一页画的是一个加料和加热系统的结构图，整个过程就是液体从上罐进料（V1 控制），液位满了后关闭，再通过 V2 流到下罐。下罐（T2）负责加热，用 V3 控制加热，温度到位后再通过 V4 把液体排出去。
LIS 传感器是测液位的，TIS 是测温度的，它们给控制系统提供信号，让 PLC 知道什么时候开、什么时候关。
简单说，这个系统就像一个自动煮汤锅：上面加料、下面加热，温度够了就放出来，整个过程自动循环。


---

## 第 90 页

![第 90 页](Chapter 3 - Programmable Logic ___lers (slides with annotations)_assets/page-090.png)

这页图展示的是 **“加料与加热罐系统（Dosing and Heating Tank）”的顺序功能图（SFC）实现逻辑**。
它对应上一页的设备结构图，说明了在 PLC 程序中，这个系统是如何通过步骤（Steps）、条件（Transitions）和动作（Actions）来控制阀门的开启与关闭。

---

## 一、整体思路

这张图是用 **SFC（Sequential Function Chart，顺序功能图）** 描述的自动化流程控制逻辑。
系统的状态按顺序从 **idle → Fill T1 → Fill T2 →（后续步骤）** 转换，
每个步骤都对应一个控制动作（例如打开或关闭阀门），
而转换条件则由液位传感器的信号（LIS1、LIS2）决定。

---

## 二、详细说明

### 1️⃣ 初始状态：**idle（空闲状态）**

* 系统刚启动时处于 idle（空闲）状态。
* 这一状态下不执行任何阀门操作，系统等待“启动信号（start）”。
* 一旦接收到 **start = True**，就进入下一个步骤。

---

### 2️⃣ Step 1：**Fill T1（填充上罐 T1）**

* 动作：`open V1`（打开阀门 V1） → 液体从 feed 进入罐 T1。
* 转换条件：`LIS1 = True`

* 这表示液位传感器 LIS1 检测到液体达到上限。
* 当条件满足，说明上罐已经填满，可以进入下一步。

💡 **控制逻辑说明：**

> “当上罐 T1 被填满时，系统自动关闭 V1 并准备向下罐放料。”

---

### 3️⃣ Step 2：**Fill T2（填充下罐 T2）**

* 动作：

* `close V1`（关闭 V1，停止向上罐进料）
* `open V2`（打开 V2，让液体从 T1 流向 T2）
* 转换条件：`LIS2 = False`

* LIS2 是下罐的液位检测器。
* 当 LIS2 表示液位“未满”（False）时，V2 保持打开。
* 当 LIS2 检测到液体已达到满位（True），则结束本步骤。

💡 **控制逻辑说明：**

> “上罐装满 → 打开 V2 把液体放入下罐；
> 下罐装满后，关闭 V2，准备进入加热步骤。”

---

### 4️⃣ 过程循环关系

图中底部的线条说明 **整个系统是循环运行的**：
完成加料与转移后，系统会返回初始状态（idle），等待下一次启动信号。
在完整系统设计中，这之后通常还会有 **加热（Heat T2）** 和 **排空（Empty T2）** 的步骤。

---

## 三、核心逻辑总结

| 步骤      | 动作                | 触发条件              | 控制逻辑       |
| ------- | ----------------- | ----------------- | ---------- |
| idle    | 无动作               | start=True        | 系统待机 → 启动  |
| Fill T1 | open V1           | LIS1=True         | 上罐填满，关闭 V1 |
| Fill T2 | close V1, open V2 | LIS2=False → True | 下罐填满，关闭 V2 |
| （返回）    | 回到 idle           | 过程循环              | 等待新一轮操作    |

---

## 四、控制意义

* 这是典型的 **自动化顺序控制逻辑**：
按条件逐步执行 → 每个步骤有开始动作与结束条件。
* 系统通过液位传感器自动判断“罐是否满”或“是否空”，
无需人工干预，PLC 会自动切换状态。
* 逻辑清晰、稳定可靠，适合工业场景（如化工加料、饮料生产等）。

---

\[口语化表达]
这一页展示的是加料加热系统的自动控制逻辑图。
一开始系统是 idle（空闲），等到收到 start 信号后进入 Fill T1，这时打开阀门 V1 给上罐加料。
当液位传感器 LIS1 检测到罐满后，就关闭 V1，进入 Fill T2 步骤，打开 V2 把液体放到下罐。
等下罐液位 LIS2 也到满，就结束这一步，系统可以进入下一轮或加热阶段。
简单来说，这页讲的是：**系统自动控制阀门开关，靠液位传感器判断什么时候加料、什么时候转移，实现全自动的顺序操作流程。**


---

## 第 91 页

![第 91 页](Chapter 3 - Programmable Logic ___lers (slides with annotations)_assets/page-091.png)

这页图展示的是 **“加料与加热罐（Dosing and Heating Tank）”系统的完整 SFC（顺序功能图）控制流程**。
与前一页相比，这里包含了**整个自动化循环过程**——从加料、加热、排空到等待再启动，描述了完整的工业控制逻辑。

---

## 一、整体逻辑概览

这一页的 SFC 包含两个并行的分支（Parallel Branches）：

* **右侧分支：** 负责上罐 T1 的加料逻辑（Fill T1）
* **左侧分支：** 负责下罐 T2 的加热、排空、等待循环（Heat up → Empty T2 → Wait）

两者之间通过传感器信号（液位、温度）进行协调，使整个流程循环运行。

---

## 二、右侧逻辑（Fill T1）

### 1️⃣ Step：fill T1（填充上罐）

* **执行动作：**

* `close V2`（先关闭下罐的进料阀）
* `open V1`（打开上罐的进料阀）
→ 这表示正在向上罐 T1 加料。
* **转换条件：** `LIS1 = True`

* 当上罐液位传感器检测到液位已满时，结束加料阶段。

### 2️⃣ Step：wait’（等待）

* **执行动作：** `close V1`

* 当 T1 加满后，关闭 V1，结束加料。
* **此阶段等待左侧（加热部分）的流程完成**，保证协调运行。

---

## 三、左侧逻辑（Heat, Empty, Wait）

### 1️⃣ Step：heat up（加热阶段）

* **执行动作：** `open V3`（打开加热阀）
* **转换条件：** `TIS3 = True`

* 当温度传感器检测到目标温度达到时（T2 加热完成），结束加热阶段。

---

### 2️⃣ Step：empty T2（排空阶段）

* **执行动作：**

* `close V3`（关闭加热阀）
* `open V4`（打开排液阀）
* **转换条件：** `Empty_T2. T ≥ Time`

* 当排空时间达到预设值（表示罐内液体已排空）时，关闭阀门并进入下一步。

---

### 3️⃣ Step：wait（等待阶段）

* **执行动作：** `close V4`（关闭排液阀）
* **转换条件：** `True`（即恒为真）

* 这意味着一旦等待阶段结束，流程会循环回到初始阶段（再次加料、加热、排放）。

---

## 四、循环机制

整个流程在 PLC 程序中会**不断循环执行**，实现自动化控制：
1️⃣ 加料（Fill T1） →
2️⃣ 加热（Heat up） →
3️⃣ 排空（Empty T2） →
4️⃣ 等待（Wait） →
再回到起点重新执行。

这个循环保证：

* 罐体之间协调工作；
* 每个阀门动作受传感器信号控制；
* 生产过程连续、自动、可控。

---

## 五、控制逻辑总结

| 步骤       | 动作                | 转换条件        | 控制目的     |
| -------- | ----------------- | ----------- | -------- |
| Fill T1  | close V2, open V1 | LIS1 = True | 填满上罐     |
| wait’    | close V1          | True        | 等待下罐处理完成 |
| Heat up  | open V3           | TIS3 = True | 加热至目标温度  |
| Empty T2 | close V3, open V4 | T ≥ 设定时间    | 排空下罐     |
| Wait     | close V4          | True        | 等待下一个循环  |

---

## 六、要点总结

* 右边控制上罐进料；左边控制下罐加热与排放；
* 两边同时工作但协调运行（并行分支）；
* 传感器（液位、温度）信号是关键的切换条件；
* 整个系统实现了**自动循环控制**（从加料到排空再回到初始状态）。

---

\[口语化表达]
这一页展示的是整个“加料加热系统”的自动控制流程。右边那条线控制上罐的加料，左边那条线控制下罐的加热、排液和等待。
流程是这样的：系统先给上罐加料（V1 打开、V2 关），上罐满了之后停下来。与此同时，下罐加热（V3 打开），温度够了之后就排液（V4 打开），排完再关掉等下一轮。
等这两边都完成后，系统又会自动回到最初状态重新开始。
简单说，这张图就是一个全自动的生产循环：加料 → 加热 → 排空 → 等待 → 再加料，全过程由传感器信号自动控制阀门的开关。


---

## 第 92 页

![第 92 页](Chapter 3 - Programmable Logic ___lers (slides with annotations)_assets/page-092.png)

这页展示的是 **“加料与加热罐系统（Dosing and Heating Tank）”的完整顺序功能图（SFC complete view）**。
它把之前几页的分步控制逻辑（加料、加热、排空、等待）全部整合到了一张完整的自动化控制流程图中。
这张图可以看作是整个 **工业过程控制的核心逻辑框架**，非常典型地展示了顺序控制系统在 PLC 程序中的结构化实现方式。

---

## 一、整体结构概览

这张完整 SFC 图将整个流程从 **系统空闲（idle）开始**，经过一系列控制步骤，再循环回到初始状态，实现一个自动重复的工业过程。

流程可以分为四个主要阶段：

1. **初始状态与启动阶段（idle → Fill T1）**
2. **加料阶段（Fill T1 → Fill T2）**
3. **加热与排空阶段（Heat up → Empty T2 → Wait）**
4. **同步加料（右侧 Fill T1 分支）**

最后所有流程同步结束，重新进入新的循环。

---

## 二、详细逻辑步骤解析

### 1️⃣ 初始状态 idle（空闲状态）

* **动作：** 无操作
* **条件：** 当收到启动信号 `start` 时，流程开始进入 Fill T1 步骤。
* **目的：** 系统处于待机状态，等待启动。

---

### 2️⃣ Fill T1（填充上罐 T1）

* **动作：** `open V1`（打开进料阀 V1）
* **条件：** 当液位传感器 `LIS1 = True`（表示上罐已满）时，关闭 V1，进入下一阶段 Fill T2。
* **逻辑意义：** 上罐加满，准备向下罐输送。

---

### 3️⃣ Fill T2（填充下罐 T2）

* **动作：**

* `close V1`（关闭进料阀）
* `open V2`（打开输送阀）
* **条件：** 当下罐液位传感器 `LIS2 = False`（下罐未满）时持续加料；当检测到液位到达设定值后，关闭 V2。
* **说明：** 液体从上罐流入加热罐，为下一步“加热”做准备。

---

### 4️⃣ Heat up（加热阶段）

* **动作：** `open V3`（打开加热阀）
* **条件：** 当温度传感器 `TIS3 = True` 时，表示目标温度已达到。
* **说明：** 加热罐（T2）中的液体被加热至设定温度。

---

### 5️⃣ Empty T2（排空阶段）

* **动作：**

* `close V3`（关闭加热阀）
* `open V4`（打开排放阀）
* **条件：** 当排放持续时间 `T ≥ Time` 达到预设值后，关闭 V4。
* **说明：** 加热完成后，液体从 T2 排出，用于下一工序或输出。

---

### 6️⃣ Wait（等待阶段）

* **动作：** `close V4`（确保排液阀关闭）
* **条件：** 满足同步条件（右侧分支完成）后，流程回到起点。
* **说明：** 系统处于等待状态，确保所有动作完成并准备下一个循环。

---

### 7️⃣ 右侧分支：同步加料（fill T1 / wait’）

右侧分支是为了让 **上罐（T1）** 在下罐（T2）排空的同时进行下一轮加料，实现“流水线并行操作”。

* **fill T1：**

* 动作：`close V2`, `open V1`（重新开始向上罐加料）
* 条件：`LIS1 = True`（上罐再次加满）
* **wait’：**

* 动作：`close V1`
* 说明：等待下罐完成排空，再进入下一轮。

💡 这样可以让系统在加热罐排空时，上罐已经在准备下一批物料，从而提高生产效率。

---

## 三、循环条件

底部的连线标注 “**True**” 表示系统循环条件始终成立。
也就是说，当整个流程执行完一次后，系统会**自动回到起点（idle）重新执行下一轮**。

这一循环机制使得整个加料-加热-排空过程可以连续自动运行，不需要人工干预。

---

## 四、关键逻辑总结

| 阶段 | 步骤               | 控制动作               | 转换条件            | 功能说明      |
| -- | ---------------- | ------------------ | --------------- | --------- |
| 启动 | idle → Fill T1   | open V1            | start 信号        | 系统开始工作    |
| 加料 | Fill T1          | open V1 → close V1 | LIS1=True       | 填满上罐      |
| 转移 | Fill T2          | open V2 → close V2 | LIS2=False→True | 上罐液体流入下罐  |
| 加热 | Heat up          | open V3 → close V3 | TIS3=True       | 加热至目标温度   |
| 排空 | Empty T2         | open V4 → close V4 | T ≥ Time        | 清空下罐      |
| 等待 | Wait             | close V4           | True            | 进入循环      |
| 并行 | Fill T1’ / Wait’ | open V1 / close V1 | LIS1=True       | 上罐准备下一轮加料 |

---

## 五、总体意义

* 该系统是一个典型的 **顺序控制 + 并行分支控制** 示例；
* 它体现了工业控制中 **多阶段、互锁、安全、自动循环** 的特性；
* 所有动作均由传感器信号（LIS、TIS）驱动，避免人为操作错误；
* 该结构在 **PLC 程序（如 CoDeSys、Siemens TIA Portal）** 中非常常见。

---

\[口语化表达]
这一页展示的是整个“加料加热罐系统”的完整自动控制流程图，也就是所有动作合在一起后的总逻辑。
一开始系统处于 idle（空闲），收到 start 信号后开始给上罐 T1 加料（V1 打开）。
上罐满了以后，液体流到下罐 T2（V2 打开），等下罐装好后，就开始加热（V3 打开）。
温度够了再排液（V4 打开），排完液体后关闭阀门等待。
同时，右边那条分支会在下罐处理的同时，提前再给上罐加料，这样就能节省时间，实现“流水线式并行工作”。
最后系统会自动回到开始状态，继续下一轮循环。
简单来说，这张图展示的是一个全自动、循环运行的加料加热系统，每个动作都由传感器控制，整个过程不需要人工干预。
