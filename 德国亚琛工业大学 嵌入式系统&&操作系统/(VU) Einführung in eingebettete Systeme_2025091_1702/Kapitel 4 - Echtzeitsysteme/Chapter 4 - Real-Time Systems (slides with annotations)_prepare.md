

---

## 第 1 页

![第 1 页](Chapter 4 - Real-Time Systems (slides with annotations)_assets/page-001.png)

这张海报是 **亚琛工业大学（RWTH Aachen University）计算机系举办的年度活动——“Tag der Informatik 2025”（计算机科学日）** 的宣传图。
它详细介绍了活动日期、时间、地点以及当天的活动安排，包括招聘会（Job Fair）和晚间派对（Party）。这类活动通常面向计算机学院的学生和企业，用来促进交流、招聘实习生、展示科研成果等。

---

## 一、活动主题与时间

* **活动名称：**
“Tag der Informatik 2025”
（英文翻译：Day of Computer Science 2025）
* **活动日期：**
**2025年6月5日（星期四）**
* **主办单位：**
亚琛工业大学（RWTH Aachen）计算机科学系
主办方：人工智能方法学教研组（Chair of Artificial Intelligence Methodology，i14）
* **组织与联系方式：**
负责人：**Katharina Isabel Franke**
联系邮箱：**[tdi@cs.rwth-aachen.de](mailto:tdi@cs.rwth-aachen.de)**
地址：**Theaterstrasse 35-39, 52062 Aachen, Germany**

---

## 二、活动内容与时间安排

### 1️⃣ 招聘会（Job Fair）

* **时间：** 上午 10:30 – 下午 16:00
* **地点：** Computer Science Center (E2)
* **额外信息：** 可以领取冰淇淋和晚会入场手环（wristbands）
* **活动目的：**

* 提供学生与IT公司面对面交流的机会
* 了解实习和工作岗位信息
* 与潜在雇主建立联系

这部分相当于是校园招聘会，有多家知名企业参与（见下方赞助商名单）。

---

### 2️⃣ 晚间派对（Party）

* **时间：** 晚上 20:00 – 次日凌晨 00:30
* **地点：** Das LIEBIG（地址：Liebigstraße 19）
* **入场要求：** 必须佩戴腕带（Wristband required）
* **说明：**
这是学生与公司、教授、校友的轻松社交时间，属于活动的娱乐环节。

---

## 三、参与企业与赞助商

参与或赞助活动的公司和机构包括：

* **INFORM**
* **itestra**
* **LANCOM Systems**
* **Vector**
* **CONSILEON**
* **Worldline**
* **think-cell**
* **REWE Digital**
* **Cisco**
* **DSA**
* **Ampiron**
* **Oculavis**
* **Soptim**
* **ModuleWorks**
* **EPG**
* **IVU Traffic Technologies**
* **MAGMA**

这些公司涵盖软件开发、工业自动化、云计算、数据分析、交通管理等多个领域，为计算机专业的学生提供丰富的职业方向。

---

## 四、其他说明

* 官方网站：**[www.tdi.ac](http://www.tdi.ac)**
上面会提供更多日程安排与公司信息。
* 海报底部显示了本活动是课程 **“Introduction to Embedded Systems | Part 4 – Real-Time Systems”** 的内容结尾页之一，由 **Prof. Dr.-Ing. Stefan Kowalewski** 授课。

---

## 五、总结与意义

“Tag der Informatik” 是 RWTH Aachen 的年度传统活动，类似“计算机学院开放日”，结合了：

* **学术展示**（教授与学生项目展）
* **职业招聘**（企业展台、实习机会）
* **社交交流**（晚间派对）

对学生而言，这是结识公司、探索实习、体验学术氛围的好机会；
对企业而言，这是物色人才、展示品牌的重要平台。

---

\[口语化表达]
这张海报是在宣传亚琛工业大学计算机学院的年度活动“计算机科学日 2025”。
活动在 6 月 5 日举行，白天是招聘会（10:30 到 16:00），有很多知名 IT 公司来学校摆展台，还能免费吃冰淇淋、拿晚会手环。
晚上 8 点到凌晨 0 点半会在 Liebig 街的一个场地办派对，只要有手环就能进。
整个活动是由 RWTH 计算机系主办的，既有职业交流也有娱乐社交，是那种学生和公司都喜欢的年度盛会。


---

## 第 2 页

![第 2 页](Chapter 4 - Real-Time Systems (slides with annotations)_assets/page-002.png)

这张幻灯片是课程 **《Introduction to Embedded Systems》（嵌入式系统导论）** 的 **第四部分——Real-Time Systems（实时系统）** 的标题页。
它来自德国亚琛工业大学（RWTH Aachen University）计算机科学系，由 **Stefan Kowalewski 教授** 和 **Julius Kahle 硕士** 主讲，时间是 **2025年夏季学期（Summer Semester 2025）**。

---

## 一、课程整体信息说明

* **课程编号：** 12.24196
* **课程名称：** *Introduction to Embedded Systems*（嵌入式系统导论）
这是一门讲解嵌入式系统设计、控制逻辑、编程语言和实时性分析的基础课程。
* **授课教师：**

* **Prof. Dr.-Ing. Stefan Kowalewski** —— 亚琛工业大学信息学院教授，专攻嵌入式系统与控制技术。
* **Julius Kahle, M.Sc.** —— 研究助理或讲师，协助教学。
* **课程机构：**

* RWTH Aachen University
* Informatik 11（嵌入式软件研究组，Embedded Software Group）

---

## 二、内容主题：Part 4 – Real-Time Systems

这部分是整个课程的第四单元，主要内容围绕 **“实时系统（Real-Time Systems）”** 展开。
在嵌入式系统课程中，“实时系统”是核心内容之一。它研究系统**在特定时间约束下正确响应外部事件**的能力。

### 关键学习方向包括：

1. **实时性的定义与分类**

* 硬实时系统（Hard Real-Time）：必须在严格时间内完成任务，否则系统失败。
* 软实时系统（Soft Real-Time）：超时会导致性能下降，但系统仍能运行。

2. **任务调度（Task Scheduling）**

* 如何在 CPU 资源有限的情况下合理安排多个任务。
* 常见算法：Rate Monotonic Scheduling（RMS）和 Earliest Deadline First（EDF）。

3. **时间分析与响应时间计算**

* 计算最坏执行时间（WCET）
* 保证系统在所有情况下都能按时完成。

4. **优先级反转与同步机制**

* 多任务并发运行时的资源共享与锁定问题。
* 解决方式：优先级继承（Priority Inheritance）。

5. **实时操作系统（RTOS）**

* 介绍如 FreeRTOS、RT-Linux 等系统架构与调度原理。

---

## 三、设计风格与机构标识

幻灯片顶部展示：

* **RWTH Aachen University 标志**（德国顶尖工科大学）
* **Informatik 11 – Embedded Software**（嵌入式软件研究组）标识
→ 表示课程内容属于计算机科学学院中的嵌入式软件方向。

蓝白配色与黄色块设计代表 RWTH 的官方模板风格，简洁明快，符合学术规范。

---

## 四、课程结构背景（从前几部分延伸）

这门课前面几部分一般依次是：
1️⃣ 嵌入式系统基础与逻辑控制（Logic Control）
2️⃣ PLC（可编程逻辑控制器）与工业应用（PLC Technology）
3️⃣ 嵌入式编程语言（Programming Languages）
→ 而第四部分（Part 4）进入更高级主题：**实时系统控制与调度**。

也就是说，前面讲“怎么控制”，现在讲“在多任务下如何按时控制”。

---

## 五、核心意义

实时系统是嵌入式领域的灵魂。它确保汽车刹车、工业机械、医疗设备、无人机等**在正确的时间点执行正确的操作**。
学习这一部分后，学生将理解：

* 时间约束对嵌入式设计的重要性
* 如何分析系统的执行时间与可靠性
* 如何实现安全、可预测的控制逻辑

---

\[口语化表达]
这一页就是《嵌入式系统导论》第四部分——“实时系统”的封面。
简单来说，这部分主要讲的就是那些需要在“规定时间内完成任务”的系统，比如汽车的安全气囊、飞机控制、工业机器人等。
它由亚琛工业大学的 Kowalewski 教授和 Julius Kahle 主讲，属于嵌入式软件方向的核心课程。
在前几章学完控制逻辑和编程语言之后，这一章就是讲系统“怎么在时间上保证反应足够快、够准”。
也就是说，从现在开始，课程要进入“时间就是生命”的阶段——真正让系统在现实世界中安全又高效地运行。


---

## 第 3 页

![第 3 页](Chapter 4 - Real-Time Systems (slides with annotations)_assets/page-003.png)

这张幻灯片是本课程 **《Introduction to Embedded Systems（嵌入式系统导论）》** 第四部分——**Real-Time Systems（实时系统）** 的内容目录页。
它列出了本章节要讲的五个主要主题，涵盖了**实时系统设计的核心要素**，尤其是关于任务调度与优先级管理的部分。幻灯片上手写红色标注圈出了 **“Scheduling（调度）”**，并且用箭头指向第 4 和第 5 点，说明这三点（调度、死锁与优先级反转、优先级天花板与继承）是相互关联的重点内容。

---

## 一、五个主要学习主题解释

### 1️⃣ Real-Time Requirements（实时性需求）

这一部分讨论实时系统的**时间约束**。
在嵌入式系统中，有些任务必须在**规定时间内**完成，否则会导致系统故障或性能下降。
内容包括：

* 硬实时系统（Hard Real-Time）：如刹车系统、航天控制——超时即失败。
* 软实时系统（Soft Real-Time）：如视频播放、网络通信——允许轻微延迟。
还会讨论响应时间（Response Time）、截止时间（Deadline）和抖动（Jitter）等关键指标。

---

### 2️⃣ Real-Time Operating Systems – Example OSEK（实时操作系统示例 OSEK）

这一部分介绍**实时操作系统（RTOS）** 的作用及结构，特别是汽车工业标准 **OSEK/VDX**。
它主要用于协调多个实时任务，使系统可以预测并可靠地运行。
内容包括：

* 任务管理（Task Management）
* 中断与调度（Interrupt Handling & Scheduling）
* 资源共享（Resource Management）
OSEK 是一种典型的轻量化 RTOS，在车载系统中应用广泛，如发动机控制、ABS、防碰撞系统等。

---

### 3️⃣ Scheduling（调度）

这是红圈标注的重点。
“调度”是实时系统的核心问题之一，指**如何决定哪个任务在什么时候执行**。
内容包括：

* **调度算法（Scheduling Algorithms）：**

* Rate Monotonic Scheduling (RMS)：周期短的任务优先。
* Earliest Deadline First (EDF)：截止时间最近的任务优先。
* **可调度性分析（Schedulability Analysis）：**
判断在给定条件下系统能否按时完成所有任务。

调度决定系统是否能“准时响应”，是实时性的根基。

---

### 4️⃣ Deadlocks & Priority Inversion（死锁与优先级反转）

这一部分讲解多任务系统中**资源竞争问题**：

* **死锁（Deadlock）：** 多个任务互相等待对方释放资源，导致系统卡死。
* **优先级反转（Priority Inversion）：**
高优先级任务被低优先级任务阻塞，导致实时性受损。
例如：
高优先级任务等待一个低优先级任务持有的锁，而中优先级任务不断抢占 CPU，使得高优先级任务迟迟无法执行。
（NASA 的 *Mars Pathfinder* 就曾因为这个问题而宕机。）

---

### 5️⃣ Priority Ceiling & Inheritance（优先级上限与继承）

这是解决第 4 点问题的机制。

* **Priority Inheritance（优先级继承）：**
当低优先级任务占有资源阻塞高优先级任务时，临时“继承”高优先级，以便尽快释放资源。
* **Priority Ceiling（优先级天花板协议）：**
给每个资源定义一个最高优先级上限，防止死锁和优先级反转。

它们是实时系统中**资源同步与调度安全性**的重要保障。

---

## 二、结构逻辑与学习主线

这份内容大纲的逻辑关系是循序渐进的：
1️⃣ 明确实时系统对“时间”的要求；
2️⃣ 理解操作系统（RTOS）如何支持这些要求；
3️⃣ 学习调度算法，确保任务“准时”执行；
4️⃣ 了解可能破坏调度的风险（死锁、优先级反转）；
5️⃣ 学会用协议解决这些问题（优先级上限与继承）。

也就是说，课程会从理论到实践、从单任务到多任务逐步推进，让学生理解**如何设计一个能稳定按时工作的嵌入式系统**。

---

## 三、课程重点方向

教师在这里圈出了 **“Scheduling”**，说明后续章节的重心是：
➡️ 任务调度机制如何实现；
➡️ 不同调度算法的对比与分析；
➡️ 如何保证调度不会被死锁和优先级问题破坏。

这是理解整个实时系统的关键知识点。

---

\[口语化表达]
这页其实是“实时系统”这一章的目录。
它告诉我们，这部分要学五个主题：实时性要求、实时操作系统（以 OSEK 为例）、任务调度、死锁与优先级反转、以及优先级继承机制。
老师在这里圈出了“调度（Scheduling）”，意思是这是重点，因为它关系到系统能不能在规定时间内按顺序执行任务。
后面第 4 和第 5 点其实就是调度可能遇到的问题和对应的解决办法。
简单说，这一章的核心就是：
——系统有时间要求 → 由操作系统来保证 → 用调度算法实现 → 注意避免死锁和优先级问题。


---

## 第 4 页

![第 4 页](Chapter 4 - Real-Time Systems (slides with annotations)_assets/page-004.png)

这张幻灯片讲的是 **“Real-Time Requirements（实时性需求）”**——也就是实时系统中对“时间”要求的真正含义。
标题上写着 **“Real time ≠ fast?”（实时 = 快吗？）**，并在“≠”处画了红色的强调符号，说明这是一个容易被误解的概念：**实时系统并不一定是“快”的系统**。

---

## 一、核心思想：实时 ≠ 快速

很多初学者容易把“实时系统”理解成“运行速度快的系统”，但其实这是错误的。
在嵌入式与控制领域，“实时（real-time）”的含义是——

> 系统在**规定的时间约束内**完成任务，而不是尽可能快。

也就是说，实时系统关注的是“**时间的确定性（timing correctness）**”，
而不是“计算的速度（speed）”。

---

## 二、两项关键要求

幻灯片下面列出了两个实时系统的基本要求：

1️⃣ **Computation is correct（计算是正确的）**

* 系统首先要保证**功能正确性（functional correctness）**，也就是计算结果要正确。
* 举例：汽车的刹车控制程序必须正确判断何时施加刹车，否则即使运行得很快也没用。

2️⃣ **Computation is finished in time（计算在规定时间内完成）**

* 除了正确，系统还必须**在截止时间前完成计算**。
* 举例：如果汽车检测到障碍物，但刹车信号发得太晚（例如延迟100毫秒），
即便算法本身没错，也会导致碰撞。

换句话说，在实时系统中：
✅ 结果正确 + ✅ 时间满足要求 → 系统正确
❌ 结果正确但太晚 → 系统失败

---

## 三、为什么“实时”不是“快”

“快”指的是执行速度高，但“实时”讲的是**可预测性（predictability）**。
一个实时系统可能每秒只执行几次任务，但它必须**稳定地在规定的时间点完成**。

例如：

* 飞机的自动驾驶系统每隔 100ms 更新一次状态 → 不需要更快，但必须准时。
* 医疗心率监测仪每 1 秒采样一次 → 延迟0.5秒就可能误判。

所以实时系统强调的是：

> “任务要在‘该完成的时候’完成，而不是‘越快越好’。”

---

## 四、总结性说明

这张幻灯片的目的是让学生明白：

* 实时系统的评判标准不是“速度”，而是“时间约束下的可靠性”；
* 即使处理速度再快，如果**没在规定时间内完成**，仍然不算实时；
* 因此实时系统设计更注重“时间调度”和“响应确定性”，而非单纯性能优化。

---

\[口语化表达]
这一页是在强调一个很重要的概念：**“实时系统不等于快的系统。”**
实时系统关心的不是“跑多快”，而是“在该完成的时候能不能准时完成”。
也就是说，程序要做对事，还得按时做。
比如汽车的刹车程序，反应再快也没用，如果没在0.1秒内发出刹车信号，那就算失败。
所以“实时”讲的是“准时”而不是“高速”，核心是**时间的可靠性和可预测性**。


---

## 第 5 页

![第 5 页](Chapter 4 - Real-Time Systems (slides with annotations)_assets/page-005.png)

这张幻灯片继续讲解 **“Real-Time Requirements（实时性需求）”**，重点在于说明：
在**嵌入式系统（Embedded Systems）**中，系统运行的**物理环境不会等待控制动作（Physical environment does not wait for control actions）**。
换句话说，**现实世界的事件是连续发生的，系统必须在规定时间内作出反应，否则就太迟了**。

---

## 一、图表总体说明

图中横轴代表**时间（t）**，
纵轴方向的箭头表示**事件与控制动作的触发**。

整个时间轴分为几个关键节点：
1️⃣ **event in environment（环境中发生事件）**
2️⃣ **reaction time（系统反应时间）**
3️⃣ **control action（控制动作发生）**
4️⃣ **deadline（截止时间）**
5️⃣ **too late（太迟了）**

这说明了一个典型的实时控制系统的工作过程。

---

## 二、详细解释各个部分

### 1️⃣ event in environment —— 环境事件发生

这是一个**外部触发事件**，比如：

* 汽车检测到前方障碍物；
* 传感器发现温度过高；
* 工厂流水线上产品到达指定位置。

这个时刻是系统反应的起点。

---

### 2️⃣ reaction time —— 系统反应时间

这段时间表示系统从“发现事件”到“采取行动”之间的延迟。
它包括：

* **信号采集时间**（传感器检测输入）
* **计算处理时间**（控制算法运行）
* **输出执行时间**（执行机构响应）

幻灯片上写着：

> SPS ≈ 2k max. 3...4ms – 8...7
> 这指的是 **PLC（可编程逻辑控制器）** 的典型反应时间：
> 大约几毫秒到十几毫秒之间。
> 意思是：在工业自动化中，控制系统通常需要在几毫秒内完成反应，否则会出问题。

---

### 3️⃣ control action —— 控制动作

系统在计算完毕后做出的实际响应动作，比如：

* 打开或关闭阀门；
* 启动或停止电机；
* 发出制动信号。

如果这个动作在 **截止时间（deadline）之前** 完成，就算是正确的实时响应。

---

### 4️⃣ deadline —— 截止时间

这是系统**必须完成控制动作的最晚时刻**。
如果系统在 deadline 前反应完成 → ✅ 正常。
如果超过 deadline 才响应 → ❌ too late（太迟了）。

截止时间通常由物理过程决定，比如：

* 飞机控制：必须在 20ms 内调整舵面。
* 医疗系统：必须在 100ms 内检测到心跳异常。
* 工业控制：若阀门开关延迟超过 10ms，可能造成溢出或机械损坏。

---

### 5️⃣ too late —— 太迟

当系统响应超过 deadline，结果就是：

* 无法阻止事故（比如撞车、爆炸、失控）；
* 即使算法正确，也被认为**实时性失败（real-time failure）**。

这正说明了前一页讲的“实时 ≠ 快”，
而是“在对的时间点上完成动作”。

---

## 三、核心结论

这页要传达的关键点是：

> **实时系统的最大挑战不是计算速度，而是要在物理世界的时间约束下保证反应及时。**

现实世界不会“等你算完”，
如果反应太慢，哪怕结果再对，也会导致错误或灾难性后果。

所以实时系统必须有**严格的时间分析与调度机制**，确保：

* 所有事件都有最大响应时间（reaction time）保证；
* 系统永远不会错过截止时间（deadline）。

---

\[口语化表达]
这一页其实是在告诉我们：现实世界不会等电脑慢慢想。
当环境发生事件，比如温度太高、物体靠近、压力超标，系统必须在限定的时间内反应。
图上那根“reaction time”就是系统从发现问题到做出控制动作的反应时间。
如果动作在“deadline”前完成，就OK；
要是晚了哪怕一毫秒，就叫“too late”，可能已经出事故了。
所以实时系统讲的不是“算得多快”，而是“能不能每次都在该反应的时候，准时出手”。


---

## 第 6 页

![第 6 页](Chapter 4 - Real-Time Systems (slides with annotations)_assets/page-006.png)

这张幻灯片讲的是 **实时系统的两种类型：Hard Real-Time（硬实时）和 Soft Real-Time（软实时）** 的区别。
标题 “Hard vs. soft real-time requirements” 说明这页内容的重点在于比较两类系统对时间要求的严格程度。

---

## 一、总体理解

实时系统都要求任务**在规定时间内完成**，但“规定时间”可以是**绝对的**（硬实时）或**相对的、可容忍的**（软实时）。
因此，这一页主要告诉我们：

> 硬实时系统追求 **“绝不能超时”**，
> 软实时系统追求 **“大多数情况下准时就可以”**。

---

## 二、左图：Hard Real-Time（硬实时）

左边的图是一条直线在 **截止时间 DL（Deadline）** 处突然下降的方形曲线。

* **纵轴（y轴）**：表示系统反应的“正确性”或“可接受性”，100% 意味着反应完全有效。
* **横轴（x轴）**：时间（t）。

在截止时间 DL 之前，系统反应完全有效（100%）。
但 **一旦超过 DL，反应立即变为 0%——完全无效！**

这说明在硬实时系统中：

* 截止时间是**绝对的、不可违反的**；
* **任何延迟都意味着系统失败**，即使只差一毫秒。

幻灯片左上角的红字 *“Nicht zulässig”* 是德语，意思是 **“不允许的（Not permitted）”**，强调超时绝对不可以。

典型例子：

* 汽车安全气囊系统（Airbag）：必须在碰撞后 30ms 内触发；
* 飞机姿态控制系统：超时可能导致坠机；
* 医疗植入设备（如心律调节器）：延迟可能危及生命。

因此，硬实时系统的主要特征是：

> **确定性（Deterministic）**——永远在时间约束内完成。

---

## 三、右图：Soft Real-Time（软实时）

右边的曲线在截止时间 DL 处没有“断崖式下降”，而是平滑地逐渐下降。

这意味着：

* 在截止时间之前完成反应 → 完全正确（100%）。
* 超过截止时间一点点 → 仍然可以接受（反应价值下降，但系统不立即失败）。
* 反应越晚，效果越差，直到无效（0%）。

底部文字写着：

> **“statistically a sufficient number of reactions in time”**
> 意思是：只要在统计上大多数反应都能准时完成，系统就可以接受。

典型例子：

* 视频播放系统：偶尔掉一帧不影响整体体验；
* 在线语音通话：有一点点延迟也能容忍；
* 游戏帧率波动：偶尔卡顿不会导致系统失败。

因此软实时系统关注的是**性能平均值（平均响应质量）**，而不是“绝对按时”。

---

## 四、对比总结

| 项目   | 硬实时系统 (Hard Real-Time) | 软实时系统 (Soft Real-Time)        |
| ---- | ---------------------- | ----------------------------- |
| 时间约束 | 严格，绝对不能超过截止时间          | 可接受偶尔的超时                      |
| 超时后果 | 系统错误或灾难性后果             | 性能下降但系统仍可运行                   |
| 目标   | 确定性（Determinism）       | 平均性能（Statistical Sufficiency） |
| 示例   | 汽车安全气囊、航天控制、心脏起搏器      | 视频播放、网络通信、语音识别                |

---

## 五、课程意图

通过这页幻灯片，老师想让学生理解：

* “实时”系统不是一个固定概念，而是**分等级的时间要求**；
* 不同场景下，实时性的定义不同；
* 设计嵌入式系统时，必须先明确是硬实时还是软实时，才能选择合适的操作系统与调度策略。

---

\[口语化表达]
这页是在讲实时系统其实有两种：硬的和软的。
左边那张方形图是“硬实时”，意思是——只要一过截止时间就彻底失败，不存在“差不多行”。
像安全气囊、心脏起搏器这种，慢一毫秒都不行。
右边那张弯曲的图是“软实时”，超时一点没关系，效果会差点，但还能接受，比如视频卡一帧、语音延迟几毫秒。
所以“硬实时”是绝对不能迟，“软实时”是大部分时候准时就好。


---

## 第 7 页

![第 7 页](Chapter 4 - Real-Time Systems (slides with annotations)_assets/page-007.png)

这张幻灯片的主题是：
**“How to Fulfill Real-Time Requirements?”（如何满足实时性需求？）**
它介绍了实现实时控制系统的三种主要方法：**轮询（Polling）**、**主循环与中断（Main loop and interrupts）**、以及**实时操作系统（Real-Time Operating System, RTOS）**。

红色标注框特别强调了前两种方式（Polling 和 Main loop + Interrupts），说明这节课讲的重点是这些**低层次的实现方法**，适用于简单或单处理器系统。

---

## 一、总体理解：为什么要“满足实时性要求”

在嵌入式系统中，我们必须保证系统在特定的\*\*时间约束（time constraints）\*\*内完成任务。
所以设计者需要选择合适的方式去“控制任务执行顺序与响应速度”。
幻灯片就是在说明三种不同复杂度的实现策略，从最简单到最复杂：

1️⃣ **Polling（轮询）**
2️⃣ **Main loop and interrupts（主循环 + 中断）**
3️⃣ **Real-time operating system（实时操作系统）**

---

## 二、方法 1：Polling（轮询）

**Polling** 是最基础、最简单的实时控制方法。
它的原理是：

> 系统不断地在循环中检查各个输入状态或传感器，看看是否发生了事件。

📘 举例：
假设系统需要检测按钮是否被按下并控制LED灯，轮询方式就是：

```c
while(1){
if(button_pressed()) turn_on_LED();
}
```

特点如下：

* 结构简单，代码容易理解；
* 不需要中断或操作系统支持；
* 但 CPU 一直在“忙等”（busy waiting），效率低；
* 响应时间取决于轮询周期，可能出现延迟。

⚙️ 适用场景：
只需要处理少量简单任务的系统，如简单传感器监控或小型嵌入设备。

---

## 三、方法 2：Main loop and interrupts（主循环 + 中断）

这是在轮询的基础上更进一步的做法。
主循环负责执行常规任务，而**中断（interrupt）**机制用于**立即响应关键事件**。

🔹 工作原理：

* 主循环执行周期性任务；
* 一旦有外部事件（如传感器信号、通信中断等）触发中断，CPU 立刻暂停当前操作，跳转到中断处理程序执行；
* 处理完中断后再返回主循环。

📘 举例：
当传感器检测到温度超标时，触发中断，系统立即启动冷却装置，而不必等主循环下一次检查。

🔹 优点：

* 响应速度快；
* 节省CPU资源，不用“傻等”；
* 可保证关键任务优先执行。

🔹 缺点：

* 编程复杂度提高；
* 多中断同时发生时需要设计优先级机制；
* 可能出现“中断风暴”或竞态问题。

🧠 红色手写备注“1 processor, n tasks”意思是：

> 在这种方式下，一个处理器（CPU）可以通过中断机制同时处理多个任务（n 个 task）。

这是从单任务系统向**多任务调度系统**的过渡阶段。

---

## 四、方法 3：Real-Time Operating System（实时操作系统）

这是一种更高级的方案。
当任务数量较多且复杂，依靠手动编写循环和中断难以管理时，就需要 RTOS。

RTOS 提供：

* **任务调度（task scheduling）**；
* **优先级管理（priority management）**；
* **同步与通信机制（mutex, semaphore 等）**；
* 保证高优先级任务能在规定时间内执行。

这样，开发者不必再手动控制每个任务的时间，只需要定义优先级，系统自动保证实时性。

---

## 五、总结与对比

| 方法                     | 实现复杂度 | 响应速度       | 适用场景      |
| ---------------------- | ----- | ---------- | --------- |
| Polling                | 简单    | 慢（受轮询周期限制） | 小型、简单系统   |
| Main loop + Interrupts | 中等    | 快（中断即时响应）  | 单CPU多任务系统 |
| RTOS                   | 高     | 可控、确定性强    | 多任务复杂系统   |

---

\[口语化表达]
这一页是在讲：要想让系统能“准时反应”，我们有三种办法。
第一种最简单——**轮询（Polling）**，系统一直循环检查有没有事发生，比如不停地问“按钮按了吗？”。但这样CPU很累，反应也可能慢。
第二种——**主循环加中断（Main loop + Interrupts）**，就是平时做日常工作，有紧急情况就被打断去处理，中断结束后再回来继续做事。这种方式快多了，也能同时管好几个任务。
最后一种就是用**实时操作系统（RTOS）**，让系统自动帮我们分配任务、控制优先级，专门保证“谁该先做谁后做”，更适合复杂场景。
简单来说，这三种方法就是：\*\*从“一个人自己管一切”到“有系统帮忙管时间”\*\*的进化过程。


---

## 第 8 页

![第 8 页](Chapter 4 - Real-Time Systems (slides with annotations)_assets/page-008.png)

Something went wrong while generating the response. If this issue persists please contact us through our help center at help.openai.com.


---

## 第 9 页

![第 9 页](Chapter 4 - Real-Time Systems (slides with annotations)_assets/page-009.png)

这张幻灯片讲的是 **OSEK 的历史（OSEK: History）**，也就是汽车电子领域中一种非常重要的**实时操作系统标准的起源与发展过程**。OSEK 是车载嵌入式系统的基础之一，它为不同厂商的汽车电子设备提供了一个**统一的软件接口和通信标准**。

---

## 一、OSEK 的起源（1993 年）

在 1993 年，德国发起了一个项目，名字是：

> “**Offene Systeme und deren Schnittstellen für Elektronik im Kraftfahrzeug**”
> （翻译为：*开放式系统及其在汽车电子中的接口*）

这是一个**国家级汽车电子系统标准化项目**，目标是：

* 为汽车内的控制单元（ECU）建立**标准化的软件接口**；
* 解决不同制造商（如 Bosch、BMW、Mercedes 等）之间系统不兼容的问题；
* 让汽车电子系统更容易集成、维护和扩展。

该项目由 **德国卡尔斯鲁厄大学（University of Karlsruhe）** 的 **Kiencke 教授** 牵头协调。
他是汽车控制与实时系统领域的重要学者，对嵌入式系统标准化有很大贡献。

因此，**OSEK** 这个词实际上来自德语缩写：

> **O**ffene **S**ysteme und deren **E**inbindungen in **K**raftfahrzeuge
> （意为“汽车中的开放系统”）

---

## 二、OSEK 与法国合作（1994 年）

在 1994 年，法国的汽车厂商 **PSA（标致雪铁龙）** 和 **Renault（雷诺）** 也加入了这项工作。
他们有一个类似的研究项目，名字是：

> **Vehicle Distributed Executive (VDX)** —— “车辆分布式执行系统”

德国的 OSEK 项目与法国的 VDX 项目目标非常接近，于是两方决定**联合合作**，
从此诞生了新的统一标准：

> **OSEK/VDX**

这是汽车电子史上的一个重要时刻，因为它标志着欧洲主要汽车制造商**共同制定了统一的嵌入式实时系统标准**。

---

## 三、OSEK 的现状：成为 ISO 国际标准

幻灯片上写着：

> “Today: ISO standard”

意思是 OSEK/VDX 已经不再只是一个欧洲研究项目，而是成为了正式的 **ISO（国际标准化组织）标准**。
该标准的编号是：

> **ISO 17356（Road vehicles — Open systems and the corresponding interfaces for automotive electronics）**

这意味着：

* 全球汽车制造商都可以采用相同的实时操作系统接口；
* 不同厂商的软件组件能在相同标准下运行；
* 大大提高了软件复用性与系统可靠性。

---

## 四、红色手写内容说明

幻灯片下方的红字：

> “AUTOSAR OS, VECTOR, ETAS”

这些代表了 OSEK 的后续发展与应用：

1️⃣ **AUTOSAR OS**

* AUTOSAR（Automotive Open System Architecture，汽车开放系统架构）是现代汽车软件平台的主流标准；
* AUTOSAR 的操作系统（OS）就是基于 OSEK/VDX 的理念发展而来的；
* 可以认为 **OSEK 是 AUTOSAR OS 的前身**。

2️⃣ **VECTOR, ETAS**

* 这两个是提供 OSEK/AUTOSAR 实现的知名公司：

* **Vector**：德国软件公司，提供车载通信和实时操作系统工具；
* **ETAS**：博世（Bosch）旗下的软件公司，专注于汽车嵌入式系统开发。
* 它们都在商业上实现并推广了基于 OSEK 的操作系统解决方案。

---

## 五、总结对比

| 时间      | 事件                   | 意义                      |
| ------- | -------------------- | ----------------------- |
| 1993    | 德国启动 OSEK 项目         | 汽车电子系统接口标准化             |
| 1994    | 与法国 VDX 合并为 OSEK/VDX | 欧洲统一的车载控制系统标准           |
| 2000s 后 | 成为 ISO 标准            | 全球通用，推广为 AUTOSAR OS 的基础 |
| 今天      | 广泛用于现代汽车控制单元（ECU）    | 由 Vector、ETAS 等公司实现     |

---

\[口语化表达]
这一页讲的是 OSEK 标准的诞生史。
最早在 1993 年，德国搞了个项目，名字挺长，意思是“让汽车里的电子系统都用统一的开放接口”，由卡尔斯鲁厄大学的 Kiencke 教授带头。
一年后，法国的标致和雷诺也有类似的项目，于是双方决定合并，搞出了“**OSEK/VDX**”这个统一标准。
后来，这个标准被正式收进 ISO，也就是说变成了国际标准。
现在的汽车操作系统，比如 **AUTOSAR OS**，其实就是在 OSEK 的基础上发展出来的。
像 **Vector** 和 **ETAS** 这些公司，现在都在用这个标准做汽车控制系统的软件。
一句话总结：**OSEK 是现代汽车软件系统的鼻祖，它让不同厂商的车载电子能说“同一种语言”。**


---

## 第 10 页

![第 10 页](Chapter 4 - Real-Time Systems (slides with annotations)_assets/page-010.png)

这张幻灯片讲的是 **OSEK 实时操作系统的任务模型（OSEK: Task Model）**，也就是任务在执行过程中可能处于的不同状态（States）以及这些状态之间的转换（Transitions）。
简单来说，这页是在告诉我们：**OSEK 是如何管理和调度任务的。**

---

## 一、整体理解

OSEK 是一个用于汽车嵌入式系统的轻量级实时操作系统。
在这个系统中，每个“任务（Task）”并不是一直运行的，而是根据系统的调度情况，在不同的状态之间切换。
这些状态反映了任务的**生命周期**，包括：

* 等待被启动；
* 准备执行；
* 正在运行；
* 被中断或等待；
* 执行结束等。

这张图展示的就是任务从开始到结束的各种可能状态变化路径。

---

## 二、任务的主要状态及含义

图中共有四个核心状态（蓝色部分是基本模型，红色部分是扩展模型）：

### 1️⃣ **suspended（挂起/未激活）**

* 表示任务还没有被系统激活（Activate）。
* 它处于“闲置”（idle）状态，不参与调度。
* 当系统调用 `ActivateTask()` 时，任务会进入 **ready（就绪）** 状态。
💬 红色手写“idle” 就是指这个阶段任务处于“空闲”。

---

### 2️⃣ **ready（就绪）**

* 任务已经被激活，但还没有开始执行。
* 它在等待调度器分配 CPU。
* 如果 CPU 空闲或者该任务的优先级最高，则进入 **running（运行中）** 状态。
➡️ 转换箭头：

* `activate`（激活）→ ready
* `start` 或 `dispatch` → running

---

### 3️⃣ **running（运行中）**

* 任务正在被 CPU 执行。
* 在 OSEK 系统中，运行中的任务可能会：

* **被抢占（pre-empt）**：如果有更高优先级任务准备就绪；
* **等待资源或事件（wait）**：任务主动挂起自己；
* **正常结束（terminate）**：任务完成后自动回到 suspended 状态。

➡️ 从 running 出发的几种路径：

* `terminate` → suspended
* `wait` → waiting
* `pre-empt` → ready（被更高优先级任务抢占）

---

### 4️⃣ **waiting（等待中）**（仅在扩展模型中出现）

* 扩展模型用于支持更复杂的任务同步机制，例如任务等待某个\*\*事件（event）\*\*发生。
* 任务会暂时停止执行，直到事件被触发（release），再回到 ready 状态。
➡️ 路径：
* `wait`（进入等待）
* `release`（事件到来后被唤醒）

---

## 三、状态转换总结

可以把它想成任务的“流转流程”：

```
suspended → (activate) → ready → (start) → running
running → (wait) → waiting → (release) → ready
running → (terminate) → suspended
running → (pre-empt) → ready
```

也就是说，一个任务从被激活到执行，再到被挂起、等待、重新唤醒或结束，整个生命周期由操作系统调度机制来自动控制。

---

## 四、OSEK 的两种任务模型

幻灯片右上角写着：

> “Basic Task model with and without preemption”
> 意思是：

* **基本任务模型（Basic Task）** 可以是 **可抢占** 或 **不可抢占** 的；
* **扩展任务模型（Extended Task）** 则支持更多特性，比如等待事件（waiting）。

对比：

| 类型            | 特征                              | 是否可等待事件 |
| ------------- | ------------------------------- | ------- |
| Basic Task    | 只支持 ready → running → suspended | ❌ 不支持   |
| Extended Task | 可进入 waiting 状态                  | ✅ 支持    |

💬 左边红色“Extended Task model” 就是指扩展模型，增加了 waiting 状态。

---

## 五、红色手写标注解释

* **上方德语红字：** “für die Zustände, in denen sich Tasks befinden”
意思是 “任务可能处于的这些状态”。
* **红箭头 idle：** 表示 suspended 状态对应空闲。

---

## 六、总结思维图

| 状态            | 说明       | 可能的下一步                                                    |
| ------------- | -------- | --------------------------------------------------------- |
| **Suspended** | 未激活 / 空闲 | activate → ready                                          |
| **Ready**     | 等待调度     | start → running                                           |
| **Running**   | 正在执行     | pre-empt → ready / wait → waiting / terminate → suspended |
| **Waiting**   | 等待事件触发   | release → ready                                           |

---

\[口语化表达]
这页是在讲 OSEK 操作系统里“任务的生命周期”，也就是任务从开始到结束可能经历的几个阶段。
最开始任务是“挂起”的（suspended），系统一激活它就变成“就绪”（ready）；
等 CPU 空出来，它就被调度去“运行”（running）；
运行时可能被打断（pre-empt）回到就绪，也可能在等待事件时进入“等待”（waiting）；
等任务做完了，就会“终止”（terminate）回到挂起状态。
简单来说，一个任务就像一个人：先待命（suspended），准备好（ready），开始干活（running），有事等一下（waiting），干完活下班（terminate）。
OSEK 的扩展模型还多了“waiting”这个状态，用来支持更复杂的任务同步，比如“等信号再继续”。


---

## 第 11 页

![第 11 页](Chapter 4 - Real-Time Systems (slides with annotations)_assets/page-011.png)

这张幻灯片讲的是 **OSEK 实时操作系统中的调度方式（Scheduling）**，
尤其是两种不同的任务调度机制：
👉 **Preemptive（抢占式调度）**
👉 **Non-Preemptive / Cooperative（非抢占式调度，也叫协作式调度）**。

它通过对比图，直观说明了这两种调度模式的差异、优缺点和对任务执行的影响。

---

## 一、背景知识：什么是“调度（Scheduling）”

在一个实时操作系统中，可能有多个任务（Tasks）需要运行。
但由于 CPU 通常只有一个核心，一次只能执行一个任务。
所以操作系统要决定：

> “谁先执行？执行多久？如果有更重要的任务来了，怎么办？”

这就是“调度”的作用。

OSEK 支持两种调度策略：

1. **抢占式（Preemptive）调度**；
2. **非抢占式（Cooperative）调度**。

---

## 二、抢占式调度（Preemptive Scheduling）

左边的图展示的是**抢占式调度**的情况。

### 场景描述：

* 一开始，**任务 A** 被激活（act. A），开始运行；
* 一段时间后，**任务 B** 被激活（act. B），但它的**优先级高于任务 A**；
* 系统检测到更高优先级任务到来，就会**立即中断任务 A**，转而让任务 B 运行；
* 等 B 执行完（termination）后，系统再让 A 继续运行。

这就叫做\*\*“抢占（preemption）”\*\*，
意思是高优先级任务可以“抢走”CPU的使用权。

---

### 图中分析：

* 纵轴：任务（Task A、Task B）
* 横轴：时间（t）
* 蓝线“deadline A” 表示任务 A 的截止时间。
* 红色箭头表示任务切换（context switch）。

我们看到：

* A 被启动（act. A）后进入 running 状态；
* B 到来（act. B）时，因为优先级更高，A 被暂停（进入 ready 状态）；
* B 执行完后，A 才继续完成。

---

### 优点：

✅ **响应速度快**
— 高优先级任务可以立刻运行，对紧急事件反应迅速。

✅ **保证关键任务的实时性**
— 重要任务不会被低优先级任务阻塞。

---

### 缺点：

❌ **上下文切换（Context Switching）有开销**
— 每次任务切换都要保存/恢复寄存器状态，消耗 CPU 时间。

❌ **低优先级任务可能被“饿死”**
— 如果高优先级任务不断到来，低优先级任务可能永远得不到执行机会。
（幻灯片下方写着 “Low priority task can starve”）

---

## 三、非抢占式调度（Non-Preemptive / Cooperative Scheduling）

右边的图展示了另一种调度方式：**非抢占式（协作式）调度**。

### 场景描述：

* **任务 A** 先被激活并开始执行；
* 之后 **任务 B** 被激活；
* 但即使 B 的优先级更高，系统不会打断 A。
它必须等 A 自己执行完（termination），CPU 才会切换到 B。

这种方式叫“**协作式调度（Cooperative Scheduling）**”，
因为系统不会强制切换，而是依靠任务之间\*\*“自觉让出”\*\*CPU。

---

### 优点：

✅ **实现简单，切换开销小**
— 没有频繁的上下文切换。

✅ **任务执行更可预测**
— 当前任务不会被打断，执行时间容易估计。

---

### 缺点：

❌ **高优先级任务响应慢**
— 必须等低优先级任务执行完才能运行。

❌ **可能错过截止时间（Deadline Miss）**
— 如果 A 执行太久，B 即使很紧急也得等。

---

## 四、总结对比表

| 特性    | 抢占式（Preemptive） | 非抢占式（Cooperative） |
| ----- | --------------- | ----------------- |
| 优先级处理 | 高优先级任务可中断低优先级任务 | 必须等低优先级任务完成       |
| 响应时间  | 快               | 慢                 |
| 上下文切换 | 多，开销大           | 少，效率高             |
| 可预测性  | 低（随时被中断）        | 高（任务执行完整）         |
| 实时性   | 强               | 弱                 |
| 实现复杂度 | 较高              | 较低                |

---

## 五、图中的红色手写注释说明

* 左上角的“**Pre-emptiv**” 是德语的 “抢占式”；
* “**Priorität**” 表示“优先级”；
* 右上角的 “**cooperative**” 表示“协作式调度”；
* 图下方文字说明：

* “Context swapping takes time” → 上下文切换耗时；
* “Low priority task can starve” → 低优先级任务可能被“饿死”（永远无法运行）。

---

\[口语化表达]
这页讲的是两种任务调度方式的区别。
左边是“**抢占式**”——高优先级任务一来就能马上抢走 CPU，低优先级任务会被打断；
右边是“**协作式**”——任务自己干完才让别人上，不会被强行中断。
抢占式的好处是反应快，但切换频繁、低优先级任务可能永远跑不到；
协作式的好处是简单稳定，但可能太慢，重要任务要等别人做完。
总结一句话：
👉 抢占式像“老板插话”，实时但打断多；
👉 协作式像“排队发言”，公平但容易拖。
