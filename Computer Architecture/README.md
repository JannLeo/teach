# Computer Architecture ECS 154A

- 学生信息：

  202408260001
  后台姓名：高正青
  用户ID：76129
  用户1V1昵称：George
  学生需求类型：作业辅导
  学生基础：一般
  期望上课时间：尽快，一般下午和晚上可以美西时间
  学生DUE时间：8/28美西时间
  用户类型：1v1老用户
  院校：UCD
  年级：大三
  专业：土木
  科目代码：ECS 154A
  科目名称：Computer Architecture
  备注：需要老师辅导思路，需要效率比较高的老师，讲课逻辑清晰。（学生跨专业，基础应该是比较差的）

- ## Panel部分

  - 要设计Panel电路，你需要将12个按钮的输入转换为4位的按钮代码（B3-B0）和一个有效位（V）。这是Panel电路设计的步骤：

    ### 1. 按钮矩阵的理解
    - 这个12按钮的面板是一个4行3列的矩阵（R0-R3，C0-C2）。
    - 每个按钮按下时，都会有相应的行和列输出高电平（1）。
    - 例如，按下按钮“1”时，行R0和列C0都会输出高电平。

    ### 2. 有效位（V）的设计
    - **目标**：只有当且仅当一个按钮被按下时，V才为1，否则为0。
    - **实现**：
      1. 检查是否有且仅有一个行信号为高电平，同时仅有一个列信号为高电平。如果满足这个条件，设置V=1，否则V=0。

    **实现逻辑**：
    ```plaintext
    V = (R0 XOR R1 XOR R2 XOR R3) AND (C0 XOR C1 XOR C2)
    ```
    这段逻辑表示如果只有一个行信号和一个列信号为高电平，V将被设置为1。

    ### 3. 按钮代码（B3-B0）的设计
    - **目标**：将按钮矩阵中的每个按钮对应到一个唯一的4位二进制代码。
    - **实现**：
      1. 每个按钮按下时，你需要生成相应的4位代码。例如：
         - 按钮“1”对应代码`0001`
         - 按钮“2”对应代码`0010`
         - 按钮“L”对应代码`1010`
         - 按钮“U”对应代码`1011`

      2. 你可以使用组合逻辑来实现这一点。具体来说，B3-B0可以通过结合行信号和列信号生成。例如，按钮“1”处于行R0和列C0，因此可以通过以下逻辑生成：
         - B3: (R0 AND C0)
         - B2: (R0 AND C0)
         - B1: (R0 AND C0)
         - B0: (R0 AND C0)

    **实现逻辑**：
    ```plaintext
    B3 = R1 AND (C1 OR C2) OR R3 AND (C1 OR C2)
    B2 = R2 AND (C0 OR C2) OR R3 AND (C0 OR C2)
    B1 = R0 AND C2 OR R1 AND (C1 OR C2) OR R2 AND C1 OR R3 AND C1
    B0 = R0 AND (C0 OR C2) OR R1 AND C0 OR R2 AND C0 OR R3 AND C0
    ```

    ### 4. 电路实现
    - **步骤**：
      1. 使用**AND**、**OR**、**NOT**门来实现上述逻辑。
      2. 将行信号（R0-R3）和列信号（C0-C2）输入到逻辑电路中，产生输出B3-B0和有效位V。

    ### 5. Logisim Evolution中的实现
    - 打开Logisim Evolution，并创建一个新电路。
    - 使用`Input Pin`来表示R0-R3和C0-C2信号。
    - 使用逻辑门来实现上述的逻辑电路。
    - 添加`Output Pin`来表示输出的B3-B0和V。

    这样，你就可以完成Panel电路的设计。这个电路的功能是检测按下的按钮并将其转换为一个按钮代码，同时输出一个有效位表示是否有按钮被按下。

- ## InputBuffer部分

  - InputBuffer电路的设计目标是将来自Panel电路的按钮代码和有效位进行缓冲处理，确保在每次按钮按下时，输出的按钮代码保持一个时钟周期，并在下一个周期清除（返回无效代码1111）。下面是设计InputBuffer电路的步骤：

    ### 1. 设计需求回顾
    - **输入**：
      - 按钮代码（B3-B0）：4位二进制数，表示按下的按钮。
      - 有效位（V）：1位，表示当前是否有按钮被按下。
      - 时钟信号（CLK）：用于控制输入缓冲的时序。

    - **输出**：
      - 缓冲后的按钮代码（C3-C0）：与B3-B0相同，但经过缓冲处理。
      
    ### 2. 状态机设计
    这个电路可以使用一个简单的状态机来实现。状态机包括以下几个状态：

    - **等待有效输入状态（Idle）**：
      - 当V=0时，保持在这个状态，输出代码为`1111`（表示无效）。
      - 当V=1时，转移到“缓冲输入状态”。

    - **缓冲输入状态（Buffer）**：
      - 当V=1时，输出当前的按钮代码（C3-C0），并在一个时钟周期后转移到“重置状态”。
      
    - **重置状态（Reset）**：
      - 在这个状态下，输出代码重置为`1111`，表示无效。然后返回到“等待有效输入状态”。

    ### 3. 实现步骤
    #### 1. 状态寄存器
    - 使用D触发器来存储当前状态。你需要至少两个D触发器来存储状态信息。

    #### 2. 状态转移逻辑
    - 根据当前状态和输入（V、CLK）决定状态的转移。你可以使用组合逻辑来实现状态的转移条件。

    #### 3. 输出逻辑
    - 根据状态输出对应的按钮代码（C3-C0）。
    - 如果当前处于“缓冲输入状态”，输出按钮代码与输入的按钮代码一致。
    - 如果当前处于“等待有效输入状态”或“重置状态”，输出按钮代码为`1111`。

    ### 4. 电路实现
    **状态机逻辑示例**：
    - **状态寄存器**：使用D触发器保存当前状态。
    - **组合逻辑**：实现状态转移的组合逻辑。
    - **输出逻辑**：根据当前状态输出对应的按钮代码。

    **具体步骤**：
    1. **状态寄存器**：
       - 使用Logisim Evolution中的D触发器（D Flip-Flop）来保存当前状态。
       - 你需要定义两个状态：`Idle`和`Buffer`，可以分别用二进制`0`和`1`来表示。

    2. **状态转移逻辑**：
       - 通过`AND`、`OR`、`NOT`门来实现状态转移的条件。
       - 例如，当V=1且当前状态为`Idle`时，转移到`Buffer`状态。
       - 在`Buffer`状态下，当时钟信号上升沿时，转移到`Reset`状态。

    3. **输出逻辑**：
       - 使用多路复用器（Mux）或`AND`、`OR`门实现输出选择。
       - 如果状态为`Buffer`，输出C3-C0与输入的B3-B0一致。
       - 如果状态为`Idle`或`Reset`，输出C3-C0为`1111`。

    ### 5. Logisim Evolution中的实现
    1. **输入**：从Panel电路的输出B3-B0和V，连接到InputBuffer的输入。
    2. **状态寄存器**：使用D触发器创建状态寄存器。
    3. **状态转移逻辑**：使用组合逻辑来实现状态转移。
    4. **输出**：将输出连接到面板，检查C3-C0的输出是否符合设计要求。

    通过这个电路设计，InputBuffer会在每次有效的按钮按下时，输出一个时钟周期的按钮代码，然后清除该代码等待下一次按钮输入。

- ## Lock部分

  - Lock电路是整个系统的核心部分，用于控制锁的开关状态。这个电路需要根据输入的按钮代码执行一系列操作，如锁定、解锁、更新解锁组合等。以下是设计Lock电路的详细步骤：

    ### 1. 设计需求回顾
    - **输入**：
      - 缓冲后的按钮代码（C3-C0）：从InputBuffer电路输入的4位按钮代码。
      - 时钟信号（CLK）：用于同步状态转换。

    - **输出**：
      - 锁定信号（L）：用于锁定电机，1表示锁定，0表示不锁定。
      - 解锁信号（U）：用于解锁电机，1表示解锁，0表示不解锁。

    ### 2. 状态机设计
    Lock电路的设计可以使用一个状态机来管理不同的锁状态和操作。状态机包括以下几个状态：

    1. **Unlocked（解锁状态）**：初始状态，锁处于解锁状态。
    2. **Locking（正在锁定状态）**：接收到正确的锁定代码，进入锁定状态，输出L=1，保持4个时钟周期。
    3. **Locked（锁定状态）**：锁已被锁定，等待解锁命令。
    4. **Unlocking（正在解锁状态）**：接收到正确的解锁代码，进入解锁状态，输出U=1，保持4个时钟周期。

    ### 3. 逻辑实现步骤
    #### 1. 状态寄存器
    - 使用D触发器或其他状态存储器件来保存当前状态。

    #### 2. 状态转移逻辑
    - 通过检测输入代码（C3-C0）决定状态转移。
      - **锁定逻辑**：当处于`Unlocked`状态时，如果接收到两次L代码（1010）或L代码后紧跟着三位解锁组合（自定义），则进入`Locking`状态。
      - **解锁逻辑**：当处于`Locked`状态时，如果接收到U代码（1011）加上正确的三位解锁组合，则进入`Unlocking`状态。

    #### 3. 输出逻辑
    - **锁定状态输出（L）**：
      - 当进入`Locking`状态时，输出L=1，并保持4个时钟周期，之后返回L=0，并转移到`Locked`状态。
      
    - **解锁状态输出（U）**：
      - 当进入`Unlocking`状态时，输出U=1，并保持4个时钟周期，之后返回U=0，并转移到`Unlocked`状态。

    ### 4. 状态机的实现逻辑
    #### 1. Unlocked 状态
    - **输入**：检测是否接收到两次L代码或L代码后紧跟三位解锁组合。
    - **输出**：当满足锁定条件时，进入`Locking`状态。

    #### 2. Locking 状态
    - **输入**：在进入该状态后，保持L=1四个时钟周期。
    - **输出**：四个时钟周期后，进入`Locked`状态，并将L重置为0。

    #### 3. Locked 状态
    - **输入**：检测是否接收到U代码和正确的解锁组合。
    - **输出**：当满足解锁条件时，进入`Unlocking`状态。

    #### 4. Unlocking 状态
    - **输入**：在进入该状态后，保持U=1四个时钟周期。
    - **输出**：四个时钟周期后，进入`Unlocked`状态，并将U重置为0。

    ### 5. 实现示例
    **状态机逻辑**：
    - **状态寄存器**：使用D触发器保存当前状态。
    - **状态转移逻辑**：使用组合逻辑实现状态转移条件。
    - **计数器**：用于计时，确保在`Locking`和`Unlocking`状态下输出信号持续4个时钟周期。

    **具体步骤**：
    1. **状态寄存器**：用D触发器实现状态存储。
    2. **计数器**：在`Locking`和`Unlocking`状态下启动计数器，计数达到4个时钟周期后转移到下一个状态。
    3. **状态转移逻辑**：根据输入的C3-C0按钮代码和当前状态，决定状态转移条件。
    4. **输出逻辑**：根据当前状态决定输出L和U信号。

    ### 6. Logisim Evolution中的实现
    1. **输入**：将InputBuffer的输出C3-C0和时钟信号CLK连接到Lock电路。
    2. **状态寄存器**：使用D触发器创建状态寄存器。
    3. **计数器**：在`Locking`和`Unlocking`状态下实现4周期计数。
    4. **输出**：根据状态控制L和U的输出。

    通过设计这个Lock电路，你将能够实现一个简单的数字锁系统，能够处理锁定、解锁以及更新解锁组合的操作。